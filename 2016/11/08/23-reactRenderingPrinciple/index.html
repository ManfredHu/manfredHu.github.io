<!-- build time:Wed Oct 24 2018 15:05:57 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="true"><meta name="MobileOptimized" content="320"><meta name="msapplication-tap-highlight" content="no"><title>react + reflux 渲染性能优化原理 | ManfredHu胡文峰的个人博客</title><meta name="keywords" content="ManfredHu, pphu, 胡文峰, Tencent, Front-end development engineer, Reactjs, Reflux, Nodejs"><meta name="description" content="ReactReact的优点有很多，现在很多应用都接入React这个框架。在我看来，有下列优点：Facebook团队研发并维护——有团队维护更新且有质量保证在MVVM结构下只起View的作用——简单接入，不需要花费大量人力重构代码组件化形式构建Web应用——复用性强，提高开发效率用Virtual DOM减少对DOM的频繁操作提高页面性能——批量操作减少重排（reflows）和重绘(repaints)"><meta name="keywords" content="分享,React"><meta property="og:type" content="article"><meta property="og:title" content="React + Reflux 渲染性能优化原理"><meta property="og:url" content="http://www.manfredhu.com/2016/11/08/23-reactRenderingPrinciple/index.html"><meta property="og:site_name" content="ManfredHu胡文峰的个人博客"><meta property="og:description" content="ReactReact的优点有很多，现在很多应用都接入React这个框架。在我看来，有下列优点：Facebook团队研发并维护——有团队维护更新且有质量保证在MVVM结构下只起View的作用——简单接入，不需要花费大量人力重构代码组件化形式构建Web应用——复用性强，提高开发效率用Virtual DOM减少对DOM的频繁操作提高页面性能——批量操作减少重排（reflows）和重绘(repaints)"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.manfredhu.com/images/react.png"><meta property="og:image" content="http://www.manfredhu.com/images/github/repaintAndReflow.JPG"><meta property="og:image" content="http://www.manfredhu.com/images/github/componentProblem.JPG"><meta property="og:image" content="http://www.manfredhu.com/images/github/reflux.JPG"><meta property="og:image" content="http://www.manfredhu.com/images/github/SCUAndvDOMEqual.JPG"><meta property="og:image" content="http://www.manfredhu.com/images/github/1basicDemo.png"><meta property="og:image" content="http://www.manfredhu.com/images/github/2perfDemo.png"><meta property="og:image" content="http://www.manfredhu.com/images/github/3pureRenderMixinDemo.png"><meta property="og:image" content="http://www.manfredhu.com/images/github/4updateDemo.png"><meta property="og:image" content="http://www.manfredhu.com/images/github/5immutable_set.png"><meta property="og:image" content="http://www.manfredhu.com/images/github/5immutableDemo_update.png"><meta property="og:updated_time" content="2017-04-05T13:44:04.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="React + Reflux 渲染性能优化原理"><meta name="twitter:description" content="ReactReact的优点有很多，现在很多应用都接入React这个框架。在我看来，有下列优点：Facebook团队研发并维护——有团队维护更新且有质量保证在MVVM结构下只起View的作用——简单接入，不需要花费大量人力重构代码组件化形式构建Web应用——复用性强，提高开发效率用Virtual DOM减少对DOM的频繁操作提高页面性能——批量操作减少重排（reflows）和重绘(repaints)"><meta name="twitter:image" content="http://www.manfredhu.com/images/react.png"><link rel="alternate" href="/atom.xml" title="ManfredHu胡文峰的个人博客" type="application/atom+xml"><link href="//stackpath.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><link rel="icon" href="/css/images/manfredhu.jpeg"><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css"><link href="//stackpath.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js" async crossorigin="anonymous"></script></head></html><body><div id="container"><div id="wrap"><header><div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation"><div class="navbar-inner"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="brand" style="margin-top:0" href="#" data-toggle="modal" data-target="#myModal"><img width="124px" height="124px" src="/css/images/manfredhu.jpeg"></a><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a class="main-nav-link beautifont" href="/">首页</a></li><li><a class="main-nav-link beautifont" href="/archives">归档</a></li><li><a class="main-nav-link beautifont" href="/categories">分类</a></li><li><a class="main-nav-link beautifont" href="/tags">标签</a></li><li><a class="main-nav-link beautifont" href="/about">关于</a></li><li><div id="search-form-wrap"><form class="search-form"><input type="text" class="ins-search-input search-form-input" placeholder=""> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="请输入关键词..."> <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>!function(n){var t={TRANSLATION:{POSTS:"文章",CATEGORIES:"分类",TAGS:"标签",PAGES:"页面",UNTITLED:"(无标题)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};n.INSIGHT_CONFIG=t}(window),function(n,t){function e(t){return n("<section>").addClass("ins-section").append(n("<header>").addClass("ins-section-header").text(t))}function r(e,r,i,a,s){return n("<div>").addClass("ins-selectable").addClass("ins-search-item").append(n("<header>").append(n("<i>").addClass("fa").addClass("fa-"+e)).append(null!=r&&""!=r?r:t.TRANSLATION.UNTITLED).append(i?n("<span>").addClass("ins-slug").text(i):null)).append(a?n("<p>").addClass("ins-search-preview").text(a):null).attr("data-url",s)}function i(n,i){var a,s;if(0===i.length)return null;switch(a=t.TRANSLATION[n],n){case"POSTS":case"PAGES":s=i.map(function(n){return r("file",n.title,null,n.text.slice(0,150),t.ROOT_URL+n.path)});break;case"CATEGORIES":case"TAGS":s=i.map(function(t){return r("CATEGORIES"===n?"folder":"tag",t.name,t.slug,null,t.permalink)});break;default:return null}return e(a).append(s)}function a(n,t){var e={},r=n.pages.concat(n.posts);r.forEach(function(n){n[t]&&n[t].forEach(function(n){e[n.name]=n})});var i=[];for(var t in e)i.push(e[t]);return i}function s(n){return n.split(" ").filter(function(n){return!!n}).map(function(n){return n.toUpperCase()})}function o(n,t,e){var r=s(n),i=r.filter(function(n){var r=e.filter(function(e){return t.hasOwnProperty(e)?t[e].toUpperCase().indexOf(n)>-1?!0:void 0:!1});return r.length>0?!0:!1});return i.length===r.length}function c(n){return{POST:function(t){return o(n,t,["title","text"])},PAGE:function(t){return o(n,t,["title","text"])},CATEGORY:function(t){return o(n,t,["name","slug"])},TAG:function(t){return o(n,t,["name","slug"])}}}function u(n,t,e,r){var i=0;return s(n).forEach(function(n){var a=new RegExp(n,"img");e.forEach(function(n,e){if(t.hasOwnProperty(n)){var s=t[n].match(a);i+=s?s.length*r[e]:0}})}),i}function l(n){return{POST:function(t){return u(n,t,["title","text"],[3,1])},PAGE:function(t){return u(n,t,["title","text"],[3,1])},CATEGORY:function(t){return u(n,t,["name","slug"],[1,1])},TAG:function(t){return u(n,t,["name","slug"],[1,1])}}}function f(n,t){var e=l(t),r=c(t),i=n.posts,s=n.pages,o=a(n,"tags"),u=a(n,"categories");return{posts:i.filter(r.POST).sort(function(n,t){return e.POST(t)-e.POST(n)}).slice(0,5),pages:s.filter(r.PAGE).sort(function(n,t){return e.PAGE(t)-e.PAGE(n)}).slice(0,5),categories:u.filter(r.CATEGORY).sort(function(n,t){return e.CATEGORY(t)-e.CATEGORY(n)}).slice(0,5),tags:o.filter(r.TAG).sort(function(n,t){return e.TAG(t)-e.TAG(n)}).slice(0,5)}}function p(n){O.empty();for(var t in n)O.append(i(t.toUpperCase(),n[t]))}function d(n){if(0!==n.length){var t=v[0].clientHeight,e=n.position().top-v.scrollTop(),r=n[0].clientHeight+n.position().top;r>t+v.scrollTop()&&v.scrollTop(r-v[0].clientHeight),0>e&&v.scrollTop(n.position().top)}}function h(t){var e=n.makeArray(O.find(".ins-selectable")),r=-1;e.forEach(function(t,e){return n(t).hasClass("active")?void(r=e):void 0});var i=(e.length+r+t)%e.length;n(e[r]).removeClass("active"),n(e[i]).addClass("active"),d(n(e[i]))}function T(n){n&&n.length&&(location.href=n.attr("data-url"))}var C=n(".ins-search"),g=C.find(".ins-search-input"),v=C.find(".ins-section-wrapper"),O=C.find(".ins-section-container");C.parent().remove(".ins-search"),n("body").append(C),n.getJSON(t.CONTENT_URL,function(t){"#ins-search"===location.hash.trim()&&C.addClass("show"),g.on("input",function(){var e=n(this).val();p(f(t,e))}),g.trigger("input")}),n(document).on("click focus",".search-form-submit",function(){C.addClass("show"),C.find(".ins-search-input").focus()}).on("click",".ins-search-item",function(){T(n(this))}).on("click",".ins-close",function(){C.removeClass("show")}).on("keydown",function(n){if(C.hasClass("show"))switch(n.keyCode){case 27:C.removeClass("show");break;case 38:h(-1);break;case 40:h(1);break;case 13:T(O.find(".ins-selectable.active").eq(0))}})}(jQuery,window.INSIGHT_CONFIG)</script></div></li></ul></div></div></div></div></header><div id="content" class="outer"><section id="main" style="float:none"><article id="post-23-reactRenderingPrinciple" style="width:100%;float:left" class="article article-type-post" itemscope itemprop="blogPost"><div id="articleInner" class="article-inner"><header class="article-header"><h1 class="thumb" itemprop="name">React + Reflux 渲染性能优化原理</h1></header><div class="article-meta"><a href="/2016/11/08/23-reactRenderingPrinciple/" class="article-date"><time datetime="2016-11-08T15:00:41.000Z" itemprop="datePublished">2016-11-08</time></a> <a class="article-category-link" href="/categories/随笔/">随笔</a></div><div class="article-entry" itemprop="articleBody"><blockquote class="post-source"><p>作者：ManfredHu<br>链接：<a href="http://www.manfredhu.com/2016/11/08/23-reactRenderingPrinciple/index.html" target="_blank" rel="external">http://www.manfredhu.com/2016/11/08/23-reactRenderingPrinciple/index.html</a><br>声明：版权所有，转载请保留本段信息，谢谢大家</p></blockquote><p><img src="/images/react.png" alt="React"></p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React的优点有很多，现在很多应用都接入React这个框架。<br>在我看来，有下列优点：</p><ul><li>Facebook团队研发并维护——有团队维护更新且有质量保证</li><li>在MVVM结构下只起View的作用——简单接入，不需要花费大量人力重构代码</li><li>组件化形式构建Web应用——复用性强，提高开发效率</li><li>用Virtual DOM减少对DOM的频繁操作提高页面性能——批量操作减少重排（reflows）和重绘(repaints)次数——性能对比旧的方式有提高</li></ul><h2 id="React对重排和重绘的提高"><a href="#React对重排和重绘的提高" class="headerlink" title="React对重排和重绘的提高"></a>React对重排和重绘的提高</h2><p>雅虎性能优化比较重要的点，老司机自行忽略。<br>如下图，HTML被浏览器解析为DOM树，CSS代码加载进来解析为样式结构体，两者关联组成渲染树，之后浏览器把渲染树绘制出来就是我们看到的网页了。这里如果我们对DOM树或者样式结构体做一些操作，如删除某个节点，样式改为隐藏（display:none）等等，会触发重排进而导致重绘。<br><img src="http://www.manfredhu.com/images/github/repaintAndReflow.JPG" alt="重排与重绘"></p><h3 id="触发重排的条件"><a href="#触发重排的条件" class="headerlink" title="触发重排的条件"></a>触发重排的条件</h3><ul><li>DOM元素的数量属性变化</li><li>DOM树的结构变化——节点的增减、移动</li><li>某些布局属性的读取和设置触发重排——offsetTop/offsetWidth/scrollTop等等<br>导致子级、后续兄弟元素、父节点因重新计算布局而重排</li></ul><h3 id="触发重绘的条件"><a href="#触发重绘的条件" class="headerlink" title="触发重绘的条件"></a>触发重绘的条件</h3><ul><li>简单样式属性的变化——颜色、背景色等</li><li>重排导致的重绘</li></ul><p>而React维护了一个Virtual DOM将短时间的操作合并起来一起同步到DOM，所以这也是它对整个前端领域提出的最重要的改变。</p><h2 id="为什么引入Reflux？"><a href="#为什么引入Reflux？" class="headerlink" title="为什么引入Reflux？"></a>为什么引入Reflux？</h2><p>上面说了React在MVVM结构下只起View的作用，那么除了View，MVVM下还有Model，ViewModel。<br>而纯粹的View，会让整个逻辑耦合在一层下，数据也需要层层传递，不方便控制和复用。<br><img src="http://www.manfredhu.com/images/github/componentProblem.JPG" alt="组件化遇到的问题"></p><p>故业内也有一堆的分层框架——如最早的flux，现在部门在用的Reflux，以及Redux。<br>对比Redux，Reflux更容易理解和上手——这也是现状，学习成本越低，接入现有业务就越容易。</p><h2 id="Reflux"><a href="#Reflux" class="headerlink" title="Reflux"></a>Reflux</h2><p>reflux的架构非常简单，就是三部分</p><ol><li>Action 理解为一个命令或者动作，通过它来向组件发出”指令”</li><li>Store 为ViewModel部分，组件的一些状态属性会存储在这里</li><li>View Component 为组件模板<br><img src="http://www.manfredhu.com/images/github/reflux.JPG" alt="reflux的架构"></li></ol><p>所以Reflux只是让我们，更好的去操作组件，通过一个Action命令，叫组件去干嘛，组件自己通过写好的代码，对命令做出反应(变化为不同的state状态)。</p><h2 id="React-Reflux起到的作用"><a href="#React-Reflux起到的作用" class="headerlink" title="React+Reflux起到的作用"></a>React+Reflux起到的作用</h2><p><strong>现在你已经有了两个小工具了，写一个组件，通过Action调用组件就可以了。</strong><br>写到这里，你应该能体会到，所有的引入就是为了让代码写起来更有效率，更易用，复用性更强。</p><h2 id="Pure-Component"><a href="#Pure-Component" class="headerlink" title="Pure Component"></a>Pure Component</h2><p>纯净的组件：在给定相同props和state的情况下会渲染出同样结果<br>其优点有这么几点：</p><ol><li>我们写的组件都应该是只依赖props和state的，而不应该依赖其他全局变量或参数</li><li>纯净的组件方便复用、测试和维护</li></ol><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>React组件有两部分</p><p>第一部分是初始化的生命周期:</p><ul><li>getDefaultProps</li><li>geInitialState</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ul><p>第二部分是被action触发，需要更新：</p><ul><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>conponentDidUpdate</li></ul><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p><strong>shouldComponentUpdate</strong>这个方法可以说是一个预留的插入接口。<br>在上面更新的时候，第一步就是调用的这个方法判断组件是否该被重新渲染。</p><p>shouldComponentUpdate是在React组件更新的生命周期中，用于判断组件是否需要重新渲染的一个接口，它有两个返回值：</p><ul><li>返回true，则进入React的Virtual DOM比较过程</li><li>返回false，则跳过Virtual DOM比较与渲染等过程</li></ul><p><img src="http://www.manfredhu.com/images/github/SCUAndvDOMEqual.JPG" alt="shouldComponentUpdate和Virtual DOM Equal compare"></p><p>如上图，这是一棵React Virtual DOM的树。</p><ul><li>C1在<code>ShouldComponentUpdate</code>返回了true，即默认值，代表需要更新，进入<code>Virtual DOM Diff</code>过程，返回false，不相同，需要更新</li><li>C2在<code>ShouldComponentUpdate</code>返回了false,不再更新，C4,C5因为被父节点在<code>ShouldComponentUpdate</code>中返回了false，所以不再更新</li><li>C3在<code>ShouldComponentUpdate</code>返回了true进入<code>Virtual DOM Diff</code>过程，比对结果为false，新旧不一样，需要更新</li><li>轮到C6,<code>ShouldComponentUpdate</code>返回了true，进入<code>Virtual DOM Diff</code>的过程，返回了false，即新旧两个节点不相同，所以这个节点需要更新</li><li>C7在<code>ShouldComponentUpdate</code>返回了false，即不需要更新，节点不变</li><li>C8在<code>ShouldComponentUpdate</code>返回了true,进入<code>Virtual DOM Diff</code>比对过程，结果为true，新旧相等，不更新</li></ul><p>大概就是这么一个过程，在这里，Diff算法其实还是比较复杂的，比较好的做法是我们来写入ShouldComponentUpdate来自己控制组件的更新，而不是依赖React帮我们做比较。</p><h2 id="进入正文"><a href="#进入正文" class="headerlink" title="进入正文"></a>进入正文</h2><p>前面讲了那么多，相信懂React的都懂了，就不再详细讲了，Diff算法有兴趣的可以自己去翻源码，网上也有一堆模拟实现的例子。</p><p>接下来介绍一个探索reflux&amp;react渲染优化的例子。<br>这里试图，模拟一个比较现实的例子，抛开很多业务代码，让问题变得直接。</p><p>首先例子有三个组件，两个按钮，5个数字，还有一个重复打印文本的大组件。</p><ul><li>1basicDemo 是没有优化的例子，每50ms会发出action更改store数据触发渲染</li><li>2perfDemo 使用addons插件Perf分析页面性能的例子</li><li>3pureRenderMixinDemo 使用addons插件pureRenderMixin优化页面性能的例子</li><li>4updateDemo 使用了addons插件update优化页面性能的例子</li><li>5immutableDemo 使用了<code>Immutable.js</code>优化页面性能的例子</li></ul><p><a href="https://github.com/ManfredHu/reflux-demo" rel="external nofollow noopener noreferrer" target="_blank">源码传送门</a></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>gulpfile.js为gulp构建代码，会将<code>tpl.js</code>的JSX代码翻译为js代码，需要的可以自己修改，每次转化模板需要<code>gulp</code>运行一下</li><li>modulejs模块加载器和myView单页SPA框架为腾讯通讯与彩票业务部前端团队这边的基本框架，具体的请戳<a href="https://github.com/TC-FE" rel="external nofollow noopener noreferrer" target="_blank">这里</a>查看</li><li>需要关注的文件<ul><li>index.html 页面入口，规定了执行的模块</li><li>app.js 应用程序入口</li><li>todoAction.js (reflux架构下，demo的action)</li><li>todoStore.js (reflux架构下，demo的store)</li><li>tpl.js 组件的jsx文件</li></ul></li></ul><h2 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h2><ol><li><code>cd ./xxx/</code>(这里的xxx为上面对应的 ……./4updateDemo/ 目录)</li><li><code>http-server -p 8888</code>端口可以自定义，http-server模块已在<code>node_module</code>目录下，担心版本依赖问题，已上传<code>node_module</code>目录，直接打开就可以了</li><li>打开浏览器便可浏览，详情请看控制台</li></ol><h2 id="basicDemo"><a href="#basicDemo" class="headerlink" title="basicDemo"></a>basicDemo</h2><p>1basicDemo目录是一个最原始的目录，这里你可以看到我们哪里出现了问题。</p><p><code>cd ./example</code> 打开这个没优化过的例子的目录<br><code>http-server -p xxxx</code> 这里端口随意，不冲突就好<br>浏览器访问并打开控制台，会看到<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 tpl.js:32 createNum组件被更新了</span><br><span class="line">  tpl.js:10 TextComponent被更新了</span><br><span class="line">2 tpl.js:57 createBtn组件被更新了</span><br></pre></td></tr></table></figure><p></p><p>初始化createNum组件被渲染了5次，因为有5个，createBtn组件被渲染了两次，因为有点击开始和点击结束两个按钮。通过不同的传参而改变形态。</p><p>点击开始会触发<code>action</code>，让store的数据每次+1，点击结束会清除定时器</p><p>点击开始可以看到<strong>控制台的数据每次都会刷新整个界面的所有组件，特别是有一个大组件<code>TextComponent</code></strong>，是重复5000次文本的，每次重新渲染就有很多的损耗。这就是我们要优化的地方——减少某些<strong>关键部分</strong>的重新渲染的次数，减少无用对比的消耗</p><p>这里你可以打开Chrome控制台的Timeline来看一下，点击开始，打开Timeline面板，每1S左右会有一个脚本执行的高峰期。</p><p>我们知道特别是在移动端，CPU和内存的资源显得尤为稀缺（大概只能占用正常CPU和内存的10%，微信手Q等可能会因为友商系统对应用程序的优先级设计使这个限制略有提高——我说的就是小米哈哈哈），所以这样说来，性能这一块在移动手机web显得非常非常重要。</p><p><img src="http://www.manfredhu.com/images/github/1basicDemo.png" alt="50ms渲染一次，重复渲染200次的截图"></p><h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><p>Perl是react-addons带来的性能分析工具，这里的perfDemo是结合Chrome插件的例子。<br>要向全局暴露一个<code>window.Perl</code>变量，然后就可以愉快的配合Chrome插件使用了</p><ul><li>React-addons插件版本的<a href="https://facebook.github.io/react/docs/perf.html" rel="external nofollow noopener noreferrer" target="_blank">Perf插件</a>提供原生的API——用在首次渲染部分</li><li><a href="https://github.com/crysislinux/chrome-react-perf" rel="external nofollow noopener noreferrer" target="_blank">Chrome插件</a>——用在有交互的部分</li><li><a href="https://github.com/garbles/why-did-you-update" rel="external nofollow noopener noreferrer" target="_blank">console tool</a>——需要查看对比新旧值的情况下</li></ul><p>这里的wasted time就是在做属性没变化的重复渲染的过程，可以优化。<br><strong>用法与Chrome开发工具的TimeLine用法类似，点击start开始记录，后点击stop结束</strong></p><p><img src="http://www.manfredhu.com/images/github/2perfDemo.png" alt="50ms渲染一次，重复渲染200次的截图"></p><h2 id="PureRenderMixin"><a href="#PureRenderMixin" class="headerlink" title="PureRenderMixin"></a>PureRenderMixin</h2><p>一个简单的通用优化工具，通过<strong>浅对比(shallowCompare)</strong>方法对比新旧两个组件的状态，达到减少重复渲染的目的。</p><p><strong>注意这里组件的store必须无关联，原因是shallowCompare的时候，比较的是组件关联的store的数据，而例子里面store是一个，其他组件num的变化也会引起这里TextComponent组件的更新</strong></p><p><strong>这里将store与顶级组件APP关联起来，然后在子孙组件下自定采用props传递的方式处理(传递基本类型的数据)，这样就可以让pureRenderMixin的通用化了，唯一的缺点是，传递props要控制，只把组件需要的属性传递下去，这里会比较麻烦，但是这样又是性能较高又比较好理解的处理方式(相对其他要拷贝属性的方式)</strong></p><p>*<em>store下，option里面的对象，受pureRenderMixin的限制，不可以出现引用类型</em></p><blockquote><p><strong>PureRenderMixin其实是封装了更底层的shallowCompare接口的</strong></p></blockquote><p>简单用法如下:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react'</span>).addons.PureRenderMixin;</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>就加了一个mixins，看起来简单优雅有木有。可以在众多组件里面copy通用啊有木有<br>那这里干了什么？<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.addons = &#123;</span><br><span class="line">  CSSTransitionGroup: ReactCSSTransitionGroup,</span><br><span class="line">  LinkedStateMixin: LinkedStateMixin,</span><br><span class="line">  PureRenderMixin: ReactComponentWithPureRenderMixin, <span class="comment">//看这里</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactComponentWithPureRenderMixin = &#123;</span><br><span class="line">  <span class="comment">//帮你写了一个shouldComponentUpdate方法</span></span><br><span class="line">  shouldComponentUpdate: <span class="function"><span class="keyword">function</span> (<span class="params">nextProps, nextState</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCompare</span>(<span class="params">instance, nextProps, nextState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//分别比较props和state属性是否相等</span></span><br><span class="line">  <span class="keyword">return</span> !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA, objB</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (objA === objB) &#123; <span class="comment">//store嵌套层级太深这里就会返回true，引用类型内存指向同一空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">'object'</span> || objA === <span class="literal">null</span> || <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> || objB === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> keysA = <span class="built_in">Object</span>.keys(objA);</span><br><span class="line">  <span class="keyword">var</span> keysB = <span class="built_in">Object</span>.keys(objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for A's keys different from B.</span></span><br><span class="line">  <span class="keyword">var</span> bHasOwnProperty = hasOwnProperty.bind(objB);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以PureRenderMixin这个插件，只能比较state和props为基本类型的部分。<br>如果有更加深层次的store数据嵌套，就要借助于update插件或者Immutablejs来深拷贝store的数据另存一份了。</p><p><img src="http://www.manfredhu.com/images/github/3pureRenderMixinDemo.png" alt="50ms渲染一次，重复渲染200次的截图，引入pureRenderMixin"></p><h2 id="用update优化（也称Immutable-Helper）"><a href="#用update优化（也称Immutable-Helper）" class="headerlink" title="用update优化（也称Immutable Helper）"></a>用update优化（也称Immutable Helper）</h2><p>update是addons里面的一个方法，旨在对拷贝对象复杂的过程来做一些语法上的优化，具体可以看<a href="https://facebook.github.io/react/docs/update.html" rel="external nofollow noopener noreferrer" target="_blank">react官方文档</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extend复制对象属性的时候</span></span><br><span class="line"><span class="keyword">var</span> newData = extend(myData, &#123;</span><br><span class="line">  x: extend(myData.x, &#123;</span><br><span class="line">    y: extend(myData.x.y, &#123;<span class="attr">z</span>: <span class="number">7</span>&#125;),</span><br><span class="line">  &#125;),</span><br><span class="line">  a: extend(myData.a, &#123;<span class="attr">b</span>: myData.a.b.concat(<span class="number">9</span>)&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用update的时候，提供了一些语法糖让你不用写那么多</span></span><br><span class="line"><span class="keyword">var</span> update = <span class="built_in">require</span>(<span class="string">'react-addons-update'</span>);</span><br><span class="line"><span class="keyword">var</span> newData = update(myData, &#123;</span><br><span class="line">  x: &#123;<span class="attr">y</span>: &#123;<span class="attr">z</span>: &#123;<span class="attr">$set</span>: <span class="number">7</span>&#125;&#125;&#125;,</span><br><span class="line">  a: &#123;<span class="attr">b</span>: &#123;<span class="attr">$push</span>: [<span class="number">9</span>]&#125;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>cd ./updateDemo</code> 打开这个用addons.update优化过的例子的目录<br><code>http-server -p xxxx</code> 这里端口随意，不冲突就好</p><p>这个例子与上面一个例子唯一的不同是这里用了<strong>addons.update来进行store数据的复制</strong>，具体的可以看todoStore和tpl这两个模块的代码，其他基本无修改</p><p>这里update是参考了MongoDB’s query的部分语法，具体的可以看<a href="http://docs.mongodb.org/manual/core/crud-introduction/#query" rel="external nofollow noopener noreferrer" target="_blank">这里</a>,类比数组方法，返回一个新的实例。</p><ul><li>{$push: array} 类似数组的push方法</li><li>{$unshift: array} 类似数组的unshift方法</li><li>{$splice: array of arrays} 类似数组的splice方法</li><li>{$set: any} 整个替换目标</li><li>{$merge: object} 合并目标和object的 keys.</li><li>{$apply: function} 传递当前的值给 function 并用返回值更新它</li></ul><p>但是由Timeline的观察来看，复制对象属性的性能远比刷新一个大组件的性能高。</p><p><img src="http://www.manfredhu.com/images/github/4updateDemo.png" alt="50ms渲染一次，重复渲染200次的截图，引入了update模块"></p><h2 id="Immutablejs"><a href="#Immutablejs" class="headerlink" title="Immutablejs"></a>Immutablejs</h2><p>Immutable.js是Facebook为解决数据持久化而独立出来的一个库，传统的，比如我们有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">test(a); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>函数对对象的操作，你不会知道这个函数对对象进行了什么操作。也就是说是封闭的。<br>而Immutable每次对对象的操作都会返回一个新对象</p><p>Immutable.js提供了7种不可变的数据类型:<code>List Map Stack OrderedMap Set OrderedSet Record</code>,对Immutable对象的操作均会返回新的对象，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> map = Immutable.fromJS(obj);</span><br><span class="line"><span class="keyword">var</span> map2 = map.set(<span class="string">'count'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'count'</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(map2.get(<span class="string">'count'</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>引入Immutable.js，需要对现有的业务代码进行改动，通常是对tpl和store两部分进行操作，初始化数据的时候生成一个Immutable的数据类型，之后每次get,set操作都会返回一个共享的新的对象。</p><p>50ms渲染一次，重复渲染200次的截图，引入了immutable用了其set方法：<br><img src="http://www.manfredhu.com/images/github/5immutable_set.png" alt="50ms渲染一次，重复渲染200次的截图，引入了immutable用了其set方法"></p><p>50ms渲染一次，重复渲染200次的截图，引入了immutable用了其update方法：<br><img src="http://www.manfredhu.com/images/github/5immutableDemo_update.png" alt="50ms渲染一次，重复渲染200次的截图，引入了immutable用了其update方法"></p><h2 id="seamless-immutable-amp-amp-Observejs"><a href="#seamless-immutable-amp-amp-Observejs" class="headerlink" title="seamless-immutable &amp;&amp; Observejs"></a>seamless-immutable &amp;&amp; Observejs</h2><p>一个是immutable的阉割版，一个是AlloyTeam推的。<br>两者都是通过Object.defineProperty(IE9+)对set和get操作进行处理，优点是文件比较小。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>自己设想，组件化运用到极致，应该是像<a href="http://weui.github.io/weui/#/" rel="external nofollow noopener noreferrer" target="_blank">微信weui</a>那样</p><ul><li>有一套非常适合接入，复用性非常强的组件库。拿来就用，不需要再次开发</li><li>应该兼顾起上面说的减少重复渲染的部分</li><li>开发友好</li></ul><p>这里也思考一些可能做到的变化：</p><ul><li>将一个组件的action/store/JSX/样式代码Style 写在<strong>一个文件</strong>里，这样方便修改和调用，封闭组件内部实现细节，对外只暴露action操作和store的一些get方法，这样可以修改或者是获取到组件的某些现在时刻的属性（也有同学是直接封装为一个对象，通过对象暴露其store,action）</li><li>组件共享或依赖的数据，应在公共父级的store或独立成一个单独的部分，然后采用props传递的形式或从独立的store里面取数据</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="https://github.com/ManfredHu/reflux-demo" rel="external nofollow noopener noreferrer" target="_blank">源码传送门</a><br><a href="LICENSE">MIT</a>. Copyright (c) 2016 ManfredHu.</p></div><footer class="article-footer"><div id="baidu-share" class="bdsharebuttonbox" data-tag="share_1" style="margin-bottom:15px"><a class="bds_more" data-cmd="more">更多</a> <a class="bds_weixin" data-cmd="weixin"></a> <a class="bds_sqq" data-cmd="sqq"></a> <a class="bds_tsina" data-cmd="tsina"></a> <a class="bds_qzone" data-cmd="qzone"></a> <a class="bds_evernotecn" data-cmd="evernotecn"></a> <a class="bds_youdao" data-cmd="youdao"></a> <a class="bds_copy" data-cmd="copy"></a></div><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分享/">分享</a></li></ul></footer></div><nav id="article-nav"><div class="article-nav-left"><a href="/2017/02/26/24-how-to-use-mysql-on-mac/" class="thumbnail"><span style="background-image:url(/images/mysql.jpg)" alt="MySQL使用及在Mac上的区别" class="thumbnail-image"></span></a> <a href="/2017/02/26/24-how-to-use-mysql-on-mac/" class="hover-color"><div class="dark-dialog"></div><strong class="article-nav-caption">上一篇</strong><div class="article-nav-title">MySQL使用及在Mac上的区别</div></a></div><div class="article-nav-rigth"><a href="/2016/07/12/21-classNames/" class="thumbnail"><span style="background-image:url(/images/classNames.png)" alt="classNames模块" class="thumbnail-image"></span></a> <a href="/2016/07/12/21-classNames/" class="hover-color"><div class="dark-dialog"></div><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">classNames模块</div></a></div></nav></article><div class="big-sidebar"><div class="fix-sidebar"><div class="fix-sidebar-nav"><span>展开目录</span></div><div class="fix-sidebar-comment"><span>评论</span></div><div class="fix-sidebar-share"><span>分享</span></div><div class="fix-sidebar-music"><span>音乐</span></div><a class="fix-sidebar-github" href="https://github.com/manfredHu" target="_blank" alt="Fork me on GitHub" rel="external nofollow noopener noreferrer">Github</a> <a class="fix-sidebar-totop" href="#top" alt="返回顶部">TOP</a></div><aside id="markdown-sidebar"><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#React"><span class="toc-number">1.</span> <span class="toc-text">React</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React对重排和重绘的提高"><span class="toc-number">2.</span> <span class="toc-text">React对重排和重绘的提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#触发重排的条件"><span class="toc-number">2.1.</span> <span class="toc-text">触发重排的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发重绘的条件"><span class="toc-number">2.2.</span> <span class="toc-text">触发重绘的条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么引入Reflux？"><span class="toc-number">3.</span> <span class="toc-text">为什么引入Reflux？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflux"><span class="toc-number">4.</span> <span class="toc-text">Reflux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Reflux起到的作用"><span class="toc-number">5.</span> <span class="toc-text">React+Reflux起到的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pure-Component"><span class="toc-number">6.</span> <span class="toc-text">Pure Component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件生命周期"><span class="toc-number">7.</span> <span class="toc-text">组件生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shouldComponentUpdate"><span class="toc-number">8.</span> <span class="toc-text">shouldComponentUpdate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进入正文"><span class="toc-number">9.</span> <span class="toc-text">进入正文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">10.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简单用法"><span class="toc-number">11.</span> <span class="toc-text">简单用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#basicDemo"><span class="toc-number">12.</span> <span class="toc-text">basicDemo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Perl"><span class="toc-number">13.</span> <span class="toc-text">Perl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PureRenderMixin"><span class="toc-number">14.</span> <span class="toc-text">PureRenderMixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用update优化（也称Immutable-Helper）"><span class="toc-number">15.</span> <span class="toc-text">用update优化（也称Immutable Helper）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Immutablejs"><span class="toc-number">16.</span> <span class="toc-text">Immutablejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seamless-immutable-amp-amp-Observejs"><span class="toc-number">17.</span> <span class="toc-text">seamless-immutable &amp;&amp; Observejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在最后"><span class="toc-number">18.</span> <span class="toc-text">写在最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#License"><span class="toc-number">19.</span> <span class="toc-text">License</span></a></li></ol></div></aside><div id="musicComponent"></div></div></section></div><div align="center" style="margin-top:30px"><hr class="hr" style="margin:0;height:3px"></div><footer id="footer"><div class="container"><div class="row"><p id="copyRightEn">Copyright &copy; 2015 - 2018 ManfredHu胡文峰的个人博客</p><p>All rights reserved. Designed and powered by ManfredHu.</p></div></div></footer><!--[if lt IE 9]>
<p class="chromeframe">您使用的IE浏览器版本过低，为获得更佳浏览体验，<a href="http://windows.microsoft.com/">建议升级您的IE浏览器</a>，或使用<a href="http://www.google.com/chromeframe/?redirect=true">Google Chrome</a>、<a href="http://www.firefox.com.cn/">Firefox</a>等高级浏览器，将会得到更好的体验！</p>
<![endif]--><script>var wrapdiv=document.getElementById("wrap"),contentdiv=document.getElementById("content"),allheaderHeight=document.getElementById("allheader")?document.getElementById("allheader").offsetHeight:0,footerHeight=document.getElementById("footer")?document.getElementById("footer").offsetHeight:0;wrapdiv.style.minHeight=document.body.offsetHeight+"px",contentdiv.style.minHeight=document.body.offsetHeight-allheaderHeight-footerHeight+"px"</script></div><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script><script>with(window._bd_share_config={common:{bdText:"",bdDesc:"",bdUrl:"",bdPic:"",bdMini:2},share:[{tag:"share_1",bdSize:32}]},document)0[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="https://bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)]</script><script>var _mtac={};!function(){var t=document.createElement("script");t.src="https://pingjs.qq.com/h5/stats.js?v2.0.2",t.setAttribute("name","MTAH5"),t.setAttribute("sid","500652330");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></div><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display:none"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><h2 class="modal-title" id="myModalLabel">设置</h2></div><hr style="margin-top:0;margin-bottom:0;width:80%;border-top:3px solid #000"><hr style="margin-top:2px;margin-bottom:0;width:80%;border-top:1px solid #000"><div class="modal-body"><div style="margin:6px"><a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="setFontSize()" aria-expanded="true" aria-controls="collapseOne">正文字号大小</a></div><div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne"><div class="panel-body">您已调整页面字体大小</div></div><div style="margin:6px"><a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="setBackground()" aria-expanded="true" aria-controls="collapseTwo">夜间护眼模式</a></div><div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo"><div class="panel-body">夜间模式已经开启，再次单击按钮即可关闭</div></div><div><a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a></div><div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree"><div class="panel-body">ManfredHu胡文峰的个人博客</div><div class="panel-body">Copyright © 2018 ManfredHu All Rights Reserved.</div></div></div><hr style="margin-top:0;margin-bottom:0;width:80%;border-top:1px solid #000"><hr style="margin-top:2px;margin-bottom:0;width:80%;border-top:3px solid #000"><div class="modal-footer"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div></div></div></div></body><!-- rebuild by neat -->