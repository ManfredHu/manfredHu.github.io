<!-- build time:Sat Mar 30 2019 21:31:22 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="true"><meta name="MobileOptimized" content="320"><meta name="msapplication-tap-highlight" content="no"><title>跨域终结篇 | ManfredHu胡文峰的个人博客</title><meta name="keywords" content="ManfredHu, pphu, 胡文峰, Tencent, Front-end development engineer, Reactjs, Reflux, Nodejs"><meta name="google-site-verification" content="cEEBkaUfHCAQdUy-oVbzMfS_w79I1nCPeOQmgJDgZSY"><meta name="baidu-site-verification" content="KNYdPFyuaj"><meta name="description" content="前言github代码地址：https://github.com/ManfredHu/cross-origin原来的浏览器是裸奔的，会给人看光光。就算你加密了，还是有办法看到，所以各大浏览器裸奔厂商商量好了规范，就是禁止源origin访问其他源下的资源。同源要求：同协议(http/https属于不同的协议),同域名IP，同端口。判断是否跨域看下图：CORS请求头带orgin到服务器，然后服务器返回A"><meta name="keywords" content="jsonp,CORS,postMessage"><meta property="og:type" content="article"><meta property="og:title" content="跨域终结篇"><meta property="og:url" content="http://www.manfredhu.com/2019/01/15/42-cross-origin/index.html"><meta property="og:site_name" content="ManfredHu胡文峰的个人博客"><meta property="og:description" content="前言github代码地址：https://github.com/ManfredHu/cross-origin原来的浏览器是裸奔的，会给人看光光。就算你加密了，还是有办法看到，所以各大浏览器裸奔厂商商量好了规范，就是禁止源origin访问其他源下的资源。同源要求：同协议(http/https属于不同的协议),同域名IP，同端口。判断是否跨域看下图：CORS请求头带orgin到服务器，然后服务器返回A"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.manfredhu.com/images/crossOrigin.png"><meta property="og:image" content="http://www.manfredhu.com/images/checkCrossOrigin.png"><meta property="og:updated_time" content="2019-01-15T02:07:26.669Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="跨域终结篇"><meta name="twitter:description" content="前言github代码地址：https://github.com/ManfredHu/cross-origin原来的浏览器是裸奔的，会给人看光光。就算你加密了，还是有办法看到，所以各大浏览器裸奔厂商商量好了规范，就是禁止源origin访问其他源下的资源。同源要求：同协议(http/https属于不同的协议),同域名IP，同端口。判断是否跨域看下图：CORS请求头带orgin到服务器，然后服务器返回A"><meta name="twitter:image" content="http://www.manfredhu.com/images/crossOrigin.png"><link rel="alternate" href="/atom.xml" title="ManfredHu胡文峰的个人博客" type="application/atom+xml"><link href="//stackpath.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><link rel="icon" href="/css/images/manfredhu.jpeg"><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css"><link href="//stackpath.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js" async crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script></head></html><body><div id="container"><div id="wrap"><header><div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation"><div class="navbar-inner"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="brand" style="margin-top:0" href="#" data-toggle="modal" data-target="#myModal"><img width="124px" height="124px" src="/css/images/manfredhu.jpeg"></a><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a class="main-nav-link beautifont" href="/">首页</a></li><li><a class="main-nav-link beautifont" href="/archives">归档</a></li><li><a class="main-nav-link beautifont" href="/categories">分类</a></li><li><a class="main-nav-link beautifont" href="/tags">标签</a></li><li><a class="main-nav-link beautifont" href="/about">关于</a></li><li><div id="search-form-wrap"><form class="search-form"><input type="text" class="ins-search-input search-form-input" placeholder=""> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="请输入关键词..."> <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>!function(n){var t={TRANSLATION:{POSTS:"文章",CATEGORIES:"分类",TAGS:"标签",PAGES:"页面",UNTITLED:"(无标题)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};n.INSIGHT_CONFIG=t}(window),function(n,t){function e(t){return n("<section>").addClass("ins-section").append(n("<header>").addClass("ins-section-header").text(t))}function r(e,r,i,a,s){return n("<div>").addClass("ins-selectable").addClass("ins-search-item").append(n("<header>").append(n("<i>").addClass("fa").addClass("fa-"+e)).append(null!=r&&""!=r?r:t.TRANSLATION.UNTITLED).append(i?n("<span>").addClass("ins-slug").text(i):null)).append(a?n("<p>").addClass("ins-search-preview").text(a):null).attr("data-url",s)}function i(n,i){var a,s;if(0===i.length)return null;switch(a=t.TRANSLATION[n],n){case"POSTS":case"PAGES":s=i.map(function(n){return r("file",n.title,null,n.text.slice(0,150),t.ROOT_URL+n.path)});break;case"CATEGORIES":case"TAGS":s=i.map(function(t){return r("CATEGORIES"===n?"folder":"tag",t.name,t.slug,null,t.permalink)});break;default:return null}return e(a).append(s)}function a(n,t){var e={},r=n.pages.concat(n.posts);r.forEach(function(n){n[t]&&n[t].forEach(function(n){e[n.name]=n})});var i=[];for(var t in e)i.push(e[t]);return i}function s(n){return n.split(" ").filter(function(n){return!!n}).map(function(n){return n.toUpperCase()})}function o(n,t,e){var r=s(n),i=r.filter(function(n){var r=e.filter(function(e){return t.hasOwnProperty(e)?t[e].toUpperCase().indexOf(n)>-1?!0:void 0:!1});return r.length>0?!0:!1});return i.length===r.length}function c(n){return{POST:function(t){return o(n,t,["title","text"])},PAGE:function(t){return o(n,t,["title","text"])},CATEGORY:function(t){return o(n,t,["name","slug"])},TAG:function(t){return o(n,t,["name","slug"])}}}function u(n,t,e,r){var i=0;return s(n).forEach(function(n){var a=new RegExp(n,"img");e.forEach(function(n,e){if(t.hasOwnProperty(n)){var s=t[n].match(a);i+=s?s.length*r[e]:0}})}),i}function l(n){return{POST:function(t){return u(n,t,["title","text"],[3,1])},PAGE:function(t){return u(n,t,["title","text"],[3,1])},CATEGORY:function(t){return u(n,t,["name","slug"],[1,1])},TAG:function(t){return u(n,t,["name","slug"],[1,1])}}}function f(n,t){var e=l(t),r=c(t),i=n.posts,s=n.pages,o=a(n,"tags"),u=a(n,"categories");return{posts:i.filter(r.POST).sort(function(n,t){return e.POST(t)-e.POST(n)}).slice(0,5),pages:s.filter(r.PAGE).sort(function(n,t){return e.PAGE(t)-e.PAGE(n)}).slice(0,5),categories:u.filter(r.CATEGORY).sort(function(n,t){return e.CATEGORY(t)-e.CATEGORY(n)}).slice(0,5),tags:o.filter(r.TAG).sort(function(n,t){return e.TAG(t)-e.TAG(n)}).slice(0,5)}}function p(n){O.empty();for(var t in n)O.append(i(t.toUpperCase(),n[t]))}function d(n){if(0!==n.length){var t=v[0].clientHeight,e=n.position().top-v.scrollTop(),r=n[0].clientHeight+n.position().top;r>t+v.scrollTop()&&v.scrollTop(r-v[0].clientHeight),0>e&&v.scrollTop(n.position().top)}}function h(t){var e=n.makeArray(O.find(".ins-selectable")),r=-1;e.forEach(function(t,e){return n(t).hasClass("active")?void(r=e):void 0});var i=(e.length+r+t)%e.length;n(e[r]).removeClass("active"),n(e[i]).addClass("active"),d(n(e[i]))}function T(n){n&&n.length&&(location.href=n.attr("data-url"))}var C=n(".ins-search"),g=C.find(".ins-search-input"),v=C.find(".ins-section-wrapper"),O=C.find(".ins-section-container");C.parent().remove(".ins-search"),n("body").append(C),n.getJSON(t.CONTENT_URL,function(t){"#ins-search"===location.hash.trim()&&C.addClass("show"),g.on("input",function(){var e=n(this).val();p(f(t,e))}),g.trigger("input")}),n(document).on("click focus",".search-form-submit",function(){C.addClass("show"),C.find(".ins-search-input").focus()}).on("click",".ins-search-item",function(){T(n(this))}).on("click",".ins-close",function(){C.removeClass("show")}).on("keydown",function(n){if(C.hasClass("show"))switch(n.keyCode){case 27:C.removeClass("show");break;case 38:h(-1);break;case 40:h(1);break;case 13:T(O.find(".ins-selectable.active").eq(0))}})}(jQuery,window.INSIGHT_CONFIG)</script></div></li></ul></div></div></div></div></header><div id="content" class="outer"><section id="main" style="float:none"><article id="post-42-cross-origin" style="width:100%;float:left" class="article article-type-post" itemscope itemprop="blogPost"><div id="articleInner" class="article-inner"><header class="article-header"><h1 class="thumb" itemprop="name">跨域终结篇</h1></header><div class="article-meta"><a href="/2019/01/15/42-cross-origin/" class="article-date"><time datetime="2019-01-15T02:02:43.000Z" itemprop="datePublished">2019-01-15</time></a> <a class="article-category-link" href="/categories/跨域/">跨域</a></div><div class="article-entry" itemprop="articleBody"><blockquote class="post-source"><p>作者：ManfredHu<br>链接：<a href="http://www.manfredhu.com/2019/01/15/42-cross-origin/index.html" target="_blank" rel="external">http://www.manfredhu.com/2019/01/15/42-cross-origin/index.html</a><br>声明：版权所有，转载请保留本段信息，谢谢大家</p></blockquote><p><img src="/images/crossOrigin.png" alt="crossOrigin"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>github代码地址：<a href="https://github.com/ManfredHu/cross-origin" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ManfredHu/cross-origin</a></p><p>原来的浏览器是裸奔的，会给人看光光。就算你加密了，还是有办法看到，所以各大浏览器裸奔厂商商量好了规范，就是禁止源origin访问其他源下的资源。</p><blockquote><p>同源要求：同协议(http/https属于不同的协议),同域名IP，同端口。</p></blockquote><p>判断是否跨域看下图：<br><img src="/images/checkCrossOrigin.png" alt="是否同源判断"></p><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>请求头带orgin到服务器，然后服务器返回Access-Control-Allow-origin到客户端，客户端检测返回跟现在的域是否相同，通过协议http,域名，端口判断。</p><h2 id="axios开启cookie传输"><a href="#axios开启cookie传输" class="headerlink" title="axios开启cookie传输"></a>axios开启cookie传输</h2><p>我们知道cookie是会在每一个请求的request header加上的，axios默认是发送请求的时候不会带上cookie的，需要通过设置<code>withCredentials: true</code>来解决。<br>代码如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.get(url, &#123;<span class="string">'withCredentials'</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// handle success</span></span><br><span class="line">        <span class="keyword">if</span>(response.data.retCode === <span class="number">0</span>)&#123;</span><br><span class="line">            log(<span class="string">`收到来自<span class="subst">$&#123;url&#125;</span>的返回数据`</span>)</span><br><span class="line">            log(<span class="built_in">JSON</span>.stringify(response.data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">        log(<span class="string">'请求失败'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p></p><p>项目例子对应启动代码如下。具体的实现可以看代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run cors:node</span><br><span class="line">npm run cors:web</span><br></pre></td></tr></table></figure><p></p><h2 id="express开启cookie传输"><a href="#express开启cookie传输" class="headerlink" title="express开启cookie传输"></a>express开启cookie传输</h2><p>类似的，用到了cors中间件，就会在response header返回加上<code>Access-Control-Allow-Credentials: true</code>的返回头。<br>这个时候就可以传输cookie了。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'cors'</span>)</span><br><span class="line">app.use(cors(&#123;<span class="attr">credentials</span>: <span class="literal">true</span>, <span class="attr">origin</span>: <span class="string">'http://localhost:9000'</span>&#125;))</span><br></pre></td></tr></table></figure><p></p><p>经测试，express开启设置<code>Access-Control-Allow-Origin: *</code>支持跨域传输数据。但是，如果前端axios开启了cookie传输，就是上面的<code>&#39;withCredentials&#39;: true</code>选项，则后端不能开启<code>Access-Control-Allow-Origin: *</code>,否则会报下面的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:3000/cors&apos; from origin &apos;http://localhost:9000&apos; has been blocked by CORS policy: The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br><span class="line"></span><br><span class="line">index.js:19 Error: Network Error</span><br><span class="line">    at createError (createError.js:16)</span><br><span class="line">    at XMLHttpRequest.handleError (xhr.js:87)</span><br></pre></td></tr></table></figure><p>所以如果有开启cookie的需求，则按照上面示例代码设置。</p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>缺点：只支持get，需要服务端支持，需要挂载全局函数(windows)。</p><p>通过<code>script</code>标签可以加载不同源下的文件来实现，因为在网页里，图片,css,js三种文件一般是放在cdn的，可以加快访问速度。<br>那其实网页也是允许图片，css,js之类的文件放在不同源上的，这样也可以加快加载效率。</p><p>所以这种方式跨域本质上是浏览器支持的，只是运用起来需要后端支持。</p><p>前端代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonpScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">jsonpScript.src = <span class="string">'http://localhost:3000/jsonp?callback=jsonpCallback'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(jsonpScript)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.jsonpCallback = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>后端代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.get(item, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> callback = req.query.callback; <span class="comment">//前端需要的回调函数</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        name: <span class="string">'manfredhu'</span>,</span><br><span class="line">        age: <span class="string">'25'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Object</span>.assign(&#123;&#125; ,obj, &#123;<span class="attr">retCode</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"text/javascript"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(callback + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(result) + <span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>这样后端不用开启任何跨域设置，直接返回参数包裹的函数和数据就好了。</p><p>项目例子对应启动代码如下。具体的实现可以看代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run jsonp:node</span><br><span class="line">npm run jsonp:web</span><br></pre></td></tr></table></figure><p></p><h1 id="服务器转发请求跨域"><a href="#服务器转发请求跨域" class="headerlink" title="服务器转发请求跨域"></a>服务器转发请求跨域</h1><p>缺点：需要服务器支持</p><h2 id="nginx-amp-CDN"><a href="#nginx-amp-CDN" class="headerlink" title="nginx &amp; CDN"></a>nginx &amp; CDN</h2><p>nginx和CDN都可以设置响应报头。所以原理上来说都跨域支持跨域，这里不细说，需要的同学自行实现。</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>node做为接入层的话，收到前端的请求，node可以去获取其他域的数据，因为服务器是不受跨域影响的。<br>一般的，有中间件可以用，我用的是<code>http-proxy-middleware</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">"http-proxy-middleware"</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = &#123;</span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">&#125;</span><br><span class="line">app.use(</span><br><span class="line">    <span class="string">"/"</span>,</span><br><span class="line">    proxy(&#123;</span><br><span class="line">        <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">        target: <span class="string">"http://localhost:3001"</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 修改响应头信息，实现跨域并允许带 cookie</span></span><br><span class="line">        onProxyRes: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">            res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://localhost:9000"</span>);</span><br><span class="line">            res.header(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改响应信息中的 cookie 域名</span></span><br><span class="line">        cookieDomainRewrite: <span class="string">"localhost"</span> <span class="comment">// 可以为 false，表示不修改</span></span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>项目例子对应启动代码如下。具体的实现可以看代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run proxy:web</span><br><span class="line">npm run proxy:node1</span><br><span class="line">npm run proxy:node2</span><br></pre></td></tr></table></figure><p></p><h1 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h1><p>通常，相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。</p><h2 id="浏览器接口"><a href="#浏览器接口" class="headerlink" title="浏览器接口"></a>浏览器接口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure><ul><li><strong>otherWindow</strong><br>其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</li><li><strong>message</strong><br>将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</li><li><strong>targetOrigin</strong><br>通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<em>“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是</em>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</li><li><strong>transfer</strong><br>是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>这里有个问题要特别注意下，如下代码广播数据到指定的域时候，有时候会自己也会触发自己监听的<code>window.onmessage</code>。例子端口分别起在9000和9001也会，消息前后顺序不确定。所以如果要确切的收到来自某个跨域消息的话，<code>window.onmessage</code>要做过滤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifr.contentWindow.postMessage(data, <span class="string">'http://localhost:9001'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otherOrigin = <span class="string">'http://localhost:9001'</span></span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">`收到otherPage的postMessage返回的消息`</span>)</span><br><span class="line">    <span class="keyword">if</span>(e.origin === otherOrigin)&#123; <span class="comment">//这里做过滤</span></span><br><span class="line">        log(<span class="built_in">JSON</span>.stringify(e.data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目例子对应启动代码如下。具体的实现可以看代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run postMessage:web1</span><br><span class="line">npm run postMessage:web2</span><br></pre></td></tr></table></figure><p></p><h1 id="修改document-domain来跨子域"><a href="#修改document-domain来跨子域" class="headerlink" title="修改document.domain来跨子域"></a>修改document.domain来跨子域</h1><p>通常我们可以这么干，自己用JS动态添加一个iframe,一般是隐藏不显示，通过设置<code>display:none</code>。<br>然后在iframe里面设置如下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">"localhost"</span> <span class="comment">//这里不用端口只判断是否是子域</span></span><br></pre></td></tr></table></figure><p>然后在我们的页面就可以动态载入一个存在服务器上的静态页面或者动态生成内容的页面。返回给前端，前端设置自己也在这个域内，代码如上，就可以起到跨域通信的目的。</p><p>有一点要特别注意的是，获取iframe的document对象的时候。要通过<code>contentWindow</code>属性，其他属性一概不行或者错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ifr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> ifrDoc = ifr &amp;&amp; ifr.contentWindow &amp;&amp; ifr.contentWindow.document</span><br></pre></td></tr></table></figure><p>项目例子对应启动代码<code>npm run domain</code>。具体的实现可以看代码</p><h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><p>注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。</p><p>其实跟子域的设置方式类似,就是创建一个隐藏的iframe，然后获取到window对象，拿到那个页面挂在window.name的信息。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">"msg"</span>: <span class="string">"这是来自otherPage的数据"</span>, <span class="string">"type"</span>: <span class="string">"window.name"</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ifr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> ifrWin = ifr &amp;&amp; ifr.contentWindow &amp;&amp; ifr.contentWindow</span><br><span class="line">log(<span class="string">`<span class="subst">$&#123;ifrWin.name&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><p>项目例子对应启动代码<code>npm run windowName</code>。具体的实现可以看代码</p><h1 id="使用-WebSocket-实现跨域"><a href="#使用-WebSocket-实现跨域" class="headerlink" title="使用 WebSocket 实现跨域"></a>使用 WebSocket 实现跨域</h1><p>这个不说了，WS是没有域限制的，不同域名、端口下随便连接，但是后台WS服务一般有鉴权，所以也不是随便就可以连伤的。还可以开多个WS连接链接好几个不同源（亲测3个稳定连接，在微信手Q里面）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/entry/57d21eadbf22ec005f9c7d76" rel="external nofollow noopener noreferrer" target="_blank">实现跨域的几种方式</a></li><li><a href="https://www.cnblogs.com/2050/p/3191744.html" rel="external nofollow noopener noreferrer" target="_blank">无双-js中几种实用的跨域方法原理详解</a></li><li><a href="https://segmentfault.com/a/1190000011811117" rel="external nofollow noopener noreferrer" target="_blank">axios的cookie跨域以及相关配置</a></li></ul></div><footer class="article-footer"><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"5b9db2c4dd040aa5a359",clientSecret:"c2f2d6135ff1a35ac3465139f113e55d96b9a53a",repo:"manfredHu.github.io",owner:"ManfredHu",admin:["ManfredHu"],id:location.pathname,distractionFreeMode:!0});gitalk.render("gitalk-container")</script><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CORS/">CORS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsonp/">jsonp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/postMessage/">postMessage</a></li></ul></footer></div><nav id="article-nav"><div class="article-nav-left"><a href="/2019/01/18/45-x-forwarded-for/" class="thumbnail"><span style="background-image:url(/images/x-forwarded-for1.jpg)" alt="如何获取请求方的ip" class="thumbnail-image"></span></a> <a href="/2019/01/18/45-x-forwarded-for/" class="hover-color"><div class="dark-dialog"></div><strong class="article-nav-caption">上一篇</strong><div class="article-nav-title">如何获取请求方的ip</div></a></div><div class="article-nav-rigth"><a href="/2019/01/07/43-websocket/" class="thumbnail"><span style="background-image:url(/images/html5-websocket.png)" alt="websocket原理和实践" class="thumbnail-image"></span></a> <a href="/2019/01/07/43-websocket/" class="hover-color"><div class="dark-dialog"></div><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">websocket原理和实践</div></a></div></nav></article><div class="big-sidebar"><div class="fix-sidebar"><div class="fix-sidebar-nav"><span>展开目录</span></div><div class="fix-sidebar-comment"><span>评论</span></div><div class="fix-sidebar-share"><span>分享</span></div><div class="fix-sidebar-music"><span>音乐</span></div><a class="fix-sidebar-github" href="https://github.com/manfredHu" target="_blank" alt="Fork me on GitHub" rel="external nofollow noopener noreferrer">Github</a> <a class="fix-sidebar-totop" href="#top" alt="返回顶部">TOP</a></div><aside id="markdown-sidebar"><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CORS"><span class="toc-number">2.</span> <span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#axios开启cookie传输"><span class="toc-number">2.1.</span> <span class="toc-text">axios开启cookie传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express开启cookie传输"><span class="toc-number">2.2.</span> <span class="toc-text">express开启cookie传输</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSONP"><span class="toc-number">3.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#服务器转发请求跨域"><span class="toc-number">4.</span> <span class="toc-text">服务器转发请求跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-amp-CDN"><span class="toc-number">4.1.</span> <span class="toc-text">nginx &amp; CDN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node"><span class="toc-number">4.2.</span> <span class="toc-text">node</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postMessage"><span class="toc-number">5.</span> <span class="toc-text">postMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器接口"><span class="toc-number">5.1.</span> <span class="toc-text">浏览器接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#修改document-domain来跨子域"><span class="toc-number">6.</span> <span class="toc-text">修改document.domain来跨子域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#window-name"><span class="toc-number">7.</span> <span class="toc-text">window.name</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-WebSocket-实现跨域"><span class="toc-number">8.</span> <span class="toc-text">使用 WebSocket 实现跨域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></aside><div id="musicComponent"></div></div></section></div><div align="center" style="margin-top:30px"><hr class="hr" style="margin:0;height:3px"></div><footer id="footer"><div class="container"><div class="row"><p id="copyRightEn">Copyright &copy; 2015 - 2019 ManfredHu胡文峰的个人博客</p><p>All rights reserved. Designed and powered by ManfredHu.</p><p><a target="_blank" href="http://www.miitbeian.gov.cn/state/outPortal/loginPortal.action" rel="external nofollow noopener noreferrer">粤ICP备18133029号</a></p></div></div></footer><!--[if lt IE 9]>
<p class="chromeframe">您使用的IE浏览器版本过低，为获得更佳浏览体验，<a href="http://windows.microsoft.com/">建议升级您的IE浏览器</a>，或使用<a href="http://www.google.com/chromeframe/?redirect=true">Google Chrome</a>、<a href="http://www.firefox.com.cn/">Firefox</a>等高级浏览器，将会得到更好的体验！</p>
<![endif]--><script>var wrapdiv=document.getElementById("wrap"),contentdiv=document.getElementById("content"),allheaderHeight=document.getElementById("allheader")?document.getElementById("allheader").offsetHeight:0,footerHeight=document.getElementById("footer")?document.getElementById("footer").offsetHeight:0;wrapdiv.style.minHeight=document.body.offsetHeight+"px",contentdiv.style.minHeight=document.body.offsetHeight-allheaderHeight-footerHeight+"px"</script></div><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script><script>var _mtac={};!function(){var t=document.createElement("script");t.src="https://pingjs.qq.com/h5/stats.js?v2.0.2",t.setAttribute("name","MTAH5"),t.setAttribute("sid","500652330");var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></div><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display:none"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><h2 class="modal-title" id="myModalLabel">设置</h2></div><hr style="margin-top:0;margin-bottom:0;width:80%;border-top:3px solid #000"><hr style="margin-top:2px;margin-bottom:0;width:80%;border-top:1px solid #000"><div class="modal-body"><div style="margin:6px"><a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="setFontSize()" aria-expanded="true" aria-controls="collapseOne">正文字号大小</a></div><div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne"><div class="panel-body">您已调整页面字体大小</div></div><div style="margin:6px"><a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="setBackground()" aria-expanded="true" aria-controls="collapseTwo">夜间护眼模式</a></div><div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo"><div class="panel-body">夜间模式已经开启，再次单击按钮即可关闭</div></div><div><a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a></div><div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree"><div class="panel-body">ManfredHu胡文峰的个人博客</div><div class="panel-body">Copyright © 2019 ManfredHu All Rights Reserved.</div></div></div><hr style="margin-top:0;margin-bottom:0;width:80%;border-top:1px solid #000"><hr style="margin-top:2px;margin-bottom:0;width:80%;border-top:3px solid #000"><div class="modal-footer"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div></div></div></div></body><!-- rebuild by neat -->