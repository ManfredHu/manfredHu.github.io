{"meta":{"title":"ManfredHu胡文峰的个人博客","subtitle":null,"description":"Stay hungry, stay foolish. Keep looking, don't settle.","author":"ManfredHu","url":"http://www.manfredhu.com"},"pages":[{"title":"","date":"2017-02-10T17:13:32.000Z","updated":"2016-03-26T19:16:40.000Z","comments":true,"path":"404.html","permalink":"http://www.manfredhu.com/404.html","excerpt":"","text":"404"},{"title":"","date":"2017-02-10T17:13:32.000Z","updated":"2016-03-26T18:34:06.000Z","comments":true,"path":"baidu_verify_KNYdPFyuaj.html","permalink":"http://www.manfredhu.com/baidu_verify_KNYdPFyuaj.html","excerpt":"","text":"KNYdPFyuaj"},{"title":"About Me","date":"2017-04-25T18:19:57.000Z","updated":"2017-04-25T18:19:57.000Z","comments":true,"path":"about/index.html","permalink":"http://www.manfredhu.com/about/index.html","excerpt":"","text":"NameNickname: manfredhuRtx: pphuChinese Name: 胡文峰SchoolGDUT(Guangdong University of Technology)，广东工业大学Origin PlaceGuangdong，Shanwei，宇宙银河系太阳系地球亚洲中国广东省汕尾市Job现就职Tencent腾讯深圳总部，担任Web前端开发工程师ContactQQ: 279331641E-mail: 279331641@qq.comWechat: id为hwf_pp或者扫描下面二维码推荐如有意加入腾讯这个大家庭，请留言并将简历投递到我的邮箱 :)"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2016-11-10T07:11:10.000Z","comments":true,"path":"archives/index.html","permalink":"http://www.manfredhu.com/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2016-11-10T07:11:10.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.manfredhu.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2016-11-10T07:11:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.manfredhu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DNS解析和配置","slug":"35-dns-parse","date":"2018-10-24T07:50:25.000Z","updated":"2018-10-25T08:49:03.259Z","comments":true,"path":"2018/10/24/35-dns-parse/","link":"","permalink":"http://www.manfredhu.com/2018/10/24/35-dns-parse/","excerpt":"","text":"从面试题说起经典的问题，用户在浏览器输入网址按下回车到网页呈现在用户面前中间经历了什么。比如输入了www.qq.com，第一步肯定是本地查找DNS记录或者递归DNS服务器一级一级往上找，最后拿到一个IP地址。所以DNS可以理解为，域名 =&gt; IP地址 的过程。DNS解析配置我们可以看到，访问www.manfredhu.com和manfredhu.github.io最后返回的IP都是一样的。我们看下我们配置的DNS解析配置。可以看到只有两条记录，这里起作用的是下面那条1www CNAME 默认 manfredhu.githuDNS记录的含义A (Address) 记录是用来指定域名对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。CNAME：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。所以这里看A记录和CNAME记录是平等同级的，一个是指定IP，一个可以指定这个域名是另一个域名的别名，访问这个域名相当于访问另一个域名。如上面，我们访问了www.manfredhu.com其实就是访问的manfredhu.github.io了。manfredhu.github.io 是git page生成的静态网页，经常用来做为项目介绍或者个人博客。具体的可以自行Google搜下，一般看后缀，如果是github.io，一般都是git page页面。但其实A记录和CNAME记录还是有点不太一样的。比如这里www.manfredhu.com是要映射到manfredhu.github.io的，但是manfredhu.github.io其实也是个域名，最后还是要转化为ip，如上图，其实也可以把添加A记录，把www.manfredhu.com解析到185.199.111.153。但是这里因为manfredhu.github.io的解析不归我们控制可能会变化，所以这里填写CNAME记录的话会很稳定，因为我访问www.manfredhu.com走的还是manfredhu.github.io，github如果改了ip，我这里没感知的。但是如果我添加A记录，把www.manfredhu.com解析到185.199.111.153，如果185.199.111.153这个IP的机器挂了，那我的网站就挂了。但是A记录有它自己的好处，例如可以在输入域名时不用输入WWW.来访问网站哦！从SEO优化角度来看，一些搜索引擎如alex或一些搜索查询工具网站等等则默认是自动去掉WWW.来辨别网站，CNAME记录是必须有如：WWW(别名)前缀的域名，有时候会遇到这样的麻烦，前缀去掉了默认网站无法访问。所以其实A记录和CNAME记录都有自己的作用，如果单纯的git page域名解析，即访问www.manfredhu.com你可以加下面这条记录主机记录记录类型线路类型记录值wwwCNAME默认manfredhu.github.io如果访问的是manfredhu.com你可以加下面这条记录，这样的话访问manfredhu.com和www.manfredhu.com都会到manfredhu.github.io|去了。主机记录记录类型线路类型记录值@CNAME默认manfredhu.github.iodig命令查看DNS解析过程dig命令一般就用来看域名=&gt;IP这个过程的，可以自己打下dig -help看下。百度DNS一个有趣的现象12345678910111213141516171819202122[root@VM_16_14_centos ~]# dig www.baidu.com; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; www.baidu.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 2979;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;www.baidu.com. IN A;; ANSWER SECTION:www.baidu.com. 764 IN CNAME www.a.shifen.com.www.a.shifen.com. 12 IN A 61.135.169.121www.a.shifen.com. 12 IN A 61.135.169.125;; Query time: 0 msec;; SERVER: 183.60.83.19#53(183.60.83.19);; WHEN: Thu Oct 25 15:27:35 CST 2018;; MSG SIZE rcvd: 101你可以看到www.baidu.comCNAME到一个www.a.shifen.com去了。关于这个域名有个很有趣的故事,戳这里","categories":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.manfredhu.com/categories/工作经验/"}],"tags":[{"name":"DNS解析","slug":"DNS解析","permalink":"http://www.manfredhu.com/tags/DNS解析/"}]},{"title":"图片自适应大小、压缩demo","slug":"34-picture-fileUpload","date":"2018-10-22T10:36:45.000Z","updated":"2018-10-22T13:00:52.637Z","comments":true,"path":"2018/10/22/34-picture-fileUpload/","link":"","permalink":"http://www.manfredhu.com/2018/10/22/34-picture-fileUpload/","excerpt":"","text":"图片上传demo原理一个图片上传demo，可以上传图片，然后按照最大宽度和最大高度，先触边的为目标，等比例缩放后绘制canvas显示。然后把canvas数据转化为base64位数据，这个时候就大家就可以自由传递数据到后台了。拖拽裁剪之类的大家再去找下其他插件把，demo只做演示用。这里canvas.toDataURL这个接口，有两个可选参数第一个参数是文件类型，默认为 image/png，图片的分辨率为96dpi第二个是编码选项，在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。这里注意png图片的是没有压缩比例这个参数控制的，所以传了也没用。但是png图片我们可以通过等比缩放大小来控制图片大小限制手机拍照原图的大小一般是好几M以上，而很多时候这个大小实际用不到，几百K的图片用的居多。所以一般会做压缩处理，这个压缩如果放在后台的话，5M的照片用户就需要上传5M的流量，100张就是500M。手机流量贵，所以这个压缩过程放在前端是大家喜闻乐见的！图片压缩大小的限制，jpeg等可以通过压缩比例控制。png格式可以通过缩放图片大小控制。但是都离不开最后一步将canvas转化为数据的过程，base64是用toDataURL()接口，然后如果需要的是二进制数据，可以用toBlob()接口。通过改变canvas的大小，预算数据大小，活着预先调用toDataURL接口转化后计算图片大小。满足约束条件即可，如果不满足可能要多试几次。基本思路就这样。示例源代码也可以点击这里123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;图片上传压缩测试&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 图片最大宽度（超出会自动裁剪）:&lt;input class=\"imgMaxWidth\" type=\"text\" value=\"200\" placeholder=\"正整数\" /&gt; &lt;/div&gt; &lt;div&gt; 图片最大高度（超出会自动裁剪）:&lt;input class=\"imgMaxHeight\" type=\"text\" value=\"200\" placeholder=\"正整数\" /&gt; &lt;/div&gt; &lt;div&gt; 图片压缩比例（jpeg可选压缩比例）: &lt;input class=\"imgQulity\" type=\"text\" value=\"0.1\" placeholder=\"0到1\" /&gt; &lt;/div&gt; &lt;input id=\"file\" type=\"file\" accept=\"image/*\" /&gt; &lt;script&gt; var eleFile = document.querySelector('#file'); // 压缩图片需要的一些元素和对象 var reader = new FileReader(), img = new Image(); // 选择的文件对象 var file = null; // 缩放图片需要的canvas var canvas = createElement('canvas'); var context = canvas.getContext('2d'); // base64地址图片加载完毕后 img.onload = function () &#123; // 图片原始尺寸 var originWidth = this.width; var originHeight = this.height; // 最大尺寸限制 // var maxWidth = 400, maxHeight = 400; var maxWidth = document.querySelector('.imgMaxWidth').value, maxHeight = document.querySelector('.imgMaxHeight').value; if (typeof parseInt(maxWidth) !== 'number' || typeof parseInt(maxHeight) !== 'number') &#123; alert(\"图片最大宽度与图片最大高度必须为正整数\"); return; &#125; // 目标尺寸 var targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过400x400的限制 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123; if (originWidth / originHeight &gt; maxWidth / maxHeight) &#123; // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); &#125; else &#123; targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); &#125; &#125; // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 图片压缩 context.drawImage(img, 0, 0, targetWidth, targetHeight); // https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL // canvas.toDataURL(type, encoderOptions); // 图片格式，默认为 image/png // 在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。 var imgData = canvas.toDataURL(file.type || 'image/png', document.querySelector('.imgQulity').value); log('压缩后的图片数据(base64)：'); log(imgData); var image = createElement(\"img\"); image.src = imgData; log(\"压缩后的图片大小：\" + calcFileSize(imgData) + \"KB\"); &#125;; // 文件base64化，以便获知图片原始尺寸 reader.onload = function (e) &#123; img.src = e.target.result; &#125;; eleFile.addEventListener('change', function (event) &#123; file = event.target.files[0]; log(\"上传的图片大小：\" + file.size + \"字节（约\" + (file.size / 1024).toFixed(2) + \"kb)\"); // 选择的文件是图片 if (file.type.indexOf(\"image\") == 0) &#123; reader.readAsDataURL(file); &#125; &#125;); function log(text) &#123; var temp = document.createElement('p'); temp.appendChild(document.createTextNode(text)); document.body.appendChild(temp); &#125; // 通过base64文件估算文件大小, 返回字节大小 function calcFileSize(base64) &#123; let blen = base64.length; return (blen - (blen / 8) * 2) / 1024; &#125; function createElement(element)&#123; var tempDiv = document.createElement('div'); var tempElement = document.createElement(element); tempDiv.appendChild(tempElement); document.body.appendChild(tempDiv); return tempElement; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.manfredhu.com/categories/工作经验/"}],"tags":[{"name":"图片上传","slug":"图片上传","permalink":"http://www.manfredhu.com/tags/图片上传/"},{"name":"图片压缩","slug":"图片压缩","permalink":"http://www.manfredhu.com/tags/图片压缩/"}]},{"title":"前端常用shell(Mac OS)","slug":"33-mac-shell","date":"2018-08-28T13:20:37.000Z","updated":"2018-10-23T09:42:53.001Z","comments":true,"path":"2018/08/28/33-mac-shell/","link":"","permalink":"http://www.manfredhu.com/2018/08/28/33-mac-shell/","excerpt":"","text":"常常有写shell平时用不到，参数记忆比较模糊。但是用到的时候又想找个地方查一下。这个时候就很蛋疼了，故作笔记记录下，方便翻阅。端口占用不知道大家有没有遇到过端口占用的情况。解决方法分两步找到是哪个进程占用了这个端口kill掉这个进程对应的命令lsof -i:4000 查找占用4000端口的进程kill 13219如下为lsof -i:4000输出的结果，我们第二步根据PID(进程id)来kill掉进程.12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 13219 pphu 28u IPv4 0xbca6de3c7141352d 0t0 TCP *:terabase (LISTEN)alias这个是常用的提高效率的方法，一般跟两个文件有关~/.bash_profile 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.~/.bashrc 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.如果没有这两个文件可以自己新建一个cd ~touch .bashrctouch .bash_profile所以可以在两个文件随便一个设置aliascd ~ll -avi .bashrc12345678910alias i=&quot;install&quot;alias wb=&quot;wbuild server&quot;alias st=&quot;status&quot;alias co=&quot;checkout&quot;alias ci=&quot;commit&quot;alias br=&quot;branch&quot;alias gst=&quot;git status&quot;alias gco=&quot;git checkout&quot;alias gbr=&quot;git branch&quot;alias gci=&quot;git commit&quot;ps: 有遇到过重启启不生效的情况，所以最好将1source ~/.bashrc这句加在~/.bash_profile最后，这样每次都会执行.bashrc文件的alias最后，如果你用的是zsh，比如mac标配iterm2+zsh。那么iterm2生效的配置就不是.bash_profile而是~/.zshrc了。所以要把1source ~/.bash_profile这句加在~/.zshrc最后。ls -alhls查看文件大家都知道了就不多说了；ls -a可以查看隐藏的一些以.开头的文件；ls -al可以以列表形式显示文件信息；但是很蛋疼，这里显示的是字节，我们更直观的是显示多少K，多少M。这个时候ls -alh就可以满足你的诉求了权限问题如何看一个文件的权限？12345678➜ .ssh lltotal 56-rw-r--r-- 1 manfredhu ***** 778B 10 22 15:04 config-rw------- 1 manfredhu ***** 1.6K 3 11 2018 id_rsa-rw-r--r-- 1 manfredhu ***** 398B 3 11 2018 id_rsa.pub-rw-r--r-- 1 manfredhu ***** 5.6K 10 17 19:54 known_hosts-rwxr-xr-x 1 manfredhu ***** 301B 7 25 15:58 login.exp-rwxr-xr-x 1 manfredhu ***** 1.1K 3 16 2018 ssh.m2.expect这里ssh.m2.expect前面的-rwxr-xr-x，第一位是d（目录）或者-（文件）。之后是三组rwx，分别代表read读取,write写入,exec执行。1-3位数字代表文件所有者的权限4-6位数字代表同组用户的权限7-9数字代表其他用户的权限所以这里ssh.m2.expect的权限是文件所有者可以读写执行，同组用户和其他用户可以读和执行。权限计算的方式读取的权限等于4，用r表示写入的权限等于2，用w表示执行的权限等于1，用x表示所以这里ssh.m2.expect的权限用数据表示就是755。授权如果你想要让所有用户拥有这个文件的读写执行，那么就可以用1chmod 777 ssh.m2.expect更改文件的授权curl很多时候要测试接口的调取可以命令行直接测试。比如你想模拟MacOS的UA就可以用下面这个，类似的iphone，ipad巴拉巴拉的UA1curl -A 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36' www.qq.com","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.manfredhu.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.manfredhu.com/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.manfredhu.com/tags/MVVM/"}]},{"title":"Vue备忘笔记","slug":"32-vue-notes","date":"2018-08-23T16:03:29.000Z","updated":"2018-08-28T13:50:58.920Z","comments":true,"path":"2018/08/24/32-vue-notes/","link":"","permalink":"http://www.manfredhu.com/2018/08/24/32-vue-notes/","excerpt":"","text":"本文主要记录一些比较容易遗忘的知识点，方便后面查阅。如果对你有帮助，那不胜荣幸。前端变化出的另一个优雅工具自打部门研发基于Vue的适配H5、小程序、Weex的多端系统后，因为在深入进行H5游戏引擎和游戏物理引擎的开发对Vue就没怎么关注。错过了上手的最好时机，现在把这块给补上。组件生命周期与方法顺序组件生命周期12345678910new Vue -&gt; Init Events &amp; Lifecycle -&gt;(1) Init injections &amp; reactivity (2) -&gt; no el vm.$mount(el) is called -&gt; Has el option -&gt; has template option then Compile template into render function -&gt; no template option Compile outerHTML as template(整个替换掉) -&gt; (3) Create vm.$el and replace (4) -&gt; Mouted then (5) Remouted if data changes (6) -&gt; when vm.$destroy() is called (7) -&gt; Teardown watchers,child components and event listeners -&gt; Destroyed (8)所以顺序依次是:beforeCreateCreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestroydestroyed方法顺序Props -&gt; Methods -&gt; Data -&gt;Computed -&gt; Watch具体可以见这里的源代码如果有同名属性，一般都会报错。so这里要注意同名属性的存在。slot-scope插槽部分基础文档有说过，如字面意思。你插拔内存，插拔硬盘接口等等。换内存就如同换组件。4G的、8G的，对应的就是不同组件的不同功能。默认的单个插槽（匿名插槽），如下父组件：12345678910&lt;template&gt; &lt;div class=\"father\"&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;child&gt; &lt;div class=\"tmpl\"&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt;子组件：123456&lt;template&gt; &lt;div class=\"child\"&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;最后渲染为:123456789&lt;div class=\"father\"&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;div class=\"child\"&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;div class=\"tmpl\"&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;而slot-scope是带有数据的插槽，数据是通常是子元素传入到插槽内的。123&lt;slot slot-scope=\"xxx\"&gt; //这里可以获取&lt;/slot&gt;比如子组件异步拉了一个接口，就可以把数据传递给父组件嵌套的组件。最后渲染为:123456&lt;div class=\"father\"&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;div class=\"child\"&gt; //这里可以获取到上面传递的数据 &lt;/div&gt;&lt;/div&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.manfredhu.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.manfredhu.com/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"http://www.manfredhu.com/tags/MVVM/"}]},{"title":"Git Flow在大型多人合作总的使用","slug":"31-git-flow","date":"2018-08-23T15:58:58.000Z","updated":"2018-09-04T05:46:23.153Z","comments":true,"path":"2018/08/23/31-git-flow/","link":"","permalink":"http://www.manfredhu.com/2018/08/23/31-git-flow/","excerpt":"","text":"SVN的痛记得大学在工作室的时候起初用的版本管理工具是SVN，多人开发以其中一个同学的机器创立本地版本库。之后其他同学局域网链接这个同学的机器提交代码做中心化的版本管理。然后有时候吧，合并的时候遇到各种坑爹问题合并不了或者相互覆盖，所以经常在合并之前会自己保留自己的代码一份再去合并。或者是出问题了，要重新拉一下svn的代码，本地合并完再提交。灰常蛋疼。还有更坑爹的是，有时候线上有一个bug要经济修复，然后本地还有在开发的代码，这个时候就不得不checkout多一份代码，做hotfix，然后解决完再合并。项目小还好，但是如果项目一大，光checkout代码就耗时很久了。但是后面换到git之后，这种情况没怎么发生了，从一个侧面来说明，也是git优秀于svn的地方，是一个分布式的仓库，而不是集中式的代码版本管理。GitGit是个好东西大家都知道，但是经常会有童鞋对git的一些指令了解不是很深入，毕竟团队人员技术水平参差不齐，又不能一一要求。这个时候git-flow就登场了，通过寥寥几个命令你就可以快速掌握企业级的git研发流程。推荐软件https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow客户端软件： SourceTree关于git-flow当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。基本上你可以定义一个完全适合你自己项目的工作流程，或者使用一个别人定义好的。就是git-flow脚本，你不需要去记忆很多的git指令，比如git fetch、git pull和git rebase的区别之类的。具体的可以点击这里几个脚本命令初始化git flow init [-d] -d选项可选，如果有-d则默认所有选项为默认（推荐）feature特性分支git flow feature start[] base可选参数必须是分支，默认为developgit flow feature publishgit flow feature finishgit flow feature deleterelease发布分支git flow release start[]git flow release publishgit flow release finishgit flow release deletebase可选参数必须是分支，默认为develop˙hotfix修复bug分支git flow hotfix start[]git flow hotfix publishgit flow hotfix finishgit flow hotfix deletebase可选参数必须是分支，默认为develop","categories":[{"name":"工作经验","slug":"工作经验","permalink":"http://www.manfredhu.com/categories/工作经验/"},{"name":"基本技能","slug":"工作经验/基本技能","permalink":"http://www.manfredhu.com/categories/工作经验/基本技能/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.manfredhu.com/tags/Git/"},{"name":"版本管理","slug":"版本管理","permalink":"http://www.manfredhu.com/tags/版本管理/"}]},{"title":"几种常见的ES6改进写法","slug":"30-es6-normal-error","date":"2017-11-06T16:15:37.000Z","updated":"2018-09-04T05:39:05.194Z","comments":true,"path":"2017/11/07/30-es6-normal-error/","link":"","permalink":"http://www.manfredhu.com/2017/11/07/30-es6-normal-error/","excerpt":"","text":"下面是自己总结的ES6对ES5提升非常大的写法,代码会更加优雅.如果你真的想让自己的代码写的更少,作用更大,那你应该好好研究研究下面出现的情况.用解构写法替换object写法12345678910111213141516171819//---bad---// options 上的属性表示附加参数function setCookie(name, value, options) &#123; options = options || &#123;&#125;; let secure = options.secure, path = options.path, domain = options.domain, expires = options.expires; // 设置 cookie 的代码&#125;// 第三个参数映射到 optionssetCookie(\"type\", \"js\", &#123; secure: true, expires: 60000&#125;);很多 JS 库都包含了与此例 setCookie() 类似的函数。在此函数内， name 与 value 参数是必需的，而 secure 、 path 、 domain 与 expires 则可选。并且由于此处对其余数据并没有顺序要求，将它们作为 options 对象的特定属性会更有效，避免列出一堆额外的具名参数。虽然这种方法有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数体的代码。12345678910//---bad---function setCookie(name, value, &#123; secure, path, domain, expires=24*3600*1000 &#125; = &#123;&#125;) &#123; // 设置 cookie 的代码&#125;setCookie(\"type\", \"js\", &#123; secure: true, expires: 60000&#125;);这种更好的写法用了解构函数,让你的方法定义更加明确.传入默认的空的方法会防止你没有传入options多选参数的时候导致的解构错误.解构函数更加方便123456789101112131415//---better---let node = &#123; type: \"Identifier\", name: \"foo\"&#125;;let type = node.type, name = node.name, value = node.value, baby = node.baby || 'BB';console.log(type); // \"Identifier\"console.log(name); // \"foo\"console.log(value); // undefinedconsole.log(baby); // \"BB\"不知道你写过这样的代码没有,反正我是写过,ES6让我飞上了天.请看下面的代码:123456789101112//---better---let node = &#123; type: \"Identifier\", name: \"foo\"&#125;;let &#123; type, name, value, baby = 'BB' &#125; = node;console.log(type); // \"Identifier\"console.log(name); // \"foo\"console.log(value); // undefinedconsole.log(baby); // \"BB\"这里直接对node的变量进行解析使用,你不用重新声明变量然后再使用,也不用做判空和赋予默认值的操作,直接一句代码就可以搞定全部.警惕错误null对解构的影响12345678910111213function setCookie(name, value, &#123; secure = false, path = \"/\", domain = \"example.com\", expires = new Date(Date.now() + 360000000) &#125; = &#123;&#125;) &#123; console.log(arguments); console.log(secure);&#125;setCookie('xixi',123,null); //报错,null.secure找不到setCookie('xixi',123,undefined); //可以运行,secure等四个可选参数全部为默认值多行字符串以前写多行字符串用的是\\做转意连接符,或者是用\\n来做换行等.现在不需要了,写模版会更加方便.1234567891011//---bad---var message = \"Multiline \\string\";console.log(message); // \"Multiline string\"//betterlet message = `Multilinestring`;console.log(message); // \"Multiline // string\"console.log(message.length); // 16扩展运算符获取一个数组最大值的方法,有人是取数组第一项为最大,之后迭代数组,更加优雅的是用Math.max来做,但是ES6让优雅更近一步.1234567//---bad---let values = [25, 50, 75, 100]console.log(Math.max.apply(Math, values)); // 100//betterlet values = [25, 50, 75, 100]console.log(Math.max(...values)); // 100异步文件1import( /* webpackChunkName: \"xxxx\" */ 'xxxx.js');一个promise的异步文件的用法，可以对文件起别名（chrome network 可以看到）1234//exampleexport let config = &#123; resolve: (props) =&gt; import(`templates/$&#123;props.templateId&#125;`),&#125;;当然这里依赖了一些模块和配置，如下webpack配置:12345output: &#123; publicPath: &apos;/&apos;, filename: &apos;scripts/[name].[chunkhash].js&apos;, chunkFilename: &apos;scripts/[id].[name].[chunkhash].js&apos;,&#125;,webpack 2.6.0以后，支持使用注释的方式给动态导入的模块添加chunk name标准语法如下：12345import( /* webpackChunkName: \"my-chunk-name\" */ /* webpackMode: \"lazy\" */ 'module');","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://www.manfredhu.com/categories/JavaScript/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.manfredhu.com/tags/ES6/"}]},{"title":"前端行业发展现状分析","slug":"28-font-end-development","date":"2017-11-05T10:38:59.000Z","updated":"2017-11-05T10:49:01.000Z","comments":true,"path":"2017/11/05/28-font-end-development/","link":"","permalink":"http://www.manfredhu.com/2017/11/05/28-font-end-development/","excerpt":"","text":"先说下本人身份，大二开始接触互联网、大三某大型搬砖公司实习满一年，今年七月毕业刚入职某大型搬砖企业。按照我Leader给别人介绍我的时候就说：这是今年的毕业生，不过已经有一年的工作经验了。下面我会从一个刚毕业不久、但是已经有一年左右工作经验的“入门级”前端开发来给你介绍一下如何加入“前端”这个行业。我们先来简单介绍一下前端发展到现在的现状，再告诉大家如何入坑“前端”。传统的Web服务前端从原来的网页设计、网页制作到逐渐发展起来的jQuery时代，再到后面的工程时代，开始引入工程化的概念，MVVM框架频出。大概2005年到现在2017年，发展了10多年左右。期间除了不断引入其他领域的概念、方法来提高工作效率之外，还不断侵入其他领域并创新地发展。如Nodejs已经可以代替PHP作为后台接入层了（机器相同情况下性能更好），相当于前端掌握了客户端到服务器网络传输的通道。只要浏览器／客户端与调试通了，Node再调用后台服务就好了。浏览器大跃进时代近几年IE浏览器份额下滑非常严重，从去年Win10的Edge（换了IE内核）推出开始已经表明了微软公司在浏览器失去了霸主地位了，今年的Chrome浏览器份额继续提升。随着Win7升级到Win10，Chrome大有一统浏览器界的趋势。当然国内因为各大政府单位、学校对IE的无限贡献导致IE还是有一定的份额，不过后面这部分是肯定会被废弃的。如果你实在要做兼容，那推荐你还是把他们的电脑都装了Chrome然后把图标换成IE吧。Chrome浏览器为什么代表了一个大跃进时代？因为其静默更新的性质导致它对新的技术特性的支持度十分好。相当于你浏览器不用手动更新，一定是比较新的版本。对开发人员来说是大大提升他们的开发效率的。所以说现在的前端是处在浏览器大统一的“红利”时代移动、物联智能时代热潮的到来我们现在处于大移动时代，距离物联智能时代也不远了。这也对前端的发展起到了推进的作用，为什么大移动时代、物联智能时代会推动前端的发展？Web相对于传统的软件是一个巨大的提升，软件要安装，网站打开就能用了。在物联网智能时代，设备增多，如果每个设备安装软件，肯定没有只安装一个浏览器打遍天下便利。你会说安卓APP，APP只对固定形式的内容起作用，动态的东西其实还是网页方式容易开发。你知道微信是一个巨型浏览器吗？小程序就是一个Native网页。全栈开发我一直对全栈开发不感冒，可能很多人连Node本地服务都没写过部署过，学了了一下Node的API搞了下Sass／Less的编译就说自己是全栈了。业内有说全栈＝什么都不会的说法，或者有人自命全栈开发工程师，个人理解这应该是一种自我驱动的使命性命名，代表你对自己的要求比一般的前端开发多。也可以理解为超越一般前端开发水平的工程师。可能是后端转到前端方向的，也可能是前端干的很不错，要顺着Node涉猎后台部分了。说一下我自己接触的后台技术（没有存在客户端的部分）：第一个时期是C＃和.Net时期，纯粹拉控件开发的体验，也就是现在前端的“组件化”的雏形，这其实是人家PC软件玩烂的东西。引入到前端变成了“热门”的概念，所以从这里可以看到很多其他领域的东西被引入了前端。第二个时期因为一个项目是Java Web开发的，需要二次维护，于是入坑Java Web开发。一两个星期看API学语言，带着C＃.Net的基础过去，模仿着写，基本相当于熟悉了一下JavaWeb API和Eclipse的感觉。个人感觉就是没有C＃开发那么简便，新手也没有用什么框架。第三个时期是接触Nodejs部分，自己独立搞了一台机器部署Node服务。有人会说哇你好厉害啊，接触了这么多后台的东西，你是全栈开发吗？我不敢说自己会后端，只能说大概对Web开发的流程有一定的了解，这些自己摸的坑在现在的工作中也收益着，因为我比其他人理解后台的逻辑。我会的这些也不属于“后台”的部分，我觉得另外一个词可以代表后台——高并发和高可用，所以从来不敢声称自己会后台，因为我的服务访问量根本不需要并发，core了最多重启服务。几万、几百万、几亿、十几亿的访问量，后台架构完全是不一样的。所以给在大学的学弟学妹们一句劝，不要以为会很多语言就很牛逼，其实只要在一种上精通，辅以其他专业知识，足够你进BAT了。所谓的精通就是，你在这个部分已经了然于胸，问你什么都可以答出来。大前端时代这也是一个概念，不过其背后产生的背景是近年前端开发领域严重的分化。你可能写过HTML、CSS，也写过简单的JavaScript，做过简单的展示型的网站，然后你说自己是前端从业人员。你可能写过后台服务，然后转型写Nodejs接入层开发、维护，然后你说自己是前端从业人员。你可能由展示性网站转向HTML5游戏开发，用游戏领域的概念和开发方式开发Web游戏，然后你说自己是前端从业人员。你可能由始至终写的就是JavaScript，只不过你更加深入，从架构、工程化出发优化流程，开发库、组件给他人使用，然后你说自己是前端从业人员。你可能以前是一个测试，然后你从自动化测试出发，构建自动化测试系统，对前端页面、Node接入部分进行测试方面的工作。并推动TDD测试驱动开发，然后你说自己是前端从业人员。你可能以前搞的是安卓iOS，某天发现APP居然还可以内嵌网页，于是你搞起了Native，到Weex，然后你说自己是前端从业人员。你可能写的是桌面应用程序，开发类似Atom的编辑器，然后你说你是前端工业人员。你可能是……然后你说自己是前端从业人员前端涉及的领域越来越深入，接触的东西越来越多。会产生究竟什么是前端的疑问，从大前端时代来看，上述全部都是前端范围。前端领域介绍完了，你应该对前端行业现状有一个大概的了解了。接下来我们另外一篇文章再来说下大家关心的，如何入坑前端。请关注我的头条号以及接下来的文章吧。我是ManfredHu，谢谢您的观看。如果你想了解更多前端行业的东西，请关注我的头条号。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"前端","slug":"前端","permalink":"http://www.manfredhu.com/tags/前端/"}]},{"title":"谈谈url这东西","slug":"22-url","date":"2017-08-16T14:58:40.000Z","updated":"2017-08-14T03:51:48.000Z","comments":true,"path":"2017/08/16/22-url/","link":"","permalink":"http://www.manfredhu.com/2017/08/16/22-url/","excerpt":"","text":"URL普及篇，作为互联网从业者如果连链接都不认识，很难交流。不知道你们有没有遇到这样的情况，开发要给产品一个链接叫产品体验，开发说打开链接加个_test=1的参数，产品说，怎么搞啊，我不会呀！！！我不会呀！！！我不会呀！！！所以要普及一些网络姿势！！URL的由来我们的身份证有18个号码，标识了我们的唯一。URL全称Uniform Resource Locator 统一资源定位符（或称统一资源定位器/定位地址、URL地址等，常缩写为URL），有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址。现在它已经被万维网联盟编制为因特网标准RFC 1738。URL的组成部分URL的协议类型:http://www.tmtpost.com/2737087.html?mobile=1&amp;mdebug=1#haha=init&amp;lh=1[scheme:][//host][:port][/pathname][?search][#hash][http:][//www.tmtpost.com][/2737087.html][?mobile=1&amp;mdebug=1][#haha=init&amp;lh=1]举个栗子，如下URL：http://www.tmtpost.com/2737087.html?mobile=1&amp;mdebug=1#haha=init&amp;lh=1标识了一个互联网上的文件的地址。在控制台输入window.location 会输出信息，大概如下12345678910Locationhash:\"#haha=init&amp;lh=1\"host:\"www.tmtpost.com\"hostname:\"www.tmtpost.com\"href:\"http://www.tmtpost.com/2737087.html?mobile=1&amp;mdebug=1#haha=init&amp;lh=1&amp;test=1\"origin:\"http://www.tmtpost.com\"pathname:\"/2737087.html\"port:\"\"protocol:\"http:\"search:\"?mobile=1&amp;mdebug=1\"格式部分例子对应的部分获取代码protocolhttp:window.location.protocolhost//www.tmtpost.comwindow.location.hostporthttp默认为80，https默认为443，本例为空window.location.portpathname/2737087.htmlwindow.location.pathnamesearch?mobile=1&amp;mdebug=1window.location.searchhash#haha=init&amp;lh=1window.location.hashwindow.location.href 和 window.location.replacewindow.location.href 是一个可读可写的属性。读则返回整个URI字符串，写则跳转页面。window.location.replace 是一个方法，同样用于页面跳转，只是同时会把历史纪录替换掉，所以你后退回不去原来的链接，而 window.location.href 是有记录的。注意：这里只可以跳转到同个host下的不同pathname。12345//如果你打开www.baidu.com在控制台输入window.location.href = \"www.qq.com\";//则url会变成 https://www.baidu.com/www.qq.com//百度会告诉你它根本不认识这货而跳转到错误搜索//测试环境为Chrome构建URL业务中经常会用URL的参数，通常是 location.search 这里的部分来做一些业务相关的操作，比如某些功能的体验，加了一个参数就可以打开体验等等。这里通常就是操作http://www.tmtpost.com/2737087.html?mobile=1&amp;mdebug=1#haha=init&amp;lh=1这样链接的 ?mobile=1&amp;mdebug=1部分，通过添加其他参数来构成URL.比如我们上面情景下的开发哥哥想要你加上_test=1。那么就会形成 ?mobile=1&amp;mdebug=1&amp;_test=1的search部分。这里参数以&amp;符号来分割。总的链接为http://www.tmtpost.com/2737087.html?mobile=1&amp;mdebug=1&amp;_test=1#haha=init&amp;lh=1这就是开发哥哥想要的URL了。HASH的读写location.hash为获取的hash，通常的单页SPA下会通过hash的变化来判断执行的模块方法。这块通常也是一些基础面试里面会问到的题目，让你现场写一个东西来获取URL里面的参数，因为场景太常用了，所以是必修题。记得在大三去微信TIT面试的时候有一道就是这样的，考察的是JS正则表达式的使用和对URL的理解是否深刻。hash的常见类型如： #haha=init&amp;lh=1&amp;test=11234567891011121314var URL = &#123;&#125;;URL.setHash = function(hash)&#123; location.hash = hash;&#125;URL.getHash = function()&#123; var hash = location.hash; return hash ? hash.replace(/.*#/,\"\"):\"\"; //删除掉#前面（包括#）的所有字符&#125;URL.getHashParam = function(key)&#123; var hash = URL.getHash(); //这里会取到haha=init&amp;lh=1这样的字符串，用正则来捕获key为传入key的值 var result = hash.match(new RegExp(\"(^|&amp;)\"+ key +\"=([^&amp;]*)(&amp;|$)\")); return result != null ? result[2]: \"\";&#125;SEARCH部分location.search部分为?号 后面的内容，跟HASH类似，也是key=value的模式。search的常见类型如： ?mobile=1&amp;mdebug=1&amp;_test=11234567891011121314151617181920212223242526272829var URL = &#123;&#125;;//HASH部分URL.setHash = function(hash)&#123; location.hash = hash;&#125;URL.getHash = function()&#123; var hash = location.hash; return hash ? hash.replace(/.*#/,\"\"):\"\"; //删除掉#前面（包括#）的所有字符&#125;URL.getHashParam = function(key)&#123; var hash = URL.getHash(); //这里会取到haha=init&amp;lh=1这样的字符串，用正则来捕获key为传入key的值 var result = hash.match(new RegExp(\"(^|&amp;)\"+ key +\"=([^&amp;]*)(&amp;|$)\")); return result != null ? result[2]: \"\";&#125;//SEARCH部分URL.getSearch = function()&#123; var search = location.search; //得到形如 ?mobile=1&amp;mdebug=1 这样的字符串 return search ? search.replace(/.*?/,\"\"):\"\"; //删除掉?前面（包括?）的所有字符&#125;//支持传入urlURL.getSearchParam = function(key,url)&#123; var search = url ? url :URL.getSearch(); //这里会取到haha=init&amp;lh=1这样的字符串，用正则来捕获key为传入key的值 var result = search.match(new RegExp(\"(^|&amp;)\"+ key +\"=([^&amp;]*)(&amp;|$)\")); return result != null ? result[2]: \"\";&#125;URL编码解码window全局对象下有几个方法函数是对URL进行处理的。有这些window.decodeURIwindow.encodeURIwindow.decodeURIComponentwindow.encodeURIComponentwindow.unescapewindow.escape很明显，这是三对类似的情侣。相爱相杀，一个用来解码一个用来编码。首先，我们看一下阮一疯的关于URL编码这里先入个门再来看我们下面的总结部分。废弃的escape和unescape这一对可以对中文进行编解码操作，以前用的比较多，现在已经不提倡使用(废弃)看下面的例子：1234escape(\"醉了\")//\"%u9189%u4E86\"unescape(\"%u9189%u4E86\")//\"醉了\"同理我们可以对比String.charCodeAt方法，这个方法会返回字符串某个字符的unicode编码。escape和String.charCodeAt方法的联系1234\"醉了\".charCodeAt(0) //37257（十进制）\"醉了\".charCodeAt(1) //20102（十进制）parseInt(escape(\"醉\").match(/\\d+/)[0],16) //37257（十进制）parseInt(escape(\"了\").match(/\\d+/)[0],16) //20102（十进制）这里我们用escape编码 醉字得到字符的unicode编码&quot;%u9189&quot;，然后用String.match匹配整数部分得到16进制的9189，然后用parseInt方法将9189转码为十进制得到与charCodeAt方法一样的数字——37257encodeURI和decodeURI这一对会对一些符号进行编码（如空格转为%20），其他一些在网址中有特殊含义的符号”; / ? : @ &amp; = + $ , #”，不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。123456encodeURI(\"醉了\")//\"%E9%86%89%E4%BA%86\"encodeURI(\"醉了 \")//\"%E9%86%89%E4%BA%86%20\"decodeURI(\"%E9%86%89%E4%BA%86%20\")//\"醉了 \"encodeURIComponent和decodeURIComponent与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。因此，”; / ? : @ &amp; = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码1234encodeURI('哈哈hao123;/?:@&amp;=+$,#')\"%E5%93%88%E5%93%88hao123;/?:@&amp;=+$,#\"encodeURIComponent('哈哈hao123;/?:@&amp;=+$,#')\"%E5%93%88%E5%93%88hao123%3B%2F%3F%3A%40%26%3D%2B%24%2C%23\"escape和encodeURIComponent的区别上例说了encodeURI和encodeURIComponent的区别,区别不大.只是在; / ? : @ &amp; = + $ , #这些特殊符号编不编码的问题.而escape和encodeURI的区别则是——Unicode编码和UTF-8的区别.因为escape会将传入的字符串参数转码为Unicode,而encodeURI则会将传入的字符串参数转码为可以直接在互联网传递的UTF-8格式.Unicode和UTf-8UTF-8UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有二条：对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。对照关系如下:Unicode符号范围(十六进制)UTF-8编码方式（二进制）0000 0000-0000 007F0xxxxxxx0000 0080-0000 07FF110xxxxx 10xxxxxx0000 0800-0000 FFFF1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF11110xxx 10xxxxxx 10xxxxxx 10xxxxxxUnicode和UTF-8的转化以醉了的醉字为例1234\"醉\".charCodeAt(0)//37257(十进制)encodeURI('醉')//\"%E9%86%89\"可以这里醉字的UTF-8编码为三字节,E9 86 89转化为二进制为 11101001 10000011 10001001对应上面表格的第三行,将其代入第三行的UTF-8编码的部分,得到替代的x部分为1001 000011 001001则为醉字的Unicode编码部分.123456parseInt('1001 000011 001001'.replace(/\\s/g,''),2)//37065\"醉\".charCodeAt(0)//37257(十进制)parseInt(escape('醉').match(/\\d+/)[0],16)//37257(十进制)","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"基础","slug":"笔记/基础","permalink":"http://www.manfredhu.com/categories/笔记/基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"},{"name":"基础","slug":"基础","permalink":"http://www.manfredhu.com/tags/基础/"}]},{"title":"前端疲劳","slug":"27-front-end-tried","date":"2017-07-25T13:57:58.000Z","updated":"2017-07-25T14:50:20.000Z","comments":true,"path":"2017/07/25/27-front-end-tried/","link":"","permalink":"http://www.manfredhu.com/2017/07/25/27-front-end-tried/","excerpt":"","text":"前端疲劳这个词最近突然在很多文章出现,这次,我躺在家里的沙发上,深刻的思考了一波.近年业务发展多样化,框架层出不穷其实在业务量剧增的今时今日的前端业务,随着各种各样花式框架的出现,不得不说让人挑的眼花缭乱,欲罢不能.随之产生了很大的疲倦的心理.如React,Vue,Angular这些大巨头框架,不但是框架在PK,甚至框架的版本有时候也在PK,比如有的React一推出就用了,后面要更新就发现很难了.甚至于ES6的出现,又让工程增加了一层编译转换的过程(不编译为ES5,无法兼容众多浏览器).这里其实很大抛弃了IE等等老的浏览器了.业务发展多样化导致的细分领域增多在我还是大学生的时候,我会认为前端就是HTML+CSS+JS,后来随着离校实习,接触了越来越多的业务,我会认为前端工程师=入门级设计师+重构工程师+前端开发工程师+入门的后台开发+深厚的计算机基础同样的可以得出:前端=设计+重构+前端开发+简单的后台开发+计算机基础简单粗暴,可能也是大家观念中的全栈,可以一个人写完一套组件或者搭建一套组件系统,以此为准.看的多了,发现每个领域可以深挖的东西太多,不仅仅是设计和交互,重构和前端,后台和运维.一个领域的深挖都非常耗时,不要说各个领域的精通了.所以我后面的想法是用80%精力深挖自己专业的东西,用20%精力去触类旁通,开拓其他领域.讲座没少听,讨论没少发言.渐渐的看到了前端的细分领域,如果让你想象有的前端在写Node接入层,有的前端在写HTML5游戏,不知道你要不要把他们归为前端开发.这是一个很混乱的命题,根源在于我们究竟用什么来鉴别前端开发这个领域?有人会说是开发语言——JavaScript专注于语言层面的,可能从一开始眼界就狭隘了.如何鉴别属不属于前端开发?有古人说:运行于浏览器端为前端,运行于服务端为后台.在Node没有出现之前这句话应该是正确的.但是Node的出现和壮大,极大的打击了这句话的正确性.前端区别于后台的唯一逻辑一定不是开发语言,而应该是开发思想和习惯,一种更加高效,更加热爱折腾,更加开放,不局限于条条框框的思想.今天的前端开发现在的前端开发应该是从各种层面来说的,每一个层面都可以深挖出很多东西,然后去解决过去的痛点.提高用户体验这句话不单单局限于用户,同样适用于开发,特别是前端开发.最终的答案是:前端=前端工程+前端语言+工具+前端架构或许几年后,这个观念又在变化……前端无止境","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"}]},{"title":"游记－涠洲岛","slug":"travel-weizhoudao","date":"2017-06-28T05:31:46.000Z","updated":"2017-06-29T17:17:28.000Z","comments":true,"path":"2017/06/28/travel-weizhoudao/","link":"","permalink":"http://www.manfredhu.com/2017/06/28/travel-weizhoudao/","excerpt":"","text":"涠洲岛不久前刚去涠洲岛旅游，途中见识了为数不多的大风大浪，特地记下。涠洲岛，位于广西壮族自治区北海市北部湾海域中部，北临广西北海市，东望雷州半岛，东南与斜阳岛毗邻，南与海南岛隔海相望，西面面向越南。涠洲岛总面积24.74平方千米，岛的最高海拔79米。岛内景区包括鳄鱼山景区、滴水丹屏景区、石螺口景区、天主教堂景区和五彩滩景区等。涠洲岛是火山喷发堆凝而成的岛屿，有海蚀、海积及溶岩等景观，有“蓬莱岛”之称，是中国地质年龄最年轻的火山岛，也是广西最大的海岛。怎么去涠洲岛？我是从广州南出发去广西北海市，然后坐车到北海的银滩，在从银滩坐船去涠洲岛的。很少见到的离大陆比较远的一个小岛，有24海里，坐船要90分钟！！为什么记得这么清楚，因为天气原因，途中的浪特别大，3/4的船上的人都吐了，我记得我也差不多快吐了，后面愣是没吐出来。后面大家调侃说，我们也算是见过大风大浪的人了哈哈哈。有趣的是有个大姐直接躺地上，失禁了！！对的你没听错，失禁了！！！我才知道原来晕船的最高境界是——失禁！！然后她还不肯起来，工作人员劝说去船后面，她就一直说我失禁了，不能动，最后过当上躺了好几个人当尸体。广州南去北海高铁225RMB左右景色景色确实很美，附上图片如下，大家慢慢欣赏。吃的岛上海鲜特别多，我们住宿在牛栏山的朋友开的客栈，旁边有个圣母教堂的市场，基本上都是海味拉，什么螃蟹皮皮虾、圣子王、石斑、螺、鲳鱼，还有一些越南来的土特产特别多……海边的同学大概不会陌生还有甜甜软软的菠萝蜜，纯天然的木瓜，黄皮枣，香蕉等等。看起来都没打农药，大妈牙齿都掉了，用普通的普通话说2块钱一串愣是让我们买了几串，物价是真心便宜。除了一些坑爹的停车收费（因为岛比较大，都是租的电瓶车出去玩的），村民还是非常淳朴的。玩的岛上还是有很多景点可以去看的，鳄鱼山的景色非常不错。南澳码头的小糖水铺也可以去坐坐，特别有渔家小店的感觉。","categories":[],"tags":[{"name":"游记","slug":"游记","permalink":"http://www.manfredhu.com/tags/游记/"}]},{"title":"CSS的rem单位","slug":"26-rem","date":"2017-05-06T13:43:19.000Z","updated":"2017-05-21T11:27:25.000Z","comments":true,"path":"2017/05/06/26-rem/","link":"","permalink":"http://www.manfredhu.com/2017/05/06/26-rem/","excerpt":"","text":"改变font-size来进行自适应rem 这个属性，通过在 html 元素设置一个初始大小，然后全部单位用 rem 来计算，则页面自适应。兼容性现在大部分浏览器IE9+，Firefox、Chrome、Safari、Opera ，如果我们不修改相关的字体配置，都是默认显示 font-size是16px 即：123html &#123;font-size:16px;&#125;则设置了 &lt;html&gt; 之后，后面的大小样式会这样写，如123p &#123;font-size: 0.75rem; //12÷16=0.75（rem）&#125;所以你很容易想到，根据屏幕宽度和高度来动态改变 &lt;html&gt; 的 font-size 的大小，那么页面的大小也随之变化了。结合JS做自适应布局下面是一段做自适应布局的JS脚本12345678910111213141516171819202122232425/*** 判断用户client width* 然后给html设置一个font-size* 目的是为了方便rem做自适应布局*/(function (doc, win) &#123; var docEl = doc.documentElement, //判断是横竖屏 resizeEvt = 'orientationchange' in window ? 'orientationchange':'resize', func = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; //按照比例缩放 var docElWidth = 100 * (clientWidth / 320); //最大值 if (docElWidth &gt; 200) docElWidth = 200; // console.log(docElWidth); docEl.style.fontSize = docElWidth + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, func, false); doc.addEventListener('DOMContentLoaded', func, false);&#125;)(document, window);","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.manfredhu.com/tags/CSS/"}]},{"title":"JS正则终极篇","slug":"25-js-regexp","date":"2017-03-21T13:50:52.000Z","updated":"2017-08-15T15:49:05.000Z","comments":true,"path":"2017/03/21/25-js-regexp/","link":"","permalink":"http://www.manfredhu.com/2017/03/21/25-js-regexp/","excerpt":"","text":"香港有一个叫郑则仕的演员，就是上面这个了，每次我打正则式，都是联想的他的名字。从开始学习正则到逐渐熟悉，偶尔不用经常会忘记。常常要翻出来查着用，遇到高深的用法常常不知所措，如果你也是这样，那就快快保存这篇博文吧，想不出来了，从头看一遍，保证你回想起全部正则的知识。装逼OK，开始开车。创建RegExp对象直接量/pattern/attributes12var reg = /\\d+/g;var a = &#123;a:1&#125;;这种写法如同直接对象new一个new RegExp(pattern, attributes);12var reg = new RegExp(/\\d/,\"i\")var a = new Object(&#123;a:1&#125;);这种写法如同使用构造函数构建参数i/g/m的作用attributes作为模式选择，有下面几种可以选择。参数含义作用iignore区分大小写gglobal全局匹配mmultiline多行匹配举个栗子：1234var reg = /[a-z]/;var reg2 = /[a-z]/g;console.log(\"abcdefg\".match(reg)); //[\"a\", index: 0, input: \"abcdefg\"]console.log(\"abcdefg\".match(reg2)); //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]这里用到了Sting下的match方法，稍后会说道。这里先看着RegExp下的一些方法方法：test()返回值： Boolean类型，true 或 false举例：1234var reg = /\\d+/; reg.test(&#123;a:123&#125;); //falsereg.test(123); //truereg.test('manfredhu'); //false不难看出，test方法用在一些测试环境下，比如检测某个字符串是否存在某个特定字符的时候如上栗子，要监测字符串是否具有数字，只有第二个符合。方法：exec()返回值：被匹配的值，返回一个数组，数组为匹配串下标整个串没有发现匹配，则返回null举例：123var reg = /\\d+/; reg.exec('d123'); //[\"123\", index: 1, input: \"d123\"] reg.exec('manfredhu'); //null参数g在exec()方法的工作原理没有g参数的exec()方法只会执行一次12345678var reg = /\\d+/; var str = 'd123d123d123';var result = reg.exec(str); console.log(result,reg);//[\"123\", index: 1, input: \"d123d123d123\"] /\\d+/result = reg.exec(str);console.log(result,reg);//[\"123\", index: 1, input: \"d123d123d123\"] /\\d+/而拥有g参数的exec()方法却是不一样的，工作原理如下找到第一个 “e”，并存储其位置如果再次运行 exec()，则从存储的位置开始检索，并找到下一个 “e”，并存储其位置12345678var reg = /\\d+/g; var str = 'd123d123d123';var result = reg.exec(str); console.log(result,reg);//[\"123\", index: 1, input: \"d123d123d123\"] /\\d+/result = reg.exec(str);console.log(result,reg);//[\"123\", index: 5, input: \"d123d123d123\"] /\\d+/这里加了g参数，第一次匹配返回匹配开头的下标1，第二次返回下标5.方法：compile()返回值： 无compile() 方法用于改变 RegExp。compile() 既可以改变检索模式，也可以添加或删除第二个参数。12345var patt1=new RegExp(\"e\");console.log(patt1.test(\"The best things in life are free\")); //truepatt1.compile(\"d\",\"g\");console.log(patt1); // /d/gconsole.log(patt1.test(\"The best things in life are free\")); //false正则表达式正则符号比较多，常用的如下:常用元字符符号含义[abc]查找方括号之间的任何字符[^abc]查找不属于abc的任何字符[A-z]查找任何从大写 A 到大写 z 的字符\\w查找单词字符。\\W查找非单词字符。\\d查找数字。\\D查找非数字字符。\\s查找空白字符。\\S查找非空白字符。\\b匹配单词边界。\\B匹配非单词边界。量词如字面意思，就是描述匹配的数量的。量词描述n+匹配任何包含至少一个 n 的字符串。n*匹配任何包含零个或多个 n 的字符串。n?匹配任何包含零个或一个 n 的字符串。n{X}匹配包含 X 个 n 的序列的字符串。n{X,Y}匹配包含 X 至 Y 个 n 的序列的字符串。n{X,}匹配包含至少 X 个 n 的序列的字符串。n$匹配任何结尾为 n 的字符串。^n匹配任何开头为 n 的字符串。?=n匹配任何其后紧接指定字符串 n 的字符串,但是不会出现在匹配结果的字符串里面?:n匹配任何其后紧接指定字符串 n 的字符串,并出现在匹配结果字符里面,不作为子匹配返回。?!n匹配任何其后没有紧接指定字符串 n 的字符串。这里的量词还是比较重要的，最后两个估计有的同学没见过。正向预查与负向预查?=n 正向预查在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， ‘Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。?!= 负向预查在任何不匹配的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始?=和?:的区别这两个预查都是正向的,区别是(?=)不会作为匹配校验,也不会被捕获而出现在匹配结果字符串里面.而(?:)会作为匹配校验,并被捕获出现在结果字符串里面,它跟(.)不同的地方在于,不被捕获作为子匹配返回.如果想要不捕获字符串的一些值的话,这两个都可以用.1234567var data = 'windows 98 is ok';console.log(data.match(/windows (?=\\d+)/))console.log(data.match(/windows (?:\\d+)/))console.log(data.match(/windows (\\d+)/))//[\"windows \", index: 0, input: \"windows 98 is ok\"]//[\"windows 98\", index: 0, input: \"windows 98 is ok\"]//[\"windows 98\", \"98\", index: 0, input: \"windows 98 is ok\"]RegExp下的一些属性属性描述globalRegExp 对象是否具有标志 g。ignoreCaseRegExp 对象是否具有标志 i。multilineRegExp 对象是否具有标志 m。lastIndex or index一个整数，标示开始下一次匹配的字符位置。source正则表达式的源文本。lastIndex属性该属性存放一个整数，它声明的是上一次匹配文本之后的第一个字符的位置。上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。提示和注释重要事项：不具有标志 g 和不表示全局模式的 RegExp 对象不能使用 lastIndex 属性。提示：如果在成功地匹配了某个字符串之后就开始检索另一个新的字符串，需要手动地把这个属性设置为 0。栗子翻上去看 2.2.1. 参数g在exec()方法的工作原理String对象下的一些正则方法方法：search(regexp)用途： 检索与正则表达式相匹配的值，可以对比String.indexOf(string,fromIndex)方法，但是不同的是这里可以传入一个正则表达式作为参数。参数： 接受一个正则表达式作为参数返回值：匹配首字母的下标没有匹配返回-1举例：123var str=\"Visit W3School!\"console.log(str.search(/W3School/)); //6console.log(str.search(/w3school/)); // -1方法：match(str|regexp)用途： 找到一个或多个正则表达式的匹配。参数： 接受一个字符串或者正则式作为参数。返回值： 返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。举例:12345var str = \"For more information, see Chapter 3.4.5.1\";var re = /(chapter \\d+(\\.\\d)*)/i;var found = str.match(re);console.log(found); //[\"Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 26, input: \"For more information, see Chapter 3.4.5.1\"]这个例子的返回值可以看看，返回的数组的第一个值为正则式的匹配串，第二个值开始为()捕获的捕获串，这里的正则有两对小括号，所以应该有2个捕获串，就是返回值数组的第二个和第三个。倒数第二个参数为第一个捕获串的首字母的下标。倒数第一个参数为整个字符串。带有g参数12var str = \"1 plus 2 equal 3\";console.log(str.match(/\\d+/g)); //[\"1\", \"2\", \"3\"]综合起来1234var str = \"For more information, see Chapter 3.4.5.1 chapter\";var re = /(chapter \\d+(\\.\\d)*)/ig;var found = str.match(re);console.log(found); //[\"Chapter 3.4.5.1\"]可以看到带有g参数的，返回值只有匹配串。方法：split(separator,howmany)用途： 把字符串分割为字符串数组，String.split() 执行的操作与 Array.join 执行的操作是相反的。参数：参数separator为必需，字符串或正则表达式，从该参数指定的地方分割string。参数howmany为可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。返回值： 分割后的字符串数组。举例:1234var str=\"How are you doing today?\";console.log(str.split(\" \")); //[\"How\", \"are\", \"you\", \"doing\", \"today?\"]console.log(str.split(\"\")); //[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]console.log(str.split(\" \",3)); //[\"How\", \"are\", \"you\"]方法：replace(regexp,func)用途： replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。参数：第一个参数为规定子字符串或要替换的模式的 RegExp 对象。第二个参数为一个字符串值。规定了替换文本或生成替换文本的函数。从参数组合来看有四种组合，下面举例四种情况。返回值： 处理后的字符串。举例:参数为字符串、字符串的替换功能12var str=\"Visit Microsoft!\";console.log(str.replace(\"Microsoft\", \"W3School\")); //Visit W3School!参数为正则表达式、字符串的更高级的替换功能12var str=\"Visit Microsoft!\";console.log(str.replace(/Microsoft/, \"W3School\")); //Visit W3School!参数为正则表达式、函数1234567var str = '&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;';str.replace(/\\&#123;(\\d+)\\&#125;/ig,function(a,b)&#123; console.log(arguments);&#125;);//[\"&#123;0&#125;\", \"0\", 12, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"]//[\"&#123;1&#125;\", \"1\", 17, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"]//[\"&#123;2&#125;\", \"2\", 30, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"]这里可以看出，接受函数作为第二个参数的时候，函数会收到的参数：第一个参数是正则表达式的匹配串第二个是正则表达式的捕获串，实际上，中间的参数具体有多少个取决于正则表达式中子表达式的个数倒数第二个参数是捕获到的部分的首字母在整个字符串中的位置索引，从0开始最后一个参数是调用replace()方法的字符串本身","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"}]},{"title":"MySQL使用及在Mac上的区别","slug":"24-how-to-use-mysql-on-mac","date":"2017-02-26T12:59:36.000Z","updated":"2017-04-05T13:44:00.000Z","comments":true,"path":"2017/02/26/24-how-to-use-mysql-on-mac/","link":"","permalink":"http://www.manfredhu.com/2017/02/26/24-how-to-use-mysql-on-mac/","excerpt":"","text":"MySQL用的比较多的，应该是学生时代，作为一款入门款的关系型数据库，还是挺好用的。首先是下载MySQL的安装包，然后安装，直接搜官网安装就好了。之前都是在windows上用的mysql，习惯之后换了电脑在Mac上面用遇到了不少坑。记录如下下载MySQLMac下载地址： 官网下载链接戳这里安装后进入MySQL命令模式下载dmg之后安装，安装完要进入MySQL，按照windows的使用习惯是这样的，问题就在于在windows的时候它有叫我设置用户名和密码，在Mac上没有。。。我试过了几个密码，123456，123,没有密码都提示错误。后面发现可能是root，不过懒得试了。搜了一下破解方法，最后成功破解。破解方法停止 mysql server. 通常是在 &#39;系统偏好设置&#39; &gt; MySQL &gt; &#39;Stop MySQL Server&#39;PS：可以在Alfred搜mysql直接调出来打开终端，输入：sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables打开另一个新终端，输入:sudo /usr/local/mysql/bin/mysql -u root 无密码进入修改密码：UPDATE mysql.user SET authentication_string=PASSWORD(&#39;新密码&#39;) WHERE User=&#39;root&#39;;同步修改到内存：FLUSH PRIVILEGES;终端下输入mysql -u root -p如果进入则成功安装NavicatNavicat这货是windows和mac上都有的数据库管理软件，用习惯之后你会发现比mysql自带的workbench还要爽，在windows用了过来已经改不了了，果断下一个，链接在这里Navicat登陆mysqlhostName: localhostport: 3306userName: rootpassword: 123456savePassword: YESencoding: utf-8习惯这个配置了哈哈哈","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"},{"name":"mysql","slug":"mysql","permalink":"http://www.manfredhu.com/tags/mysql/"}]},{"title":"React + Reflux 渲染性能优化原理","slug":"23-reactRenderingPrinciple","date":"2016-11-08T15:00:41.000Z","updated":"2017-04-05T13:44:04.000Z","comments":true,"path":"2016/11/08/23-reactRenderingPrinciple/","link":"","permalink":"http://www.manfredhu.com/2016/11/08/23-reactRenderingPrinciple/","excerpt":"","text":"ReactReact的优点有很多，现在很多应用都接入React这个框架。在我看来，有下列优点：Facebook团队研发并维护——有团队维护更新且有质量保证在MVVM结构下只起View的作用——简单接入，不需要花费大量人力重构代码组件化形式构建Web应用——复用性强，提高开发效率用Virtual DOM减少对DOM的频繁操作提高页面性能——批量操作减少重排（reflows）和重绘(repaints)次数——性能对比旧的方式有提高React对重排和重绘的提高雅虎性能优化比较重要的点，老司机自行忽略。如下图，HTML被浏览器解析为DOM树，CSS代码加载进来解析为样式结构体，两者关联组成渲染树，之后浏览器把渲染树绘制出来就是我们看到的网页了。这里如果我们对DOM树或者样式结构体做一些操作，如删除某个节点，样式改为隐藏（display:none）等等，会触发重排进而导致重绘。触发重排的条件DOM元素的数量属性变化DOM树的结构变化——节点的增减、移动某些布局属性的读取和设置触发重排——offsetTop/offsetWidth/scrollTop等等导致子级、后续兄弟元素、父节点因重新计算布局而重排触发重绘的条件简单样式属性的变化——颜色、背景色等重排导致的重绘而React维护了一个Virtual DOM将短时间的操作合并起来一起同步到DOM，所以这也是它对整个前端领域提出的最重要的改变。为什么引入Reflux？上面说了React在MVVM结构下只起View的作用，那么除了View，MVVM下还有Model，ViewModel。而纯粹的View，会让整个逻辑耦合在一层下，数据也需要层层传递，不方便控制和复用。故业内也有一堆的分层框架——如最早的flux，现在部门在用的Reflux，以及Redux。对比Redux，Reflux更容易理解和上手——这也是现状，学习成本越低，接入现有业务就越容易。Refluxreflux的架构非常简单，就是三部分Action 理解为一个命令或者动作，通过它来向组件发出”指令”Store 为ViewModel部分，组件的一些状态属性会存储在这里View Component 为组件模板所以Reflux只是让我们，更好的去操作组件，通过一个Action命令，叫组件去干嘛，组件自己通过写好的代码，对命令做出反应(变化为不同的state状态)。React+Reflux起到的作用现在你已经有了两个小工具了，写一个组件，通过Action调用组件就可以了。写到这里，你应该能体会到，所有的引入就是为了让代码写起来更有效率，更易用，复用性更强。Pure Component纯净的组件：在给定相同props和state的情况下会渲染出同样结果其优点有这么几点：我们写的组件都应该是只依赖props和state的，而不应该依赖其他全局变量或参数纯净的组件方便复用、测试和维护组件生命周期React组件有两部分第一部分是初始化的生命周期:getDefaultPropsgeInitialStatecomponentWillMountrendercomponentDidMount第二部分是被action触发，需要更新：shouldComponentUpdatecomponentWillUpdaterenderconponentDidUpdateshouldComponentUpdateshouldComponentUpdate这个方法可以说是一个预留的插入接口。在上面更新的时候，第一步就是调用的这个方法判断组件是否该被重新渲染。shouldComponentUpdate是在React组件更新的生命周期中，用于判断组件是否需要重新渲染的一个接口，它有两个返回值：返回true，则进入React的Virtual DOM比较过程返回false，则跳过Virtual DOM比较与渲染等过程如上图，这是一棵React Virtual DOM的树。C1在ShouldComponentUpdate返回了true，即默认值，代表需要更新，进入Virtual DOM Diff过程，返回false，不相同，需要更新C2在ShouldComponentUpdate返回了false,不再更新，C4,C5因为被父节点在ShouldComponentUpdate中返回了false，所以不再更新C3在ShouldComponentUpdate返回了true进入Virtual DOM Diff过程，比对结果为false，新旧不一样，需要更新轮到C6,ShouldComponentUpdate返回了true，进入Virtual DOM Diff的过程，返回了false，即新旧两个节点不相同，所以这个节点需要更新C7在ShouldComponentUpdate返回了false，即不需要更新，节点不变C8在ShouldComponentUpdate返回了true,进入Virtual DOM Diff比对过程，结果为true，新旧相等，不更新大概就是这么一个过程，在这里，Diff算法其实还是比较复杂的，比较好的做法是我们来写入ShouldComponentUpdate来自己控制组件的更新，而不是依赖React帮我们做比较。进入正文前面讲了那么多，相信懂React的都懂了，就不再详细讲了，Diff算法有兴趣的可以自己去翻源码，网上也有一堆模拟实现的例子。接下来介绍一个探索reflux&amp;react渲染优化的例子。这里试图，模拟一个比较现实的例子，抛开很多业务代码，让问题变得直接。首先例子有三个组件，两个按钮，5个数字，还有一个重复打印文本的大组件。1basicDemo 是没有优化的例子，每50ms会发出action更改store数据触发渲染2perfDemo 使用addons插件Perf分析页面性能的例子3pureRenderMixinDemo 使用addons插件pureRenderMixin优化页面性能的例子4updateDemo 使用了addons插件update优化页面性能的例子5immutableDemo 使用了Immutable.js优化页面性能的例子源码传送门说明gulpfile.js为gulp构建代码，会将tpl.js的JSX代码翻译为js代码，需要的可以自己修改，每次转化模板需要gulp运行一下modulejs模块加载器和myView单页SPA框架为腾讯通讯与彩票业务部前端团队这边的基本框架，具体的请戳这里查看需要关注的文件index.html 页面入口，规定了执行的模块app.js 应用程序入口todoAction.js (reflux架构下，demo的action)todoStore.js (reflux架构下，demo的store)tpl.js 组件的jsx文件简单用法cd ./xxx/(这里的xxx为上面对应的 ……./4updateDemo/ 目录)http-server -p 8888端口可以自定义，http-server模块已在node_module目录下，担心版本依赖问题，已上传node_module目录，直接打开就可以了打开浏览器便可浏览，详情请看控制台basicDemo1basicDemo目录是一个最原始的目录，这里你可以看到我们哪里出现了问题。cd ./example 打开这个没优化过的例子的目录http-server -p xxxx 这里端口随意，不冲突就好浏览器访问并打开控制台，会看到1235 tpl.js:32 createNum组件被更新了 tpl.js:10 TextComponent被更新了2 tpl.js:57 createBtn组件被更新了初始化createNum组件被渲染了5次，因为有5个，createBtn组件被渲染了两次，因为有点击开始和点击结束两个按钮。通过不同的传参而改变形态。点击开始会触发action，让store的数据每次+1，点击结束会清除定时器点击开始可以看到控制台的数据每次都会刷新整个界面的所有组件，特别是有一个大组件TextComponent，是重复5000次文本的，每次重新渲染就有很多的损耗。这就是我们要优化的地方——减少某些关键部分的重新渲染的次数，减少无用对比的消耗这里你可以打开Chrome控制台的Timeline来看一下，点击开始，打开Timeline面板，每1S左右会有一个脚本执行的高峰期。我们知道特别是在移动端，CPU和内存的资源显得尤为稀缺（大概只能占用正常CPU和内存的10%，微信手Q等可能会因为友商系统对应用程序的优先级设计使这个限制略有提高——我说的就是小米哈哈哈），所以这样说来，性能这一块在移动手机web显得非常非常重要。PerlPerl是react-addons带来的性能分析工具，这里的perfDemo是结合Chrome插件的例子。要向全局暴露一个window.Perl变量，然后就可以愉快的配合Chrome插件使用了React-addons插件版本的Perf插件提供原生的API——用在首次渲染部分Chrome插件——用在有交互的部分console tool——需要查看对比新旧值的情况下这里的wasted time就是在做属性没变化的重复渲染的过程，可以优化。用法与Chrome开发工具的TimeLine用法类似，点击start开始记录，后点击stop结束PureRenderMixin一个简单的通用优化工具，通过浅对比(shallowCompare)方法对比新旧两个组件的状态，达到减少重复渲染的目的。注意这里组件的store必须无关联，原因是shallowCompare的时候，比较的是组件关联的store的数据，而例子里面store是一个，其他组件num的变化也会引起这里TextComponent组件的更新这里将store与顶级组件APP关联起来，然后在子孙组件下自定采用props传递的方式处理(传递基本类型的数据)，这样就可以让pureRenderMixin的通用化了，唯一的缺点是，传递props要控制，只把组件需要的属性传递下去，这里会比较麻烦，但是这样又是性能较高又比较好理解的处理方式(相对其他要拷贝属性的方式)*store下，option里面的对象，受pureRenderMixin的限制，不可以出现引用类型PureRenderMixin其实是封装了更底层的shallowCompare接口的简单用法如下:1234567var PureRenderMixin = require('react').addons.PureRenderMixin;React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;);就加了一个mixins，看起来简单优雅有木有。可以在众多组件里面copy通用啊有木有那这里干了什么？1234React.addons = &#123; CSSTransitionGroup: ReactCSSTransitionGroup, LinkedStateMixin: LinkedStateMixin, PureRenderMixin: ReactComponentWithPureRenderMixin, //看这里123456var ReactComponentWithPureRenderMixin = &#123; //帮你写了一个shouldComponentUpdate方法 shouldComponentUpdate: function (nextProps, nextState) &#123; return shallowCompare(this, nextProps, nextState); &#125;&#125;;1234function shallowCompare(instance, nextProps, nextState) &#123; //分别比较props和state属性是否相等 return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);&#125;1234567891011121314151617181920212223242526function shallowEqual(objA, objB) &#123; if (objA === objB) &#123; //store嵌套层级太深这里就会返回true，引用类型内存指向同一空间 return true; &#125; if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) &#123; return false; &#125; var keysA = Object.keys(objA); var keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; return false; &#125; // Test for A's keys different from B. var bHasOwnProperty = hasOwnProperty.bind(objB); for (var i = 0; i &lt; keysA.length; i++) &#123; if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) &#123; return false; &#125; &#125; return true;&#125;所以PureRenderMixin这个插件，只能比较state和props为基本类型的部分。如果有更加深层次的store数据嵌套，就要借助于update插件或者Immutablejs来深拷贝store的数据另存一份了。用update优化（也称Immutable Helper）update是addons里面的一个方法，旨在对拷贝对象复杂的过程来做一些语法上的优化，具体可以看react官方文档1234567//extend复制对象属性的时候var newData = extend(myData, &#123; x: extend(myData.x, &#123; y: extend(myData.x.y, &#123;z: 7&#125;), &#125;), a: extend(myData.a, &#123;b: myData.a.b.concat(9)&#125;)&#125;);123456//用update的时候，提供了一些语法糖让你不用写那么多var update = require('react-addons-update');var newData = update(myData, &#123; x: &#123;y: &#123;z: &#123;$set: 7&#125;&#125;&#125;, a: &#123;b: &#123;$push: [9]&#125;&#125;&#125;);cd ./updateDemo 打开这个用addons.update优化过的例子的目录http-server -p xxxx 这里端口随意，不冲突就好这个例子与上面一个例子唯一的不同是这里用了addons.update来进行store数据的复制，具体的可以看todoStore和tpl这两个模块的代码，其他基本无修改这里update是参考了MongoDB’s query的部分语法，具体的可以看这里,类比数组方法，返回一个新的实例。{$push: array} 类似数组的push方法{$unshift: array} 类似数组的unshift方法{$splice: array of arrays} 类似数组的splice方法{$set: any} 整个替换目标{$merge: object} 合并目标和object的 keys.{$apply: function} 传递当前的值给 function 并用返回值更新它但是由Timeline的观察来看，复制对象属性的性能远比刷新一个大组件的性能高。ImmutablejsImmutable.js是Facebook为解决数据持久化而独立出来的一个库，传统的，比如我们有123456var a = &#123;b:1&#125;;function test(obj)&#123; obj.b = 10; return obj;&#125;test(a); //10函数对对象的操作，你不会知道这个函数对对象进行了什么操作。也就是说是封闭的。而Immutable每次对对象的操作都会返回一个新对象Immutable.js提供了7种不可变的数据类型:List Map Stack OrderedMap Set OrderedSet Record,对Immutable对象的操作均会返回新的对象，例如:123456var obj = &#123;count: 1&#125;;var map = Immutable.fromJS(obj);var map2 = map.set('count', 2);console.log(map.get('count')); // 1console.log(map2.get('count')); // 2引入Immutable.js，需要对现有的业务代码进行改动，通常是对tpl和store两部分进行操作，初始化数据的时候生成一个Immutable的数据类型，之后每次get,set操作都会返回一个共享的新的对象。50ms渲染一次，重复渲染200次的截图，引入了immutable用了其set方法：50ms渲染一次，重复渲染200次的截图，引入了immutable用了其update方法：seamless-immutable &amp;&amp; Observejs一个是immutable的阉割版，一个是AlloyTeam推的。两者都是通过Object.defineProperty(IE9+)对set和get操作进行处理，优点是文件比较小。写在最后自己设想，组件化运用到极致，应该是像微信weui那样有一套非常适合接入，复用性非常强的组件库。拿来就用，不需要再次开发应该兼顾起上面说的减少重复渲染的部分开发友好这里也思考一些可能做到的变化：将一个组件的action/store/JSX/样式代码Style 写在一个文件里，这样方便修改和调用，封闭组件内部实现细节，对外只暴露action操作和store的一些get方法，这样可以修改或者是获取到组件的某些现在时刻的属性（也有同学是直接封装为一个对象，通过对象暴露其store,action）组件共享或依赖的数据，应在公共父级的store或独立成一个单独的部分，然后采用props传递的形式或从独立的store里面取数据License源码传送门MIT. Copyright (c) 2016 ManfredHu.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"},{"name":"React","slug":"React","permalink":"http://www.manfredhu.com/tags/React/"}]},{"title":"classNames模块","slug":"21-classNames","date":"2016-07-12T15:18:35.000Z","updated":"2017-04-05T13:44:14.000Z","comments":true,"path":"2016/07/12/21-classNames/","link":"","permalink":"http://www.manfredhu.com/2016/07/12/21-classNames/","excerpt":"","text":"classNames今天分享一个好玩的东西，它叫 classNames ,这个是一个翻译的版本，原版链接在这里它是一个小工具。我是在React项目里面用到它的。一用就停不下来了它是什么？它是一个简单的对类名进行条件判断并且拼装的小工具。通过条件判断把对应的class串接起来，可以更清晰的展示组件的状态对应的css.总的来说，就是让你的代码可读性更高它用在哪里？React官方推荐用它，当然，既然是小工具，那么肯定扩展性是非常强的。不仅仅是React!!不仅仅是React!!不仅仅是React!!重要的事情我们说三遍为什么要用它？项目CSS代码的规范遵循的是BEM，所以我们有很多的类名是有状态定义的，比如 .sidebar__item--active 。你应该可以一眼看出来，这是一个侧边导航栏的激活状态，在选中的时候显示。但是通常还有一个默认状态 .sidebar__item ，那么这个时候，你通常会加多一个判断语句，因为你需要判断是不是激活的。12345678910var SideBar = React.createClass(&#123; // ... render () &#123; var sideBarClass = 'sidebar__item'; if (this.state.isActive) &#123; sideBarClass += '--active'; &#125; return &lt;div className=&#123;sideBarClass&#125;&gt;&#123;this.props.text&#125;&lt;/div&gt;; &#125;&#125;);那么假设你还有一个自定义颜色的 .sidebar__item-orange 类。那你的代码会多一个 if 判断.12345678910111213var SideBar = React.createClass(&#123; // ... render () &#123; var sideBarClass = 'sidebar__item'; if (this.state.isActive) &#123; sideBarClass += '--active'; &#125; if (this.props.color) &#123; sideBarClass += '' + this.props.color; //'+'优先于'+=' &#125; return &lt;div className=&#123;sideBarClass&#125;&gt;&#123;this.props.text&#125;&lt;/div&gt;; &#125;&#125;);假如……好了没那么多假如了，你的类名有多长，你的 if 就会有多长。所以作为一个有追求的前端，不能忍!!怎么用？还是上面的例子123456789101112131415var cl = require('classnames');var SideBar = React.createClass(&#123; // ... render () &#123; var sideBarClass = cl(&#123; 'sidebar__item': true, '--active': this.state.isActive, [this.props.color] :this.props.color, //这里用的是ES6的语法，可以用JSX编译工具如babel转换出来 .... .... .... &#125;); return &lt;div className=&#123;sideBarClass&#125;&gt;&#123;this.props.text&#125;&lt;/div&gt;; &#125;&#125;);有多少可以来多少，不怂好吗。引用了一个模块，我们的代码就优雅了好多了，可能你还会担心，这模块大不大啊，引入的话会不会得不偿失啊。我们看一下源代码吧。123456789101112131415161718192021222324252627282930313233343536373839(function () &#123; var hasOwn = &#123;&#125;.hasOwnProperty; function classNames () &#123; var classes = []; for (var i = 0; i &lt; arguments.length; i++) &#123; var arg = arguments[i]; if (!arg) continue; var argType = typeof arg; if (argType === 'string' || argType === 'number') &#123; classes.push(arg); &#125; else if (Array.isArray(arg)) &#123; classes.push(classNames.apply(null, arg)); &#125; else if (argType === 'object') &#123; for (var key in arg) &#123; if (hasOwn.call(arg, key) &amp;&amp; arg[key]) &#123; classes.push(key); &#125; &#125; &#125; &#125; return classes.join(' '); &#125; //CommonJS规范 if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports = classNames; //AMD规范 &#125; else if (typeof define === 'function' &amp;&amp; typeof define.amd === 'object' &amp;&amp; define.amd) &#123; // register as 'classnames', consistent with npm package name define('classnames', [], function () &#123; return classNames; &#125;); //其他 &#125; else &#123; window.classNames = classNames; &#125;&#125;());代码真心短得可怜，而且还可以再DIY,最后三个if，其实你可以选择你项目用的规范来引入。默认支持 CommonJS规范/AMD规范/全局定义 三种。我们再观察一下原理部分，看有没有什么bug。知己知彼才能放心插入嘛一个内部数组classes，然后对参数进行判断后将参数添加到内部数组里参数类型判断条件string或者number类型直接push到数组Array类型则递归这个数组Object类型则把键为true的加入数组最后join了数组返回一个字符串。代码很简单，但是创意无限。非常推荐大家用这个模块。有问题可以留言哈。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"}]},{"title":"Interesting JavaScript","slug":"20-interestingJavascript","date":"2016-07-07T14:43:02.000Z","updated":"2017-04-05T13:44:21.000Z","comments":true,"path":"2016/07/07/20-interestingJavascript/","link":"","permalink":"http://www.manfredhu.com/2016/07/07/20-interestingJavascript/","excerpt":"","text":"声明提升写出下面代码的运行结果12345678910var a,b;(function()&#123; console.log(a); console.log(b); var a=b=3; console.log(a); console.log(b);&#125;)();console.log(a);console.log(b);A. undefined,undefined,3,3,undefined,3B. undefined,undefined,3,3,undefined,undefinedC. 0,0,3,3,undefined,undefinedD. undefined,undefined,3,3,0,0正确答案：A解释：代码相当于下面这样的过程123456789101112var a,b;(function()&#123; var a; console.log(a); //undefined console.log(b); //undefined a=3; b=3; console.log(a); //3 console.log(b); //3&#125;)();console.log(a); //undefinedconsole.log(b); //3变量定义规则下面符合一个有效的javascript变量定义规则的是？A. _$te$t2B. withC. a bcD. 2a正确答案： A考点：ECMAScript语法解析：with为关键字，空格不行，数字开头的不行document.getElementById和document.getElementsByTagNameJavaScript中document.getElementById的返回值的类型和document.getElementsByTagName的返回值类型分别是？A. Array,NodeListB. Object, HTMLCollectionC. String,NodeListD. Function,NodeList正确答案： B解析：这题可能有争议，浏览器测试代码如下1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Id与TagName类型检测&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"test\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function checkType(element)&#123; console.log(Object.prototype.toString.call(element)); &#125; checkType(document.getElementById('test')); //[object HTMLDivElement] checkType(document.getElementsByTagName('div')); //[object HTMLCollection] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;if/var下面关于块内函数的做法哪些是正确的？A. if(x){ function foo(){}}B. if(x){ var function foo(){}}C. if(x){ foo = function(){}}D. ECMAScript明确的规范了块级函数，JavaScript实现了这个规范正确答案：B解析：测试报错hasOwnProperty下列代码123var obj=&#123;&#125;……obj.hasOwnProperty(\"val\");中hasOwnProperty的作用是？A. 判断obj对象是否具有val的属性B. 判断obj对象是否具有val的值C. 判断obj的原型对象是否具有val的属性D. 判断obj的原型对象是否具有val的值正确答案：A解析：hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回falsecall和apply下面有关JavaScript中 call和apply的描述，错误的是？A. call和apply都属于Function.prototype的方法，所以每个function实例都有call，apply属性B. 两者传递的参数不一样，call函数第一个参数都是传入给当前对象的对象，apply不是C. apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入D. call传入的则是直接的参数列表。call方法可将一个函数的对象上下问从出事的上下文改变为thisObj指定的新对象。正确答案：B解析:apply和call都是改变函数内部this指向的方法，挂载在Function.prototype下script标签（不定项选择题）给网页添加javascript的方式有1234A. 使用script标签，将JavaScript代码写到&lt;script&gt;&lt;/script&gt;之间B. 添加外部javascript文件C. 使用行内javascriptD. 使用@import引入javascript文件正确答案：A，B，C解析：只有CSS可以用@import方法，题目其实可以换成CSS，则全部正确12345给网页添加css的方式有A. 使用style标签，将JavaScript代码写到&lt;style&gt;&lt;/style&gt;之间B. 添加外部css文件C. 使用行内cssD. 使用@import引入css文件parseInt与map[“1”, “2”, “3”].map(parseInt)的输出结果是A. [1,NaN,NaN]B. [1,2,3]C. [NaN,NaN,NaN]D. 发生错误正确答案： A. [1,NaN,NaN]解析：Array.prototype.map(func(currentValue, index, arrary),thisObj)map接受两个参数, 一个回调函数 callback, 一个回调函数的this值。其中回调函数接受三个参数 currentValue, index, arraryparseInt 只接受两个两个参数 string, radix(基数).基数。该值介于 2 ~ 36 之间,如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。如果为0，则直接输出字符串如下的例子来看this的运用和基数的例子：1234567891011var obj = &#123; value:1&#125;;[\"1\", \"2\", \"3\"].map(function(currentValue, index, arrary)&#123; console.log(this); //输出3次obj&#125;,obj);console.log(parseInt('1', 0)); //1console.log(parseInt('123', 0)); //123console.log(parseInt('2', 1)); //NaNconsole.log(parseInt('3', 2)); //NaN当[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)的时候，传入parseInt的参数为currentValue,indexFunction.prototype.name1234function foo() &#123; &#125;var oldName = foo.name;foo.name = &quot;bar&quot;;console.log([oldName, foo.name]);A. [‘foo’,’bar’]B. [‘foo’,’foo’]C. [‘bar’,’bar’]D. [‘bar’,’foo’]答案：B.[‘foo’,’foo’];函数的name属性指向函数名，挂载在Function.prototype下，所以不要给函数赋值属性name哈。并且这个属性是不可改变的.所以下面这样的例子就不要出现了12function foo() &#123;&#125;foo.name = \"bar\"; //bad,你居然真忘了Function.prototype.name是一个不可修改的属性！！测试代码：1console.log(Function.prototype.hasOwnProperty('name')); //true正则test方法的参数问题12var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()]A. false, trueB. false,trueC. true,trueD. true,false答案: C.true, true如题所示，test方法如果参数为null或者不屑，则默认返回true变量作用域写出这段代码的运行结果123456789&lt;SCRIPT type=\"text/javascript\"&gt; var bb = 1; function aa(bb) &#123; bb = 2; console.log(bb); &#125;; aa(bb); console.log(bb);&lt;/SCRIPT&gt;正确答案： 2 1+-操作符如下代码输出的结果是什么：1234console.log(1+ \"2\"+\"2\");console.log(1+ +\"2\"+\"2\");console.log(\"A\"- \"B\"+\"2\");console.log(\"A\"- \"B\"+2);正确答案：122 //数字与字符串+则数字默认转换为字符串32 //+号会将字符串2先转化为数字，这种也是常用的将字符串转换为数字的方式NaN 2NaN解析：插播——常见的将字符串转换为数字的方法：parseInt,具体使用请看前面第8题+&quot;123&quot; 类似这种写法，比如某个参数不确定是不是数字可以这样 +data.lenNumber方法从带宽（精简压缩后）考虑会用第二种，所以通常会在代码上大量看到这种写法null和Object的关系[typeof null, null instanceof Object]的输出结果是正确答案：object, false解析：null为一个空的对象，这个对象存在但是里面一点东西都没有，相当于有堆空间但是里面没有属性。而undefined可以理解为连堆空间都没有（至少表现出来是这样的不是吗？）null instanceof Object为false是因为null连属性都没有，更没有检测原型链的_proto_和prototype了。+运算符优先于?:运算符var val = ‘smtg’;console.log(‘Value is ‘ + (val === ‘smtg’) ? ‘Something’ : ‘Nothing’);正确答案： ‘Something’变量作用域12345678910写出下面代码的执行效果var name = &apos;World!&apos;;(function () &#123; if (typeof name === &apos;undefined&apos;) &#123; var name = &apos;Jack&apos;; console.log(&apos;Goodbye &apos; + name); &#125; else &#123; console.log(&apos;Hello &apos; + name); &#125;&#125;)();正确答案： Goodbye Jack编译语法分析后代码（声明提升）如下12345678910var name = 'World!';(function () &#123; var name; if (typeof name === 'undefined') &#123; name = 'Jack'; console.log('Goodbye ' + name); //Goodbye Jack &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)();##写出下面题的答案1234567var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count);正确答案：不会输出，因为END是最大值了，解析：在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停浮点数的不准确性输出0.1+0.2 === 0.3的结果，并简单地解释。解析：经典的题目，浮点数因为存在误差，所以不能用===判定，通常在金额处理的时候会乘以10/100倍来小数部分的数据正则表达式replace的高级用法写出答案1\"1 2 3\".replace(/\\d/g, parseInt)答案：1, NaN, 3解析：replace() 方法的参数第二个参数可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。1.该函数的第一个参数是匹配模式的字符串2.接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数3.接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置4.最后一个参数是 stringObject 本身。题目中因为没有子表达式匹配，即()括起来的匹配项，所以传入parseInt的参数三次分别为：123parseInt(&quot;1&quot;, 0) //1，因为当基数为0时候直接输出第一个参数parseInt(&quot;2&quot;,2) //NaN，因为2进制只有01两个数字parseInt(&quot;3&quot;,4) //3，因为不超过四进制的最大值4getPrototypeOf根据proto获取类型123function f() &#123;&#125;var a = f.prototype, b = Object.getPrototypeOf(f);console.log(a === b);答案：false解析如下：1234567function f() &#123;&#125;var a = f.prototype; //Objectvar c = new f();var b = Object.getPrototypeOf(f); //functionvar d = Object.getPrototypeOf(c); //Obejctconsole.log(a === b); //falseconsole.log(d === a); //true函数的原型是一个对象，而函数的原型会是函数，对象的原型会是对象题目这里就是让你混淆普通函数的原型到底是什么？函数还是对象？答案是函数，因为普通函数的_proto_指向的是Function.prototype，所以Object.getPrototypeOf拿到的是function你可以狠狠戳这里去看我以前写的15条规则解析JavaScript对象布局这里应该可以看的很清楚了，函数Foo的prototype是Foo.prototype而Object.getPrototypeOf拿的是_proto_指向的Function.prototype,所以输出的是一个function。而普通对象，如图的o1,o2，_proto_指向的是Object.prototype[,]和join1[,,,].join(\", \")答案: “, , “解析：12[,,,].lenth //3[,,,].join('-') //--所以这题很明显了，三个逗号默认忽略最后一个，然后用’-‘会在两项中间添加连接符Function.length和new Function.length123var a = Function.length, b = new Function(1,'2234').length;console.log(a === b);答案 false解析：a为1，b为0，不相等Math.min()和Math.max()在没有参数时候的奇葩情况12var min = Math.min(), max = Math.max()min &lt; max答案；false解析：min为Infinity，b为-Infinity，结果是min &gt; maxmin() 方法可返回指定的数字中带有最低值的数字。Math.min(x,y) 如果没有参数，则返回 Infinity。如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。max() 方法可返回两个指定的数中带有较大的值的那个数。Math.max(x…) 如果没有参数，则返回 -Infinity。如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。闭包123456789function aa() &#123; console.log(\"aaa\"); return function()&#123; console.log(\"bbb\"); &#125;;&#125;console.log(aa);console.log(aa());console.log(aa()());答案：123456789function aa() &#123; console.log(\"aaa\"); return function()&#123;console.log(\"bbb\");&#125;;&#125;aaafunction()&#123;console.log(\"bbb\");&#125;;aaabbbundefined第一个输出aa的函数体，大家都懂第二个执行了aa()，输出文本&quot;aaa&quot;，同时返回了里面的匿名函数第三个在第二步的基础上执行了匿名函数，最后再输出一个bbb，最后因为执行函数没有返回值，返回了undefined类数组（array like)类数组对象是什么？说一下你知道的JavaScript里面类数组对象有哪些，类数组怎么转化为数组？类数组: 指向对象元素的数字索引下标以及 length 属性告诉我们对象的元素个数,但是不具有诸如 push 、 forEach 以及 indexOf 等数组对象具有的方法常见例子: DOM方法 document.getElementsByClassName() 的返回结果（实际上许多DOM方法的返回值都是类数组）以及特殊变量 arguments所以通常要有一个转换的过程，借助 Array.prototype.slice 可以实现:1Array.prototype.slice.call(arguments) //arguments转化为普通数组构造函数与静态方法写出下面代码输出的结果并写出你的解题思路？1234567891011121314151617function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;Foo.getName = function () &#123; console.log (2);&#125;;Foo.prototype.getName = function () &#123; console.log (3);&#125;;var getName = function () &#123; console.log (4);&#125;;function getName() &#123; console.log (5);&#125; //请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName();答案：1234567Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2new Foo().getName();//3new new Foo().getName();//3典型闭包下面代码的运行结果是？1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;DOM进阶&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; var buttons=document.getElementsByName(&apos;button1&apos;); for(var i=0;i&lt;buttons.length;i++)&#123; buttons[i].onclick=function()&#123; console.log(i); &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body &gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮1&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮2&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮3&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮4&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮5&quot; /&gt;&lt;/body&gt;&lt;/html&gt;这个错新手估计会犯，当初的我也是。闭包，点那个按钮都是输出 buttons.length 的值，这里是5","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"对象深复制","slug":"19-extendMethod","date":"2016-06-14T14:59:03.000Z","updated":"2017-12-10T10:52:06.000Z","comments":true,"path":"2016/06/14/19-extendMethod/","link":"","permalink":"http://www.manfredhu.com/2016/06/14/19-extendMethod/","excerpt":"","text":"对象引用这里主要举例jQuery的$.extend方法，首先是对象的深复制的背景：对象和数组是引用的，所以如果你用12345var arr = [1,2,3,4,5];var arr2 = arr;arr2.push(6);console.log(arr); //[1, 2, 3, 4, 5, 6]console.log(arr2); //[1, 2, 3, 4, 5, 6]但是有时候这不是我们要的结果，我们要将arr缓存起来，在某个时候重新还原arr为原来的值。这个时候就坑爹了，要复制整个对象或者数组。这个时候深复制就来了。如果你不用jQuery的，你要自己写的话，还真的挺麻烦的。jQuery的$.extend方法的几种调用方法$.extend(object1)直接扩展jQuery$.extend(target [,object1] [,object2])复制不递归$.extend([deep], target, object1 [,objectN])递归复制这里的deep是一个Boolean的值$.extend(object1/function)直接扩展jQuery1234567891011121314var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;; // Merge object2 into object1$.extend( object1); // Assuming JSON.stringify - not available in IE&lt;8console.log($.apple) //0console.log($.banana) //Object &#123;weight: 52, price: 100&#125;console.log($.fn.cherry) //undefinedconsole.log($.banana === object1.banana); //true把对象的属性copy到$下了，这里的$可能是Zepto或者jQuery，一样的。默认不会递归复制，这里可以看到banana还是复制的引用。$.extend这种写法jquery自己也用的很多，可以看到其实代码的后面一堆的$.extend或者是$.fn.extend这种写法，包括插件也用的很多。$.extend(target [,object1] [,object2])复制不递归12345678910111213141516171819var object1 = &#123; apple: [0], banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100, egg: [1,2,3,4]&#125;;// Merge object2 into object1$.extend( object1, object2 );console.log(JSON.stringify( object1 )); //&#123;\"apple\":[0],\"banana\":&#123;\"price\":200&#125;,\"cherry\":97,\"durian\":100,\"egg\":[1,2,3,4]&#125;console.log(object1.egg === object2.egg); //true这里将object2的属性合并到了object1中，object2和object1共有的属性会直接覆盖object1的属性，没有的会合并到object1里面。没有递归深层的属性，就是简单的复制属性而已。$.extend([deep], target, object1 [,objectN])递归复制12345678910111213141516171819var object1 = &#123; apple: [0], banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100, egg: [1,2,3,4]&#125;;// Merge object2 into object1$.extend(true, object1, object2 );console.log(JSON.stringify( object1 )); //&#123;\"apple\":[0],\"banana\":&#123;\"weight\":52,\"price\":200&#125;,\"cherry\":97,\"durian\":100,\"egg\":[1,2,3,4]&#125;console.log(object1.egg === object2.egg); //false这里传入了一个true的参数开启递归深复制，object1和object2的属性不会直接拿个引用过去，而是检查不同的地方，将相同的地方覆盖，没有的地方复制，引用的对象数组也被拷贝了一份过去，而不是拷贝引用而已。没有源码你说啥呢？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 对$.fn.extend添加方法，之后将引用赋给$.extendjQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, //target是最后返回的对象，如果没有就创建一个对象 i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; deep = target; // skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target) ) &#123; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;对象的属性复制是分开的，boolean,number,string这三个和object,array处理是不一样的。Object.assign这个方法会拷贝源对象自身可枚举的方法到目标对象.类似extend,这个方法可以扩展对象属性.并返回扩展后的对象123var obj = &#123;a: 1&#125;;var copy = Object.assign(&#123;&#125;,obj,&#123;b:123&#125;);console.log(copy); //&#123;a:1,b:123&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"关于实习的一些看法","slug":"18-internship","date":"2016-06-14T14:41:30.000Z","updated":"2017-04-05T13:45:05.000Z","comments":true,"path":"2016/06/14/18-internship/","link":"","permalink":"http://www.manfredhu.com/2016/06/14/18-internship/","excerpt":"","text":"这是一篇自己在腾讯实习一个半月的总结，仅供参考，非喜勿喷。实习是干嘛的？实习就是公司让你适应从学校到职业生涯的转换的一个试练，你能转变过来才有资格留下来继续走下去。实习累不累？说实话，新人都会觉得比较累，因为有太多不懂的东西，有太多的东西要学，有很多以前素不相识的人要认识。所以一句话：实习累，但是是一个痛并快乐的过程，因为你可以看着自己每天在成长。你学到了什么？没来到腾讯之前在学校，完全不会知道别的公司是如何开发的。或许你会自己YY一遍，但是真正来了之后才发现，实习招聘的要求是多么基本，比如面试官会问你看过XX框架的源码没有？其实潜台词是我们这里的代码没有注释或者基本没有注释，如果你看不懂就就GG了。又比如面试官问你写CSS和JS你喜欢哪一个，潜台词是：我们这里分为重构和前端，对应不同的工作，你更喜欢从事哪一个工作？现在看来，面试的一切问题都不是无的放矢，都有背后的潜台词存在。面试很难吗？难，因为你需要的不只是平常的积累和实力，还有很多运气成分。你遇到了什么面试官，面试官对你的评价，直接决定了你能不能来到公司，以及来到公司是做什么的。实习生很多，评价不一样，从事的工作也不一样，有人简单有人难，有人苦逼有人悠闲。这些你控制不了，所以看见别人悠闲的时候，可以想一想是不是你面试的时候表现太好了。面试官对你评价太高了。当然，问题不外乎老生常谈的那些面经上面的问题，但是那是一个坎，过了就过了，没过的加紧学习就好，工作之后会遇到，但是没那么多时间让你去学，所以要你提前储备知识。关于霸面有人很害怕霸面，有人又觉得霸面不好。其实看人，如果你真的很想要这份offer，厚下脸皮也没什么。当然，霸面只支持小部分人，人太多秩序会乱HR就不愿意了，这是属于工作失职。但是换句话说：如果你连你的面试官都害怕，那以后如果你的隔壁坐着的如果是总监你要怎么面对？所以能霸面的孩子起码这一关是过了，不会胆怯。关于前端和后台的划分近年来前端很热门大家都知道，但是为什么热门？因为出了node，后台能干的前端也能干，但是node对比C++的性能，还是C++比较好，虽然node也可以嵌入C++的代码执行，但是那样前端又要学C++成本就太高了，基本不可能实现。但是少部分的运用还是可以的，比如node直接调用后台底层接口，那样业务逻辑就在node里面了，前端可以直接控制服务器数据的发送，这样前端相对来说自由度就高了点了，相当于网络传输这部分全部划归前端来做（有的业务随时有需要更换后台接口的，接入node这一层之后灵活很多）node会越来越像java，随着ES6的出现与普及，ES6的语法糖会用的越来越多，而这语法糖跟java基本上一样，所以学了java的你，有了ES6写node会如鱼得水前端要不要学设计？广义上前端有三门语言是必学的HTML和CSS和JavaScript，但是术业专攻要求下HTML和CSS会在一起，JavaScript和各种框架又会在一起。所以有重构和前端开发两种要求，作为一名新手，建议是两种都要学，还有余力可以提高一下设计感。优先级可以这么来分：前端-&gt;后台-&gt;设计/产品/运营(这些在人少的时候应该有接触)后台应该干什么？写页面吗？错了，现在的后台应该只关注逻辑，关注点在你应该给客户端（各种终端）提供什么样的数据上，如何优化服务器，增加并发，代码架构是否能适应多业务的需求，增删查改的操作能不能做成公共模块直接传入参数搞定。而不是写一个又一个简单的小页面让前端去加样式。有一种趋势是APP嵌入浏览器，然后放的是页面。现在很火的，QQ/微信/Facebook的手机应用，统一都在转换这种方法，而不是用原生的安卓和iOS。所以你会听到ReactNative等等词汇的出现，这种方法也是未来的趋势，道理很简单——减少开发的成本。node也属于后台的范畴，道理与C++相通，后台的同学可以研究下。前端很牛掰的样子，我去学前端把？任何企业要求的岗位都有其存在的价值，相信存在即合理，认清楚自己的兴趣在哪里，并坚持走下去。不要过度追求潮流和未来的薪水，你会追不上时代的变化的。有句挺有道理的话：你干这事的时候觉得累，那是职业;你干这事的时候不觉得累，那是事业。实习没进入BAT怎么办？种瓜得瓜，种豆得豆，你现在的处境是你以前造成的，你的未来是你现在造成的。相信自己是金子总会发光，不用妄自菲薄一定要进BAT。适合自己的才是最好的，BAT的工作压力也很大，不一定适合现在的你，在小公司有小公司的悠闲自在。在学校和在公司的区别是什么？压力，在公司你要担心KPI，留用，HC名额等等。在学校你可以偷懒去外面玩几天，在公司没有这种机会的孩纸。你的导师和leader会是你的面试官吗？不一定，正常来说你一面的面试官会是你的leader，二面会是总监。但是这是不一定的，有的业务很缺人你也会被调过去用的。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"杂文","slug":"杂文","permalink":"http://www.manfredhu.com/tags/杂文/"}]},{"title":"event.target的亲兄弟event.currentTarget","slug":"17-eventCurrentTarget","date":"2016-05-30T01:32:06.000Z","updated":"2017-04-05T13:45:09.000Z","comments":true,"path":"2016/05/30/17-eventCurrentTarget/","link":"","permalink":"http://www.manfredhu.com/2016/05/30/17-eventCurrentTarget/","excerpt":"","text":"做项目的时候遇到的一个挺好玩的属性，就是event.currentTarget这个东西，可能我们以前用的比较多的是event.target。场景我们在列表下&lt;li&gt;标签绑定了事件，然后&lt;li&gt;下是一堆的&lt;i&gt; 标签用作动画。并且&lt;li&gt;上有用属性定义着要跳转的地址。提取例子1234&lt;ul id=\"outer\"&gt; &lt;li id=\"inner\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=\"result\"&gt;&lt;/div&gt;1234567891011121314151617181920212223242526272829body &#123; padding: 25px; font-family: Helvetica, Arial, sans-serif;&#125;#outer &#123; float: left; padding: 50px; margin: 0 0 25px; background-color: #086FA1;&#125;#inner &#123; width: 100px; height: 100px; background-color: #3CA0D0;&#125;#result &#123; clear: left;&#125;code &#123; font-size: 1.2em;&#125;p, ul &#123; margin: 0 0 25px;&#125;1234567891011121314151617181920212223var outer = document.getElementById('outer'), result = document.getElementById('result');outer.addEventListener('click', function (e) &#123; var html = ''; if (e.target === outer &amp;&amp; e.currentTarget === outer) &#123; html += '&lt;p&gt;Outer element was clicked directly - it is &lt;code&gt;e.target&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;e.currentTarget&lt;/code&gt;.&lt;/p&gt;'; &#125; if (e.target !== outer &amp;&amp; e.currentTarget === outer) &#123; html += '&lt;p&gt;Outer element is the current target, but it was not clicked directly - it is &lt;code&gt;e.currentTarget&lt;/code&gt;.&lt;/p&gt;'; &#125; html += [ '&lt;ul&gt;', '&lt;li&gt;&lt;code&gt;e.target === &amp;lt;div id=\"', e.target.id, '\"&amp;gt;&lt;/code&gt;&lt;/li&gt;', '&lt;li&gt;&lt;code&gt;e.currentTarget === &amp;lt;div id=\"', e.currentTarget.id, '\"&amp;gt;&lt;/code&gt;&lt;/li&gt;', '&lt;/ul&gt;' ].join(''); result.innerHTML = html; &#125;);总结针对不同的属性，总结两点如下：event.target捕获发出事件的目标，也是就相当于事件的产生者的意思event.currentTarget则是相当于事件冒泡被设置好监听的对象捕获了。所以如果遇到外层元素如果设置了监听函数而里面还有其他元素的情况下，为了防止点击里面的元素通过event.target获取不到事件对象，可以用event.currentTarget来获取。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"ES6快速学习","slug":"16-learn-ES6","date":"2016-05-20T11:19:36.000Z","updated":"2017-04-05T13:45:13.000Z","comments":true,"path":"2016/05/20/16-learn-ES6/","link":"","permalink":"http://www.manfredhu.com/2016/05/20/16-learn-ES6/","excerpt":"","text":"ECMAScript6，由ECMA组织发布的一个新的JS语言标准。现在比较火的是一个叫babel的编译器，可以将ES6的语法代码转化为ES5，即现在主流浏览器能支持运行的语言。而React这个火到不行的框架在0.13版本之后将JSX的编译器由JSTransform和react-tools转换到Babel，也顺手将Babel这个支持ES6的编译器带火了，现在React编写已支持ES6语法了。转化器只是手段，更多的说的话，现在的ES6被推广主要还是减少我们写代码的数量。能自动化的过程不要手动去解决这是懒人的标准思维。所以总的来说，未来几年ES6会逐渐普及并被应用于项目。Node都到了6.0了你还有理由不学ES6吗？下面一个一个来做例子，推荐scratch.js，一个Chrome浏览器的插件，安装完成在控制台可以看到多了一项选项，点击进去就可以打代码了，打完点击按钮Run就能运行代码了，Toggle output可以让你看到翻译的ES5的语法。Arrows箭头函数1234567//ES6var a = [9,5,2,7].map(v =&gt; v+1)//ES5var a = [9, 5, 2, 7].map(function (v) &#123; return v + 1;&#125;);这里将v作为参数传入返回v+1。那如果有多个参数怎么办呢？1234567//ES6var a = [9,5,2,7].map((v,k) =&gt; v+1)//ES5var a = [9, 5, 2, 7].map(function (v, k) &#123; return v + 1;&#125;);其实要注意的一点是ES6的开始拥有块级作用域的概念，如函数里面的this就已经支持了。12345678910111213141516171819//ES6function pushOne() &#123; this.nums.forEach(v =&gt; &#123; if(v % 2 === 0) &#123; this.arr.push(v); &#125; &#125;)&#125;//ES5function pushOne() &#123; var _this = this; this.nums.forEach(function (v) &#123; if (v % 2 === 0) &#123; _this.arr.push(v); &#125; &#125;);&#125;let和const块级作用域的结构，用let代替var来声明变量那么写法真的就跟Java和C#没什么区别了。12345function f() &#123; let x = 1; console.log(x);&#125;f(); //1但是如果是下面这样，就不行了12345function f() &#123; &#123;let x = 1;&#125; console.log(x);&#125;f();因为let x被{}括起来的块级作用域限定了范围了,再看一个const的例子:12345function f() &#123; const x = \"pphu\"; console.log(x);&#125;f(); //pphu但是如果修改了const声明的值，就不行了123456function f() &#123; const x = \"pphu\"; console.log(x); x = \"ManfredHu\";&#125;f(); //Error其实这些语法都已经成为规范了，不用太去考虑翻译变成什么了，除非浏览器放弃ES6，否则ES6就将火下去。剩余参数1234function f(x,y,...a) &#123; return (x+y) + a.length&#125;console.log(f(1,2,\"just do it\",true,9527)) //6展开操作符123var params = ['Hello',true,7];var other = [1,2,...params];console.log(other); //[1, 2, \"Hello\", true, 7]炫酷没有？直接迭代了params的值copy到other中，我们来试试引用的。1234var arr = [1,2,3]var params = [arr,'Hello',true,7];var other = [1,2,...params];console.log(other); //[1, 2, Array[3], \"Hello\", true, 7]翻译的代码是用到了concat来合并数组项的字符串模板模板这东西，用的多了，没想现在ES6也支持了，所以以后还能用的更爽。123var name = 'ManfredHu' ;var msg = `Hello World ,$&#123;name&#125;!`console.log(msg); //Hello World ,ManfredHu!这货一出来突然发现以后不用自己拼装字符串了，很多代码习惯全部要改。越来越优雅越来越简单了。对象有这么一个关于程序员（媛）的笑话：你想要对象？new一个啊，这么容易123456let x = 1,y =2;let obj = &#123; x,y //直接声明了obj的x和y属性&#125;console.log(obj.x) //1console.log(obj.y) //2Class类这个应该是ES6比较有亮点的地方，JAVA和C#都有了类了，C++也是。所以很多童鞋写JavaScript总是有一种找不到方向的感觉。1234567891011121314151617181920class Shape&#123; constructor(id,x,y)&#123; this.id = id this.move(x,y) &#125; move(x,y)&#123; this.x = x this.y = y &#125;&#125;class Reactangle extends Shape &#123; constructor(id,x,y,width,height)&#123; super(id,x,y) this.width = width this.height = height &#125;&#125;console.log(new Reactangle(1,2,3,10,20)) //Reactangle &#123;id: 1, x: 2, y: 3, width: 10, height: 20&#125;还可以这么玩1234567var Shape = class&#123; constructor(h,w)&#123; this.h= h this.w= w &#125;&#125;console.log(new Shape(10,20)) //Shape &#123;h: 10, w: 20&#125;static静态方法12345678910class Man&#123; constructor(name)&#123; this.name = name &#125; static getSex()&#123; return &quot;Man&quot; &#125;&#125;console.log(Man.getSex()) //Man进制的问题12console.log(0b111) //二进制111转化为十进制7console.log(0o11) //八进制11转化为十进制9解构赋值12345let foo = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];let [a,b,c] = foo;console.log(a) //onwconsole.log(b) //twoconsole.log(c) //threePromisenew Promise(fn) 返回一个promise对象在fn 中指定异步等处理·处理结果正常的话，调用resolve(处理结果值)处理结果错误的话，调用reject(Error对象)两种状态，完成OR拒绝promise对象被 resolve 时的处理(onFulfilled)promise对象被 reject 时的处理(onRejected)Promise.resolve一般情况下我们都会使用 new Promise()来创建promise对象，但是除此之外我们也可以使用其他方法。静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。如：1Promise.resolve(42);可以认为是以下代码的语法糖。123new Promise(function(resolve)&#123; resolve(42);&#125;);在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.manfredhu.com/tags/ES6/"}]},{"title":"浪潮之巅个人感想","slug":"book-topOfWave","date":"2016-04-20T05:31:46.000Z","updated":"2017-03-13T15:50:55.000Z","comments":true,"path":"2016/04/20/book-topOfWave/","link":"","permalink":"http://www.manfredhu.com/2016/04/20/book-topOfWave/","excerpt":"","text":"作者：ManfredHu链接：http://www.manfredhu.com/2016/04/20/book-topOfWave/声明：版权所有，转载请保留本段信息，否则请不要转载AT&amp;T跟随长途通信兴起的企业，后来被美国反垄断法强制分成四个子公司。鼎鼎大名的贝尔实验室，C语言和Unix操作系统诞生的地方，后面被拆分也就没了。再好的技术也要有好的企业发展方向来主导IBMIBM注重与政府部门，国企和军队的合作，虽然错失了微机和互联网的浪潮，但是却在历次经济危机中存活了下来，并且现在仍然是世界上员工人数最多、营业额和利润最高的技术公司之一。好像CVTE也是这种模式，B2B模式，也就是与政府部门、企事业单位合作，这样不会受到市场太大冲击Apple乔老爹的经历，堪称传奇吧？大学半年不到，辍学学自己感兴趣的书法课，其实我略好奇一个原来搞技术的人突然去学书法会是怎么样一种心态，不过不得不说，如果程序员有了一丝艺术气息，绝对是一种与众不同的体验。因为身边就有很多这样的例子，字写的非常好看，然后喜欢小清新的那些东西。如果要说苹果的第一次失败的原因的话，我认为是微软联合了大众将苹果比如绝地，兼容机的横行完全蚕食了苹果的市场，至少在那个全世界还讲求温饱的阶段，能体会苹果工业设计极致和用户体验的人不多。首先你要能生存下去，然后才是其他方面上的享受。在现在的社会，温饱问题基本不大，所以产品应该更加关注提升用户精神愉悦，用户体验上的方面还有从苹果技术与对用户体验平衡上的观点来考虑，它的选择是这样的对用户体验最执着的追求，不管技术实现多么难，总是服务于用户的。看苹果历代的产品就可以看出来。乔布斯第二次创业的公司，就是一个做动画的公司吧简单来说。反正这也是延续了乔老爹一贯的作风——追求走在时代前面的东西，并且在接下去用户需要的。话说谢霆锋也是创办了一个公司，叫PO朝霆好像，反正感觉国内电影这几年发展迅速，做后期特效的肯定发展非常好。但是最主要的还是觉得霆锋起步非常早，而且坚持了下来，自己又是艺人，有很多资源可以利用。摩尔定律计算机硬件每18个月价格减半。所以你是不是在等着手机降价？小米的饥饿销售？安迪-比尔定律运算速度性能的提高被软件的速度拖慢，但是软件的开发却越来越快越来越工程化。这样就吃掉了硬件性能提升的优势，当然相应的就是软件的功能越来越多，比如我们的APP动辄几百M，一个游戏动辄几十G，这在以前根本无法想象。但是现在已经习以为常了。就这样大鱼吃小鱼，小鱼吃虾米，不停的促进IT行业的进步。从编程语言来看也是这样的道理Java效率比C++的低，C++的比C的低，C的比汇编的低反摩尔定律一个IT公司如果今天和18个月前卖掉同样多同样的产品，则营业额就降低一半。所以为什么说IT公司劳动强度高？其实是有原因的。大环境逼迫着你需要不停的去进步，去完成安迪-比尔定律的循环英特尔公司微机芯片帝国，现在我们在组装电脑的时候可能会有这样的选择：到底买英特尔的CPU还是AMD的？别人会告诉你：如果你要稳定就买英特尔的，AMD的虽然便宜但是不好用。英特尔的芯片基本垄断了PC端的市场，在90年代跟微软组成的WinTel阵营逼迫着IBM放弃PC这块大蛋糕但是现在也有对手了，随着移动设备兴起的：ARMARM是一种基于精简指令的处理器，在移动设备如手机，PAD等用的多如果你还像我高中一样以为芯片只有电脑CPU那种，那就快快改变过来吧。ARM的模式也挺独特的，它不生产芯片，它只设计芯片，然后让各大厂商去生产芯片，可以说ARM控股公司就是个研究所。但是人家有分钱的，人家赚的是专利。微软用着WindowXP和Microsoft Office十几年了吧。巨硬（微软）肯定知道的啦。基本上垄断了PC操作系统级别的市场。当然它还想进军移动操作系统的市场，但是随着安卓和iOS的把控，微软还是没什么戏了感觉。虽然它不止一次想用WinPhone去占领市场，不过还是没有太大作用。微软垄断了PC端的操作系统、借助捆绑优势进而垄断办公软件、浏览器（IE）Bill Gate和Jobs的交锋也堪称经典，原来的微软只有DOS，而乔布斯的大意让微软有研发Window3的机会。后面乔布斯重回Apple的时候，又是比尔盖茨给他机会翻身。相爱相杀的两个人堪称佳话啊，好像网上还有段视频，是乔布斯对全公司宣布的和微软合作的那个情况，刚宣布是全场哗然，后面说到要为苹果开发Office的时候才有欢呼声。甲骨文公司甲骨文公司的代表产品——Oracle数据库不知道大家听过这样的说法没有，IBM的服务器，EMC的存储器，Oracle的数据库。这就是以前的一套企业搭建服务器后台的一套方案了。当然现在EMC被戴尔收购了。也没有IOE垄断的说法了。这方面是阿里巴巴的功劳。后面的Oracle趁着经融危机收购了Sun，获得了Java，收购了MySQL,用收购来的东西跟Google打官司。因为Google的安卓就是基于Java的。虽然最后失败了，不过这种并购的手段还是很让人佩服的，原来的Sun臃肿，产品多而不赚钱，但是被Oracle收购后每个东西都能有作用，不管是专利诉讼还是合并，都带动了企业原来的产品技术，或者是为未来的发展铺平了道路。思科在90年代靠着互联网的热潮，做着路由器兴起的思科公司。允许自己的员工在公司内部创业，然后收购员工创立的公司。怎么感觉BAT现在的收购有点类似的感觉？雅虎最早的门户网站，相当于现在的搜索引擎如百度和Google，用户通过这个去访问别的网站获取资讯。中国随之诞生的门户网站——搜狐、网易和新浪当然后面随着搜索引擎的流行，现在门户网站都基本没什么人用了吧。但是大型的门户网站在赚了第一桶金之后，现在还是能稳定的生存下去。要开始找到另外的增长点，否则只是坐吃山空。惠普惠普公司的创立，联系到斯坦福大学，就是那个乔布斯读了半年的那个大学。刚开始没有什么名气，后面学校搞了个工业园，更企业合作，校企合作，学校输送人才，企业消化，这样互相发展才真正是进步。风险投资在我的大学阶段，参加过的创业比赛大大小小不计其数，对其中财务一块算是比较陌生但是却在比赛中占有很大一块比例的。比如通常会有这样的一个表格注册资本比例风险投资众筹创业团队无形资产25%10%45%25%风投：全称风险投资（Venture Capital），简称VC。大部分是以投资高新技术为主，由职业金融家投入到新兴的、迅速发展的、具有巨大竞争潜力的企业中的一种权益资本。也可以说，小型的创业团队的发展其实大部分靠的就是风投或者天使投资，这两个概念的区别其实不大，大金额我们会叫风险投资，十几万的会叫天使投资。通常风投会是别的公司或者机构，天使投资会是个人。GoogleGoogle从诞生的时候就是个传奇，两位创始人在斯坦福大学的帮助下拿到太阳总裁的10万刀的投资，开始了征程。而且我们或许会听到Google的办公环境多好多好，但是我们或许不会发现一个事实——Google是全世界单位博士聚集数量最多的地方。这是Google对员工的另类补偿可以这么说，如果对一些大牛束缚太多真的就不太好了。这点也是Google觉得做的比较好的地方，当然Google的员工也是真心厉害或者是因为大部分员工都是工程师，所以才可以有这样的“特权”。或许我们国内的公司会模仿Google的模式，比如有一条可以滑下去几楼高的滑道，但是我发现——上面都是灰，也就是说其实平常是没有人去玩的。。。。。而Google的是铝合金的。。。。要说Google的特权那就多了去了，什么上班可以带宠物啊等等，不过其实方针就是体现关爱员工尊重员工罢了，现在的IT公司大部分都会在招聘的时候这样说的。Google的赢利模式：广告！！靠搜索广告来支撑公司收入，这点和百度差不多，不过百度是竞价排名和出售搜索页面的右侧广告位来赚钱。Google有一点做的比较好的，广告不多，但是收费很高，与搜索结果的相关度比较高。这样导致的结果就是用户会越来越喜欢Google简洁的界面，广告的点击转换率会比较高。长期发展来说，这样简介和收费高的广告门槛有助于Google保持在普通用户心目中的地位，也让对手无利可图。这点可以跟百度一些查询结果满页都是广告形成鲜明的对比。毕竟对于一个搜索引擎来说，用户的粘性才是最重要的，变现可以有很多种方法，不需要以牺牲用户体验去变现。facebook我们老是叫它脸书，其实真的不是一本书。。。facebook基本垄断了现在全世界的社交网络（除了中国大陆）。说到facebook的发家史也是挺好玩的，创始人的意图本来是想着——那个叫约约约？（反正蜀黍我们不约）在大学里面首先流行起来了，因为注册是用学生的邮箱注册的，所以真实度很高。后面随着学生离开大学，facebook就走出了大学校园，开始做社交了。随着社交越做越大，渐渐的有点追赶Google的趋势了，特别是人才的竞争，其实你看一些框架就能看出个大概了，Angular是Google的，React是facebook的。框架当然是要适应他们具体公司的业务需求的。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"读书笔记","slug":"笔记/读书笔记","permalink":"http://www.manfredhu.com/categories/笔记/读书笔记/"}],"tags":[{"name":"book","slug":"book","permalink":"http://www.manfredhu.com/tags/book/"}]},{"title":"JavaScript编程题","slug":"15-veryGoodForUsing","date":"2016-04-02T06:42:57.000Z","updated":"2017-04-05T13:45:17.000Z","comments":true,"path":"2016/04/02/15-veryGoodForUsing/","link":"","permalink":"http://www.manfredhu.com/2016/04/02/15-veryGoodForUsing/","excerpt":"","text":"几道觉得挺有意思的编程题，感觉做下来，自己对一些新方法的看法有了新的变化。比如indexOf,reduce,Array.isArray,forEach这些方法，以前一看到兼容性是IE9+就有点害怕，项目中不敢用，导致后面越来越陌生，不过现在一想的话。其实只要用Polyfill或者提前fix掉就可以了。^_^而且随着浏览器的更新迭代，这些方法肯定会获得更多的支持。ps:希望新手更要多用这些方法，在特别是学日常学习训练的时候更新：参加腾讯笔试的编程题，觉得挺有意思的，补上，不过可惜选择语言的时候没有JavaScript。郁闷了好久-_-!!蛇形矩阵（2016腾讯校招编程题）作为一种常用的数学数列，是由1开始的自然数一次排列成的一个N*N的正方形矩阵，数字一次由外而内的递增，如下面实例：1234567891011121314151617n=3的蛇形矩阵1 2 38 9 47 6 5n=6的蛇形矩阵 1 2 3 4 5 620 21 22 23 24 719 32 33 34 25 818 31 36 35 26 917 30 29 28 27 1016 15 14 13 12 11此题要求输入蛇形矩阵宽度N，输出整个蛇形矩阵结果，注意输出格式要求按照矩阵从上至下的依次按行输出，每行中间无需换行输出。样本输入： 3样本输出： 1 2 3 8 9 4 7 6 5自己写的答案（欢迎补充）^_^1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//可以把代码复制到Chrome控制台运行;(function() &#123; function fixIsArray() &#123; if (!Array.isArray) &#123; Array.isArray = function(arr) &#123; return Object.prototype.toString.call(arr).slice(8, -1) === \"Array\"; &#125; &#125; &#125; fixIsArray(); //fix Array.isArray（Array.isArray在IE9+支持） function Arr2D(d) &#123; if (typeof d !== 'number') throw new Error('Arr2D():arguments d must be number'); this.d = d; this.arr = this.init2DArr(d); &#125; Arr2D.prototype.reat2DArr = function() &#123; var c = 0, //环数 i = 0, //行 j = 0, //列 out = 1, //总数 z, n = this.d, a = this.arr; //检验参数 if (!Array.isArray(a)) throw new Error('reat2DArr():arguments a must be Array'); if (typeof n !== 'number') throw new Error('reat2DArr():arguments n must be Number'); z = n * n; while (out &lt;= z) &#123; i = 0; /*每轮后初始化下i,j*/ j = 0; for (i += c, j += c; j &lt; n - c; j++) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; for (j--, i = i + 1; i &lt; n - c; i++) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; for (i--, j = j - 1; j &gt;= c; j--) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; for (j++, i = i - 1; i &gt; c; i--) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; c++; &#125; return this; &#125;; Arr2D.prototype.printArr = function() &#123; var a = this.arr, n = this.d, lineStr; if (!Array.isArray(a)) throw new Error('printArr():arguments a must be Array'); for (i = 0; i &lt; n; i++) &#123; lineStr = \"\"; for (j = 0; j &lt; n; j++) &#123; lineStr += ' ' + a[i][j]; &#125; console.log(lineStr); &#125; return this; &#125;; //初始化二维矩形数组 Arr2D.prototype.init2DArr = function(m) &#123; var arr = [], i, j; for (i = 0; i &lt; m; i++) &#123; arr[i] = []; for (j = 0; j &lt; m; j++) &#123; arr[i][j] = 0; &#125; &#125; return arr; &#125;; //调用函数,测试数据数据为3 var arr = new Arr2D(3); arr.reat2DArr().printArr();&#125;)();大招来了：特别的回文字符串（2016腾讯校招编程题）所谓回文字符串，就是一个字符串，从左到右和从右到左读是完全一样的。比如”aba”、”c”。对于一个字符串，可以通过删除某些字符而变成回文字符串，如”cabebaf”，删除’c’,’e’,’f’后剩下子串’abba’就是回文字符串。要求，给定任意一个字符串，字符串最大长度1000，计算出最长的回文字符串长度。如’cabebaf’的回文字符串包括’c’,’aba’,’abba’等，最长回文”abba”长度为4。输入：字符串输出：最大的回文字符串长度。示例：输入：cabbeaf输出：4问题：个人是觉得上面这道题的描述是有问题的，比如cabebaf，那么abeba算不算回文？通常应该是算的。但是按照题目的意思则是abba才算回文，abeba是不算的。而且这里有干扰项，输入示例的cabbeaf中，要删除字符e才能检测出回文abba。所以这跟普通的回文判断完全不一样。普通的估计用这样的方法就能判断了12345//判断如abba,abeba这样的字符串function testArr(str) &#123; //将字符串切割为字符数组，倒序反转再判断跟原来的字符串是否一样 return str.split('').reverse().join('') === str;&#125;但是这里不是普通的题目，所以刚开始我想的是用indexOf和lastIndexOf来做，通过字符串的逐渐缩小范围，indexOf和lastIndexOf又可以避免要删除字符e的尴尬。12345678910111213141516171819202122232425262728293031323334353637383940;(function() &#123; //输入：cabbeaf //4 String.prototype.roundWord = function() &#123; var i = 0, str = this, count = 0, //回文计数 left, right = str.length - 1, max = 0, flag = false; if (str.length &lt;= 0) throw new Error(\"roundWord(): arguments str/this must be string\"); while (i &lt; str.length) &#123; charOne = str.charAt(i); left = str.indexOf(charOne, i); if (!flag) &#123; right = str.lastIndexOf(charOne); &#125; else &#123; right = str.lastIndexOf(charOne, right); &#125; if (left !== right &amp;&amp; left &lt; right) &#123; //头尾有相同字符 if (++count &gt;= max) max = count; flag = true; //开始有回文 &#125; i++; &#125; return count*2; &#125;; var str = \"cababeacf123\"; console.log(str.roundWord()); //6 str = \"cabbeaf\"; console.log(str.roundWord()); //4&#125;)();用reduce统计一个数组中单词出现的次数1234567891011var arr = [\"apple\",\"orange\",\"apple\",\"orange\",\"pear\",\"orange\"]; function getWordCnt()&#123; //以下应掏空 return arr.reduce(function(prev,next,index,arr)&#123; prev[next] = (prev[next] + 1) || 1; //这句是重点,刚开始都是undefined的时候undefined+1会是NaN return prev; &#125;,&#123;&#125;);&#125; console.log(getWordCnt());注意：这里传入了{}作为初始参数，所以第一个prev会是一个空对象，所以第一次的prev[next]会是undefined，而这里用了赋值给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false1234function containsRepeatingLetter(str) &#123; //以下应掏空 return /([a-zA-Z])\\1/.test(str); // \\1指代第一个括号的匹配项&#125;在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\\1就是引用第一个分组，\\2就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。已知fn为一个预定义函数，实现函数curryIt需要补全的代码12345678var fn = function(a, b, c) &#123; return a + b + c&#125;;curryIt(fn)(1)(2)(3); //6function curryIt(fn) &#123; //这里补充&#125;可以试着玩一下，这里是用的函数的柯里化1234567891011121314151617181920var fn = function(a, b, c) &#123; return a + b + c&#125;;console.log(curryIt(fn)(1)(2)(3)); //6function curryIt(fn) &#123; //以下应掏空 if(typeof fn !== 'function') throw new Error(\"curryIt():fn must be function\"); var len = fn.length; //获取函数形参数量 var slice = Array.prototype.slice; var arg = slice.call(arguments, 1); return function() &#123; arg = arg.concat(slice.call(arguments)); if(arg.length &lt; len) &#123; //当等于函数需要的形参数量时候调用 return arguments.callee; &#125;else&#123; return fn.apply(null,arg); &#125; &#125;&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"SublimeText3常用快捷键和优秀插件（亲测）","slug":"11-SublimeText3Plug","date":"2016-03-26T19:26:48.000Z","updated":"2017-01-18T07:21:23.000Z","comments":true,"path":"2016/03/27/11-SublimeText3Plug/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/11-SublimeText3Plug/","excerpt":"","text":"这篇是自己在之前的博客写的，貌似慕课拿了5000+的Page view，其他各种转载就不说了。2016/5/29更新MarkDown插件SublimeText是前端的一个神器，以其精简和可DIY而让广大fans疯狂。好吧不吹了直入正题 -_-!!首先是安装，如果你有什么软件管家的话搜一下就好，一键安装。然后，有钱的土豪就自己买个吧，穷逼就搜下注册码看下有没有土豪共享咯。既然是神器，肯定有你不知道的东西不是，下面这部分来讲操作。PS：大部分图片和文字来自网络，这里只是略微排版方便查阅。测试操作系统：Win10测试软件版本：SublimeText3 3059SublimeText3 操作部分就近选择相同项: ctrl+d把光标放在一个单词上，按下ctrl+d，将选择这个单词。一直按住ctrl且按D多次，将选择当前选中项的下一个匹配项。通过按住ctrl，再按D三次，将选择三个相同的文本。选择当前文件所有匹配项: alt+f3选择文件中的所有匹配项。小心使用这个，因为它能选择一个文件中的所有匹配项. .选择文本的包裹标签: ctrl+shift+’ （ESC键下面的那个）这是一个法宝。也许你希望所有属性保持不变，但只是想选择标签。这个快捷键为你这样做，会注意到你可以在一次操作多个标签。ps：需要Emmet插件（可以直接到后面看插件的安装）向上扩展一层: ctrl+shift+a如果你把光标放在文本间再按下上面的键将选择文本，就像ctrl+d。但是再次按下它，将选择父容器，再按，将选择父容器的父容器。ps：需要Emmet插件（可以直接到后面看插件的安装）选择括号内的内容: ctrl+shift+m这有助于选择括号之间的一切。同样适用于CSS。选择括号内的内容: ctrl+shift+↑或 ctrl+shift+↓选择括号内的内容: ctrl+shift+d如果你已经选中了文本，它会复制你的选中项。否则，把光标放在行上，会复制整行。增加和减少缩进: ctrl+[ 或 ]单行剪辑或选中项: ctrl+x粘贴并复制格式: ctrl+shift+v用标签包裹行或选中项: alt+shift+w移除未闭合的容器元素: ctrl+shift+;这会移除与你的光标相关的父标签。对清除标记很有帮助。大写和小写: 大写ctrl+k+u、小写ctrl+k+l注释选中项/行: ctrl+/这个在所有语言下都可用， 对行和选中项都可用。删除一行: ctrl+shift+kSublimeText3 插件部分首先是安装包管理器Package Control，SublimeText3的指令已经更新了，SublimeText2更新上来的童鞋注意下Ctrl+`打开控制台或者View-&gt;Show Console菜单打开命令行1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())就是上面这串东西了，然后就可以接下来的安装插件了Tips: 插件名字链接到github，网络不好的童鞋自行下载包扔到Preferences-&gt;Browse Packages打开的文件夹下面，然后解压，重启Sublime就行emmet这个没有什么好说的，类似jQuery的语法，编码蹭蹭往上提。不过要求PyV8环境（安装完后你会看到有一个文件夹），最好还是选择在线装吧。ctrl+shift+P 输入 install Package 等待读取服务器列表，输入emmet第一个就是了ps：最好看一下github里面的简单教程侧边栏增强插件SideBarEnhancements这个也没有什么好说的，谁用谁知道，大大增强右键列表的功能，装上就能用。控制台呼出插件Terminal用node，Grunt等等要调出控制台的娃知道的，简直神奇有木有，装上就能用。Tips:快捷键 ctrl+shift+T呼出当前文件路径的控制台在Mac下时command+shift+t哈，也可以设置呼出的为iTerm2具体的看这里iTerm的版本自己打开iTerm看看，2的设置不一样的。可以加打开文件的参数，这样打开就在你的文件对应的目录下了，简单有效。代码提示插件SublimeCodeIntel这个也没什么废话吧，支持多语言的高速编码的代码提示工具。装上后还不能直接使用，查了一下原因要配置你可以点击Preferences-&gt;Browse Packages-&gt;SublimeCodeIntel然后添加一个.codeintel文件夹再再在文件夹里面添加一个config文件（Windows创建.codeintel文件夹需要输入.codeintel.）config文件配置：1234567891011121314151617181920212223242526&#123; &quot;PHP&quot;: &#123; &quot;php&quot;: &apos;/usr/bin/php&apos;, &quot;phpExtraPaths&quot;: [], &quot;phpConfigFile&quot;: &apos;php.ini&apos; &#125;, &quot;JavaScript&quot;: &#123; &quot;javascriptExtraPaths&quot;: [] &#125;, &quot;Perl&quot;: &#123; &quot;perl&quot;: &quot;/usr/bin/perl&quot;, &quot;perlExtraPaths&quot;: [] &#125;, &quot;Ruby&quot;: &#123; &quot;ruby&quot;: &quot;/usr/bin/ruby&quot;, &quot;rubyExtraPaths&quot;: [] &#125;, &quot;Python&quot;: &#123; &quot;python&quot;: &apos;/usr/bin/python&apos;, &quot;pythonExtraPaths&quot;: [] &#125;, &quot;Python3&quot;: &#123; &quot;python&quot;: &apos;/usr/bin/python3&apos;, &quot;pythonExtraPaths&quot;: [] &#125;&#125;其实只要有JS就够了，不过或许某天你要写PHP了呢是吧，留着吧。然后打开Sublime创建个文件试一下，如果还不行就按下 ctrl+shift+space 开启提示功能代码排版插件Sublime-HTMLPrettify以前用的是什么TAG，CssComb和JSFormat，但是某一天发现这款集成prettify的插件后就一直没换过了,不要被插件的HTML迷惑，这是一款可以用于HTML，CSS，Javascript的集成排版插件Tips:安装完快捷键ctrl+shift+h 一键格式化代码CSS3前缀补充插件Autoprefixerctrl+shift+P 输入 install Package 等待读取服务器列表，输入autoprefixer第一个就是了要装Node.js，没有的话去下载安装吧插件使用CanIUse资料库，能精准判断哪些属性需要什么前缀Tips:使用方法：在输入CSS3属性后（冒号前）按Tab键SublimeText3 添加右键菜单和快捷开启浏览器添加右键菜单有时候要开个文件要开个SublimeText3，又要拉文件，麻烦。这里介绍将Sublime添加到右键菜单。打开注册表，开始→运行→regedit在 HKEY_CLASSSES_ROOT→ * → Shell 下面新建项命名为SublimeText右键SublimeText项，新建字符串值，命名为Icon，值为 “sublime_text.exe所在路径,0”，例如：C:\\Program Files\\Sublime Text 3\\sublime_text.exe,0右键SublimeText项，新建项，命名为command，默认值为 “sublime_text.exe所在路径 %1”，例如：C:\\Program Files\\Sublime Text 3\\sublime_text.exe %1一键浏览文件Preferences-&gt;Key Bindings - User打开用户快捷键设置，copy下面的设置123456789101112131415161718192021222324252627282930313233343536373839404142[ //firefox &#123; &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //chorme &#123; &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Users\\\\manfr\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //IE &#123; &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //safari &#123; &quot;keys&quot;: [&quot;f4&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files (x86)\\\\Safari\\\\Safari.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;]稍微解释下，keys是按键，application是浏览器应用程序路径，注意反斜杠的要转义。extensions是匹配所有的文件后缀格式。Tips:查了下默认的快捷键，SublimeText3中f1-f12中只有f11被默认为全屏命令，其他的没设置。也就是说，你可以装十个八个浏览器一字排开按过去测试。SublimeText3 问题部分（自己遇到过的）自动更新有时候会弹出自动更新的框，解决方法：找到Preferences -&gt; Settings-User（设置用户）在最后一个花括号结尾（“｝”）前添加一句：&quot;update_check&quot;:false然后请关闭Submine Text并重启，即不会再弹出更新提醒了不能获取插件列表 Package Control：There are no packages available for installationcmd下输入ping sublime.wbond.net链接一下看下sublime.wbond.net这个域名的ip打开C:\\Windows\\system32\\drivers\\etc\\hosts文件。在最后面加上例如 50.116.34.243 sublime.wbond.net这样的对应关系，IP是上面测试的然后请关闭Submine Text并重启，即不会再弹出更新提醒了参考Sublime Text 3前端开发常用优秀插件介绍——黄映焜Gif多图：我常用的 16 个 Sublime Text 快捷键 | 氪星人补充Ubantu配置部分（补）最近在玩Ubantu，所以将环境切了过去。这里补充一下吧。装SublimeText3首先是安装，试了一下SublimeText2的（去官网默认就是下的2的-_-!!）发现调不出安装包列表，后面也没去详细研究直接下了个SublimeText3的安装包装上。附上Ubantu下SublimeText3-64bit的链接：http://www.sublimetext.com/3装node插件的安装跟上文差不多，唯一比较苦逼的就是装node（插件依赖node环境）的时候了，不知道为什么安装好了输入node -v老是没有显示版本，搞了好久最后无奈去Github下了个node的安装包才搞定。Tips:一定要确认node -v和npm -v可以输出版本号才表示node安装完成附上ubantu装node的N种方法的帖子：http://www.linuxidc.com/Linux/2015-07/119588.htm一键浏览文件还有就是设置一键浏览文件的时候了，浏览器安装的目录跟Windows有点区别，看下面：12345678910111213141516171819202122[ //firefox &#123; &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;/usr/lib/firefox/firefox&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //chorme &#123; &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;/opt/google/chrome/google-chrome&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;]火狐是Ubantu自带的，目录如上。然后chrome是我自己装的，基本上也应该是这个目录。装好之后找个文件按F1和F2检测下就好。搞下来其实觉得没什么，主要是刚接触Ubantu系统对一些东西不太熟悉，后面加强。Thx ^_^MarkDown插件MarkdownEditing这货很不错，快捷键什么都有了。具体的可以看github的介绍markdown-preview这个插件是实时预览的插件，把下面这段加在Preferences-&gt;Key Bindings-User下就可以按ctrl+m预览了。12345&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview_select&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;&#125; &#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"Sublime","slug":"Sublime","permalink":"http://www.manfredhu.com/tags/Sublime/"}]},{"title":"JavaScript的动态特性(通过eval,call,apply和bind来体现)","slug":"12-EvalCallApplyBind","date":"2016-03-26T16:45:01.000Z","updated":"2017-01-18T07:11:40.000Z","comments":true,"path":"2016/03/27/12-EvalCallApplyBind/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/12-EvalCallApplyBind/","excerpt":"","text":"JavaScript是一种基于面向对象的、函数式的、动态的编程语言。现在发展到已经可以用在浏览器和服务器端了。这里不谈面向对象，也不去提及函数式编程，就单单讨论动态性。什么称为动态？语言的动态性，是指程序在运行时可以改变其结构。通俗地说就是没运行你根本不知道这段代码会出现什么情况，可能某个变量跟声明的时候不一样了，可能某个函数的作用域变了。如果有用到动态特性，很多时候你只能凭借经验来判断这段代码的执行流程。个人觉得JavaScript的动态性可以用下面几个函数的使用来总结evalapply和callbindeval函数123eval(alert(\"汪峰又上头条了！\")); // --&gt;汪峰又上头条了！alert(window.eval === eval); // --&gt;truealert(eval in window); // --&gt;false这里大概能看明白用法了，eval是一个挂载在window对象下面的函数，而且eval是不可枚举的。eval函数的动态性体现在可以在脚本执行的时候，动态改变某些东西。上面的例子就体现了这点，eval()括号里面可以执行语句，可以在程序执行的时候动态改变某些东西。下面来讨论eval函数另外一个比较坑爹的问题：eval的作用域问题举个栗子：12345678var i = 100;function myFunc() &#123; var i = \"text\"; window.eval('i = \"hello\"'); alert(i); // 现代浏览器提示text，IE6-8提示hello&#125;myFunc();alert(i); // 现代浏览器提示hello，IE6-8提示100为什么会这样呢？原因就是不同的浏览器JS引擎对eval函数的作用域设定是不一样的。这里我们指定的window.eval函数，意在让i的值改为hello字符串。但是不同浏览器JS解析内核对eval函数的作用域的设定是不同的，IE6-8因为用的是JScript内核，所以eval读到i是myFunc函数里面的var i = &quot;text&quot;的i，所以将myFunc函数里面的text改为hello之后就是显示hello了。而现代浏览器则认为window.eval是改变的是全局i=100的值。那如果window.eval改为eval呢？1234567var i = 100;function myFunc() &#123; var i = \"text\"; eval('i = \"hello\"'); &#125;myFunc();alert(i); // --&gt;100恭喜恭喜^_^，这里的eval没有指定window作用域，所以浏览器统一输出100。eval函数默认改变的就是当前作用域下的变量值。附上常见浏览器JS引擎和内核的列表（不完全）：公司浏览器JS引擎渲染引擎MicrosoftIE6-8JScritpTridentIE9-11ChakraTridentEdgeChakraEdgeMozillaFirefoxJagerMonkeyGeckoGoogleChromeV8BlinkAppleSafariWebkitSquirrelFish ExtremeOperaOpera12.16+BlinkCarakan这些只是属于JS引擎和内核的一部分而已（现有的），其他版本的请自行搜索。apply和callapply和call的基本用法apply和call的使用非常相似，举个栗子：12345678910var name = \"JaminQian\", obj = &#123; name: \"ManfredHu\" &#125;;function myFunc() &#123; alert(this.name);&#125;myFunc(); // --&gt;JaminQianmyFunc.call(obj); // --&gt;ManfredHu这里的作用就是改变this的指向，我们知道this其实在不同的环境下的指向是不一样的。有时候是window全局对象，有时候是某个对象，通过apply和call，我们就可以随意改变函数里面this的指向来达到我们的动态性。再看下面这个例子：1234567891011121314151617181920212223242526272829303132333435function Animal()&#123; this.name = \"Animal\"; this.args = arguments; //在实例上缓存构造函数的参数 this.showName = function()&#123; console.log(this.name); &#125;; this.getArgsNum = function()&#123; console.log(this.args); &#125;&#125; function Cat(num1,num2,num3)&#123; Animal.apply(this,arguments); //继承Animal this.name = \"Cat\";&#125;function PersianCat()&#123; //波斯猫 Cat.apply(this,arguments); //继承Cat this.name = \"PersianCat\";&#125;var animal = new Animal(); var cat = new Cat(1,2,3);var PersianCat = new PersianCat([1,\"2\",[3]]);//输出this.nameanimal.showName(); //--&gt;Animalanimal.showName.call(cat); //--&gt;Catanimal.showName.call(PersianCat); //--&gt;PersianCat//获取构造函数的参数animal.getArgsNum(); //--&gt;[]cat.getArgsNum(); //--&gt;[1,2,3]PersianCat.getArgsNum();//--&gt;[[1,\"2\",[3]]]这里的生物链是Animal-&gt;Cat-&gt;PersianCat(波斯猫)，生物学的不好不知道对不对暂且忽略哈^_^。然后是不停的用call在构造函数继承父类的属性（借用构造函数继承，也称为对象冒充），但是又有自己的特殊属性name，也就模仿着实现了面向对象的继承与多态。最后是apply一个最常用的做法，将参数毫无保留地传递到另外一个函数上。apply和call的实用用法获取数组的最大值、最小值如果让你来用JS求一个数组的最大值最小值的方法的话，你可能回想到遍历，可能会问下是不是有序的，用折半查找算法。但是这里的用法是比较巧妙滴。12345678910111213var numbers = [5,\"30\",-1,6, //这里定义了一个数组，numbers[1]是一个字符串\"30\" &#123; a:20, //其中最后一个元素是一个对象，重写了valueOf方法 valueOf:function() &#123; return 40 &#125; &#125;,];//求数组的最大最小值var max = Math.max.apply(Math,numbers), min = Math.min.call(Math,-10,2,6,10);console.log(max); //--&gt;40console.log(min); //--&gt;-10大概说一下：我们知道JS是非常懒的，只有当需要字符串的时候会去调用Object.prototype.toString()方法转化成字符串，而当需要数值的时候去调用Object.prototype.valueOf()方法转化为数字。这里就是用到了valueOf来转化字符串&quot;30&quot;为数值30了。当然如果全部是数字的情况就更简单了，这里不赘述了。在原来的数组追加项如果有人问你要合并两个数组要怎么做？你可以会想到Array.prototype.concat()方法123456var arr1 = [22, 'foo', &#123; age: \"21\"&#125;, -2046];var arr2 = [\"do\", 55, 100];var arr3 = arr1.concat(arr2);console.log(arr3); //--&gt;[22, \"foo\", Object, -2046, \"do\", 55, 100]OK合并完成，你也可能会想到用循环arr2然后push每一项到arr1的方法。那比较优雅的合并数组的方法呢？狗血编剧肯定会写有的啦。123456var arr1 = [22, 'foo', &#123; age: \"21\"&#125;, -2046];var arr2 = [\"do\", 55, 100];Array.prototype.push.apply(arr1,arr2); //注意这里用的是apply，传入的是数组console.log(arr1); //--&gt;[22, \"foo\", Object, -2046, \"do\", 55, 100]有没有一种四两拨千斤的赶脚？验证数组类型某天，BOSS要你将AB两个同事的代码重构一下提升下效率，那么对于重复的部分肯定要抽象出来。嗯，两边都有一个检测数组的操作，很自然，你要封装一个isArray函数来判断。然后你一拍大腿，丫的不是有原生的判断isArray的方法了吗？OK你搜了一遍发现了一个坑爹的问题：IE9+才有Array.isArray()方法，那OK，做好兼容不就行了嘛？1234567function isArray(value) &#123; if(typeof Array.isArray === \"function\") &#123; //ES5新增加的判断数组的方法，IE9+支持 return Array.isArray(value); &#125; else &#123; return Object.prototype.toString.call(value) === \"[object Array]\"; &#125;&#125;逻辑非常简单粗暴，就是下面的兼容的方法要仔细看下，原理就是数组调用Object.prototype.toString()的时候会返回&quot;[object Array]&quot;字符串。当然这里可以扩展下，类型检测大体来说基本类型检测用typeof是够的，像number, string,boolean,undefined都可以用typof检测。对于自定义引用类型的话用instanceof和Object.prototype.hasOwnProperty或者constructor属性也是够的。比较容易出错的地方在检测数组和检测函数这两个地方，特别是有iframe的地方，原来的检测方法失效，所以要特别注意。检测数组如上所述，是比较公认的方法。检测函数的话用typeof foo === &quot;function&quot;(假定foo是一个函数)来检测。类数组用数组的方法类数组是什么就不说了，有兴趣的可以翻一下之前的文章，搜一下类数组或者array-like就有了。其实这里用的最多的，估计就是jQuery了，抽象一下jQuery源码的用法。或者你可以去Look下有加了点中文注释版的jQuery源码，下面代码不能运行，只是加深下理解而已。12345var arr = [];var slice = arr.slice; //数组的slice方法toArray: function() &#123; return slice.call( this ); //这里就是可以将类数组转化为可以用原生数组的一个方法&#125;类数组转化为数组的方法不外乎两种：一种是slice，一种是concat。bind函数jQuery中的bind方法说到bind这里本篇的正题就到了，什么是bind？如果你用老版本的jQuery用的比较多你可能经常会这样写（jQuery1.7+之后是推荐用on来绑定事件的）：123$( \"#foo\" ).bind( \"click\", function() &#123; alert( \"User clicked on 'foo.'\" );&#125;);意思非常明确了，就是给id为foo的元素绑定click事件和一个匿名的回调函数。当然你也可以绑定多种类型的事件123$( \"#foo\" ).bind( \"mouseenter mouseleave\", function() &#123; $( this ).toggleClass( \"entered\" );&#125;);更详细的用法请参考jQuery官网的.bind()的API原生JavaScript中的bind方法还有一种是原生的bind函数，在ECMAScript5为Function.prototype添加了一些原生的扩展方法，其中就包括Function.prototype.bind。不信的话你可以在谷歌或者火狐下运行下下面的代码看看，IE就比较傻逼了，IE9+才支持bind方法。1console.log(Function.prototype.bind); //--&gt;bind() &#123; [native code] &#125;老式浏览器兼容bind的方法(来自MDN)：1234567891011121314151617181920212223if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== \"function\") &#123; //调用的不是函数的时候抛出类型错误 throw new TypeError(\"Function.prototype.bind() error\"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //缓存this，调用返回的函数时候会用到 fNOP = function () &#123;&#125;, fBound = function () &#123; //用闭包缓存了绑定时候赋予的参数，在调用的时候将绑定和调用的参数拼接起来 return fToBind.apply(this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;下面我们来看下JS原生bind的基本用法：123456789101112131415function foo() &#123; console.log(this.name); console.log(arguments);&#125;var obj = &#123; name: 'ManfredHu'&#125;//将foo绑定obj的作用域，返回一个绑定了作用域的新的函数var newFunc = foo.bind(obj, '我是参数1', '我是参数2'); newFunc(); //output:(最好自己试一下)//ManfredHu//Arguments[2] 0: \"我是参数1\" 1: \"我是参数2\"so，其实用法也很简单。原理简单说一下：bind将原来的函数copy了一份，并且绑定了copy副本的上下文。当然这里的上下文体现出来的就是this的指向了，而且后面就算你想改都改不了。1234567891011var obj = &#123;&#125;;function foo() &#123; return this;&#125;var foo2 = foo.bind(obj); //复制函数绑定上下文var obj2 = &#123;&#125;;obj2.foo2 = foo2;console.log(obj === foo2()); //--&gt;trueconsole.log(obj === window.foo2()); //--&gt;trueconsole.log(obj === obj2.foo2()); //--&gt;true这里尝试用window和obj2来改变函数运行的上下文，都没有成功。下面就是终结部分了，比较高能。某天闲逛时候看到了一篇很有趣的译文，起初看了下，有的地方没看的太懂，而且也赶着去做别的事，就先搁一边了，后面有空去看的时候发现这篇译文，或者说是代码。灰常犀利，不管是作用还是写法处处都将JS的动态特性体现得淋漓尽致。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var context = &#123; foo: \"bar\" &#125;;function returnFoo () &#123; //返回this.foo的简单函数 return this.foo;&#125;returnFoo(); //--&gt;undefined（因为window.foo不存在）var bound = returnFoo.bind(context); //用bind绑定函数上下文bound(); //--&gt;\"bar\"（因为上面被绑定了上下文了，这里输出context.foo）returnFoo.call(context); //--&gt; bar（call的基本用法）returnFoo.apply(context); //--&gt; barcontext.returnFoo = returnFoo; //将函数引用赋给context对象context.returnFoo(); //--&gt; bar（returnFoo函数里面的this是context）//----------------------------------------------------------------------- // 上面的应该都不会很难，下面是比较实用的部分，每一句都要看得懂之后才往下看//-----------------------------------------------------------------------[1,2,3].slice(0,1); //--&gt;[1]（简单的分割数组，比较麻烦是不是）var slice = Array.prototype.slice; //更简单的做法，将原型上的slice方法缓存到本地，方便快捷调用//因为没有绑定上下文，slice也不知道去截取哪个数组slice(0, 1); //--&gt; TypeError: can't convert undefined to object//同上，还是因为没有绑定上下文，slice也不知道去截取哪个数组slice([1,2,3], 0, 1); //--&gt; TypeError: ...//绑定了上下文，跟上面的[1,2,3].slice(0,1);一样，但是slice方法被封装起来了slice.call([1,2,3], 0, 1); //--&gt; [1]//跟上面差不多，只是换成了apply方法的调用，参数变成了数组的形式slice.apply([1,2,3], [0,1]); //--&gt; [1]//精髓的一句，上面的演进只是为了解释这一句而已，整个的思想就是“封装”，方便调用//就是将slice.call这句简写成slice一句就完成了//我们上面其实用的很多都是函数绑定对象，但是却忘记了其实JS函数也是对象，也可以被绑定//这里将slice当作对象，用call去绑定它，返回一个绑定了的函数，方便后面复用，也就是缓存的作用slice = Function.prototype.call.bind(Array.prototype.slice);//跟上面的slice.call([1,2,3], 0, 1);对比一下发现原来把call封装到slice里面去了slice([1,2,3], 0, 1); //--&gt; [1]//上面一句看懂了这句就很好懂了，bind.call省略为bind的意思var bind = Function.prototype.call.bind(Function.prototype.bind);//OK，经过我们的处理，slice和bind的功能都很厉害了//回到最初的例子var context = &#123; foo: \"bar\" &#125;;function returnFoo () &#123; return this.foo;&#125;//现在来使用神奇的\"bind\"函数//bind(function,context)//@function 待绑定上下文的函数//@context 绑定的上下文//@return 返回一个绑定了上下文的函数//按照以前的书写顺序是这样的:returnFoo.bind(context,[args1,args2……])//书写顺序完全改变了有木有？封装起来了有木有？var amazing = bind(returnFoo, context);amazing(); // --&gt; bar总结bind和call以及apply都可以动态改变函数执行的上下文，可以说很好地体现了JavaScript的动态特性JavaScript的动态特性远不止上面的eval(),call/apply,bind()这些多试着用这些东西，可以更好地理解JS这门语言，而且，代码会变得优雅，代码量复用的几率也会增大引用参考：MDN官方文档——Function.prototype.bind()张小俊128——Javascript中的Bind，Call和Apply","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"JavaScript中this关键字的使用比较","slug":"14-thisKeyWords","date":"2016-03-26T16:24:33.000Z","updated":"2017-03-13T15:41:59.000Z","comments":true,"path":"2016/03/27/14-thisKeyWords/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/14-thisKeyWords/","excerpt":"","text":"这篇是自己在之前的博客写的，各种转载就不说了。this关键字在JavaScript中，用的不能说比较多，而是非常多。那么熟悉this关键字的各种用法则显得非常关键。this有时候就是我们经常说的上下文，这个东西的指代对象。它灵活多变，有时候你看它是对象，有时候是window宿主对象。this指向宿主对象123456function myWindow() &#123; this.id = 1; // 等价于window.id = 1 console.log(this); // 这里的this就是window了 console.log(this.id); // 1&#125;myWindow();这种情况比较普遍，也就是指向宿主对象的情况，在客户端是 window对象 在node里是 Global对象 第一个说，下面看第二种。this指向调用函数的对象的时候1234567function myObj() &#123; console.log(this.x); // 在这个例子里面是obj对象&#125;var obj = &#123;&#125;;obj.x = \"xx\";obj.myObj = myObj;obj.myObj(); // xx这里的myObj()函数里面的 this 指向的就是obj这个外部传递来的对象了。注意看 obj.myObj() 这里前面的 obj. 这里，因为myObj是obj这个对象的方法，下面obj作为对象调用了myObj这个函数，所以这里的this就是指向调用函数的对象了。this指向构造函数生成的新对象的时候12345678910111213// 作为构造函数的函数记得首字母要大写function People(gender) &#123; this.gender = gender; this.sayGender = function() &#123; console.log(this.gender); &#125;&#125;// 输出man,函数this是新的People&#123;&#125;对象var girl = new People(\"women\"); // 输出women,函数this是指向girl&#123;gender:\"women\"&#125;对象girl.sayGender();这里的执行过程理一下，首先 new People(&quot;man&quot;) 这句做了几件事情：根据构造函数创建一个空的对象People{}然后传递到People里面（这里才叫开始构造的过程，添砖加瓦的意思）然后这里开始的函数里面的this就是指向传进来新的People{}对象了这里就是构造函数生成对象的一个简单的过程了，可以自己模拟着执行以下。this指向需要继承属性的对象的时候（apply和call）123456789101112function People(gender) &#123; this.gender = gender; this.sayGender = function() &#123; console.log(this.gender); &#125;&#125;var sally = new People(\"women\");var bob = &#123; // bob是直接量创建的,但是没有sayGender方法可以用 gender: \"man\";&#125;所以这里如果bob要用 sayGender() 方法的话要怎么破呢？这个时候就要用到 apply() 或者 call() 了，这两个方法差不多。apply(obj, arguments) 这里的arguments是一个参数数组call(obj,argument) 这里没有复数所以bob要调用 sayGender() 的话，就要用到 call() 方法或者 apply() 方法了。这个其实可以理解为继承的一种，Java里面继承分为实现继承跟接口继承两种，JavaScript的继承是只有实现继承的，但是实现继承JavaScript里面又有很多种，比如原型链继承，还有这里的 apply() 和 call() 也算是继承的一种。123456789101112131415function People(gender) &#123; this.gender = gender; this.sayGender = function(str) &#123; console.log(this.gender); &#125;&#125;var sally = new People(\"women\");var bob = &#123; // bob是直接量创建的,但是没有sayGender方法可以用 gender: \"man\";&#125;sally.sayGender(\"这是什么性别的？\"); // 这是什么性别的？womensally.sayGender.call(bob,\"这是什么性别的？\"); // 这是什么性别的？man这里最后一句代码的执行过程分析下：将bob{gender: “man”}这个对象传递到People里面更改函数里面this指向继续执行函数里面其他代码这里可以看出，bob这个对象继承要继承另外一个对象的某个方法的时候可以用上面这种写法 function.call(obj, argument)同时也可以知道，this在函数里面的指向其实是可以有很多种的，要根据不同的环境来判断。下面开始apply的例子，在开始 apply() 的例子之前先普及一下基本知识：首先普及下一个概念 类数组（array-like） ，类数组其实我们平时接触的很多的。比如函数里面的 arguments对象 ，注意这里说的是 arguments对象 而不是 arguments数组 。因为arguments不是一个数组而是一个对象，只是我们平时用的时候喜欢用 arguments[0] 这样的写法所以看起来像数组而已。类数组通常的定义就是 有维护一个length属性 和 可以根据数字下标来获取元素 比如 arguments[0] 这样的一个对象。不信的话我们可以测试下的：12345function arrayLike() &#123; console.log(arguments instaceof Array); // false console.log(arguments instaceof Object); // true&#125;arrayLike();其实JavaScript里面的数组对象叫 关联数组 ，也就是我们数据库表那样的 键-值对 组成的形式。所以你如果以为JavaScript可以像其他语言那样优化循环比如 for(var i=0; i&lt;100; i++) 这样的过程的话你就想多了。甚至，JavaScript的对象内部实现也是关联数组 ，比如你可以定义键为0而值为其他的对象。123456var obj = &#123; 0: \"12345\"&#125;var arr = [\"12345\"];console.log(obj[0]); // 12345console.log(arr[0]); // 12345有没有觉得JavaScript内部的实现其实很简单？或者可以说原理基本上就一个，但是通过简单的加点属性减点属性让对象跟数组看起来完全不一样。其实内部的实现原理是一模一样的。废话扯得有点多，下面看 apply() 方法的例子：1234567891011121314151617function People(gender) &#123; this.gender = gender; this.sayGender = function() &#123; var str = Array.prototype.join.call(arguments,\"\"); // arguments为类数组 console.log(str + this.gender); // &#125;&#125;var sally = new People(\"women\");var bob = &#123; gender: \"man\"&#125;var textArr = \"这是什么性别的？\".split(\"\"); // 这里将字符串分割为数组sally.sayGender.apply(bob, textArr); // 这是什么性别的？man大概就到这里吧，有兴趣的可以留言讨论下。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"15条规则解析JavaScript对象布局（__proto__、prototype、constructor）","slug":"13-proto-prototype-constructor","date":"2016-03-26T16:05:41.000Z","updated":"2017-02-10T17:22:54.000Z","comments":true,"path":"2016/03/27/13-proto-prototype-constructor/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/13-proto-prototype-constructor/","excerpt":"","text":"这篇是自己在之前的博客写的，各种转载就不说了。大家都说JavaScript的属性多，记不过来，各种结构复杂不易了解。确实JS是一门入门快提高难的语言，但是也有其他办法可以辅助记忆。下面就来讨论一下JS的一大难点-对象布局，究竟设计JS这门语言的人当时是怎么做的？设计完之后又变成了什么？原型、构造函数和实例三者的关系我们来看一张图：相信大家对这张图都不陌生了，构造函数有一个prototype属性指向其原型。相反原型也有一个constructor指向构造函数。与此同时实例也有一个constructor指向构造函数，这简直就是互相捆绑生怕找不到啊不是吗？还有一个我们称之为秘密链接的proto属性，原谅我第一眼见到这个属性就觉得特别的怪，_下划线都用上了，驼峰命名规则呢？好吧，这是部分浏览器暴露出来的一个指针而已，可能当时设计的时候随便写出来，突然发现这货有点用就留下了（纯属个人猜测）。附上上图的检测代码不信的童鞋可以自己玩玩：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;JS函数原型，函数，实例的关系证明&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; function Foo()&#123;&#125; //构造函数 var a = new Foo(); //实例 console.log(Foo===Foo.prototype.constructor); //true console.log(a.constructor===Foo); //true console.log(Foo.prototype===Foo.prototype); //true console.log(a.__proto__===Foo.prototype); //true&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;JavaScript Object Layout上面只是基础而已，下面才是真正的重点，为了修改这张图我可是煞费苦心，绞尽脑汁，不知道死了多少脑细胞。可能大家已经看晕了，没事冲杯咖啡慢慢看。下面是相应的证明代码，友情提示sublimeText看更爽：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;JavaScript对象布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; //以下代码全部为true console.log(\"1:\"+(Object.prototype.__proto__ === null)); console.log(\"2:\"+(Function.prototype.__proto__===Object.prototype)); console.log(\"3.1:\"+(Number.__proto__ === Function.prototype)); console.log(\"3.2:\"+(Boolean.__proto__ === Function.prototype)); console.log(\"3.3:\"+(String.__proto__ === Function.prototype)); console.log(\"3.4:\"+(Object.__proto__ === Function.prototype)); console.log(\"3.5:\"+(Function.__proto__ === Function.prototype)); console.log(\"3.6:\"+(Date.__proto__ === Function.prototype)); console.log(\"3.7:\"+(Error.__proto__ === Function.prototype)); console.log(\"3.8:\"+(Array.__proto__ === Function.prototype)); console.log(\"3.9:\"+(RegExp.__proto__ === Function.prototype)); console.log(\"4.1:\"+(Math.__proto__===Object.prototype)); console.log(\"4.2\"+(JSON.__proto__===Object.prototype)); function Foo()&#123;&#125; //构造函数 var f1 = new Foo(); //实例 console.log(\"5:\"+(Foo===Foo.prototype.constructor)); console.log(\"6.1:\"+(f1.__proto__===Foo.prototype)); console.log(\"7:\"+(f1.constructor===Foo)); console.log(\"8.1:\"+(Number.prototype.__proto__===Object.prototype)); console.log(\"8.2:\"+(Boolean.prototype.__proto__===Object.prototype)); console.log(\"8.3:\"+(String.prototype.__proto__===Object.prototype)); console.log(\"8.5:\"+(Function.prototype.__proto__===Object.prototype)); console.log(\"8.6:\"+(Date.prototype.__proto__===Object.prototype)); console.log(\"8.7:\"+(Error.prototype.__proto__===Object.prototype)); console.log(\"8.8:\"+(Array.prototype.__proto__===Object.prototype)); console.log(\"8.9:\"+(RegExp.prototype.__proto__===Object.prototype)); console.log(\"9:\"+(Foo.__proto__===Function.prototype)); var manfred = new Object();//实例对象 console.log(\"10:\"+(manfred.__proto__===Object.prototype)); console.log(\"11:\"+(Foo.prototype.__proto__===Object.prototype)); //manfred为object构造函数产生，manfred.constructor指向function Object()构造函数 console.log(\"12:\"+(manfred.constructor.__proto__===Function.prototype)); console.log(\"13:\"+(manfred.constructor===Object.prototype.constructor)); var hu = new Function(); console.log(\"14:\"+(hu.constructor.__proto__===Function.prototype)); console.log(\"15:\"+(hu.constructor===Function.prototype.constructor)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;相信看完这些代码和原图比较之后大家对JS对象之间的关系已经了如指掌了，确实一开始我也让这货搞得头晕晕的，但是画出这张图之后已经觉得没什么了。大家可以自己动手画一下。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"2015年阿里巴巴校招题目","slug":"10-AlibabaExamination","date":"2016-03-24T12:17:37.000Z","updated":"2017-02-10T17:26:12.000Z","comments":true,"path":"2016/03/24/10-AlibabaExamination/","link":"","permalink":"http://www.manfredhu.com/2016/03/24/10-AlibabaExamination/","excerpt":"","text":"以下题目是阿里巴巴2015校招的题目，纯粹个人恶趣味发作写着玩的。有错的地方欢迎联系交流^_^第一题1234567//第一题var array1 = [1,2];var array2 = array1;array1[0] = array2[1];array2.push(3);console.log(array1) //[2 2 3]console.log(array2) //[2 2 3]第二题12345678910111213//第二题function a(x, y) &#123; return function() &#123; y = function() &#123; x = 2; &#125;; var x = 3; y(); console.log(x); //2 &#125;.apply(this.arguments);&#125;a();第三题1234567891011//第三题var name = 'World!';(function() &#123; if(typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye' + name); //Goodbye Jack &#125;else&#123; console.log('Hello' + name); &#125;&#125;)();第四题1234567//第四题下面那些语句的结果是trueFunction instanceof Object //trueObject instanceof Function //truetypeof Object.prototype === 'object' //truetypeof Function.prototype === 'object' //false第五题1234567//第五题一个页面存在A元素和B元素;B元素浮在A元素之上;在B元素上绑定了touchstart事件，在touchstart事件处理函数中的哪些操作会导致A元素触发click事件？（这里是HTML5的点击穿透BUG，click事件会在touchstart和touchend后面发生，所以如果在touchstart将B元素移除则A元素会受到click触发）A.设置B元素CSS属性display为none //YesB.设置B元素CSS颜色C.将B元素从DOM树上删除 //YesD.设置B元素CSS属性visibility为hidden第六题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//第六题编写一个javascript函数，可以在页面上异步加载js,在加载结束后执行callback，并在IE和Chrome下都能执行//方法一function loadScript(url,callback) &#123; //兼容IE和Chrome获取XMLHttpRequest对象 var xhr = (function() &#123; if(window.XMLHttpRequest) &#123; return new XMLHttpRequest(); &#125;else if(window.ActiveXObject) &#123; return new ActiveXObject('Microsoft.XMLHTTP'); &#125;else&#123; throw new Error(\"loadScript():XMLHttpRequest Init Error\"); &#125; &#125;)(); xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4) &#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123; callback(); &#125; &#125; &#125; //用GET方式异步加载JavaScript代码 xhr.open('GET',url,true); xhr.send(null);&#125;//方法二function loadScript(url, callback) &#123; //同步 var script = document.createElement(\"script\"); script.type = \"text/javascript\"; if (script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if (script.readyState == \"loaded\" || script.readyState == \"complete\") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function() &#123; callback(); &#125;; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125;第七题1234567891011121314151617181920212223//第七题//为字符串实现一个render方法，实现下面的变量替换功能(function() &#123; String.prototype.render = renderFunc; function renderFunc(obj) &#123; if(typeof obj !== 'object') throw new Error('The arguments must be obj'); return this.replace(/\\$\\&#123;([^&#125;]+)\\&#125;/gi, function(a, b) &#123; //这里的a是 $&#123;name&#125; //b是name return obj[b] ? obj[b] : ''; &#125;); &#125; var greeting = 'my name is $&#123;name&#125;,age $&#123;age&#125;'; var result = greeting.render(&#123; name: 'XiaoMing', age: 11 &#125;); console.log(result); //my name is XiaoMing,age 11&#125;)();第八题12345678910111213141516171819202122232425262728//第八题//用JS实现随机选取10-100之间的不同的10个数字，存入一个数组并降序排序(function() &#123; function creatNumber(num) &#123; if(typeof num !== 'number') return; var arr = []; for (var i = 0; i &lt; num; i++) &#123; arr.push(parseInt(Math.random() * 90 + 10)); &#125; return arr; &#125; //降序排列 function sortOrder(a,b) &#123; return b-a; &#125; function getIsArray() &#123; return Array.isArray ? Array.isArray : function(arr) &#123; return Object.prototype.toString.call(arr).slice(8, -1) === 'Array'; &#125; &#125; var arr = creatNumber(10); var isArray = getIsArray(); if(!isArray(arr)) throw new Error(\"init Array Error\"); console.log(arr.sort(sortOrder));&#125;)();","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"Canvas一般用法","slug":"9-Canvas","date":"2016-03-10T12:54:38.000Z","updated":"2016-12-02T17:42:04.000Z","comments":true,"path":"2016/03/10/9-Canvas/","link":"","permalink":"http://www.manfredhu.com/2016/03/10/9-Canvas/","excerpt":"","text":"what is CanvasCanvas是HTML5的绘图接口，可以提供用JavaScript绘制位图的功能。APICanvas的API众多，这里举几个常用的。(好久没看都快忘了。。。)1.beginPath() 让canvas根据需要计算图形的内部和外部范围，通常在绘图开始会有2.moveTo(),lineTo() 移动和画线函数，但是不会马上绘制(paint)3.stroke(绘制)和fill(填充)会马上绘制图形显示出来4.lineWidth可以改变线条宽度5.strokeStyle可以改变绘制颜色缓存Canvas成数据用canvas.toDataURL(type)可以获取data URL格式的Canvas数据DEMO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function createCanopyPath(context) &#123; //绘制树 context.beginPath(); context.moveTo(-25, -50); context.lineTo(-10, -80); context.lineTo(-20, -80); context.lineTo(-5, -110); context.lineTo(-15, -110); context.lineTo(0, -140); context.lineTo(15, -110); context.lineTo(5, -110); context.lineTo(20, -80); context.lineTo(10, -80); context.lineTo(25, -50); context.closePath();&#125;function drawTrails() &#123; var canvas = document.getElementById('trails'); var context = canvas.getContext('2d'); context.save(); //移动画布 context.translate(130, 250); //绘制树的上半部分 createCanopyPath(context); //线条宽度 context.lineWidth = 4; //拐角显得平滑 context.lineJoin = 'round'; //设置颜色并且绘制 context.strokeStyle = '#663300'; context.stroke(); //填充颜色 context.fillStyle = '#339900'; context.fill(); context.fillStyle = '#663300'; context.fillRect(-5, -50, 10, 50); //恢复初始状态 context.restore(); // Save the canvas state and draw the path context.save(); context.translate(-10, 350); context.beginPath(); // The first curve bends up and right context.moveTo(0, 0); //绘制曲线 context.quadraticCurveTo(170, -50, 260, -190); // The second curve continues down and right context.quadraticCurveTo(310, -250, 410,-250); // Draw the path in a wide brown stroke context.strokeStyle = '#663300'; context.lineWidth = 20; context.stroke(); // Restore the previous canvas state context.restore();&#125;window.addEventListener(\"load\", drawTrails, true);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"Canvas","slug":"笔记/Canvas","permalink":"http://www.manfredhu.com/categories/笔记/Canvas/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"Canvas","slug":"Canvas","permalink":"http://www.manfredhu.com/tags/Canvas/"}]},{"title":"string.Replace用法","slug":"8-stringReplace","date":"2016-03-06T02:45:26.000Z","updated":"2017-02-10T18:04:01.000Z","comments":true,"path":"2016/03/06/8-stringReplace/","link":"","permalink":"http://www.manfredhu.com/2016/03/06/8-stringReplace/","excerpt":"","text":"replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。基本用法12var str=\"Manfred Hu\"document.write(str.replace(/Manfred/, \"WenFeng\")); //页面输出WenFeng Hu这是比较基本的用法，还有一种是第二个参数不是&quot;WenFeng&quot;而是一个函数的时候。第二种用法123456789101112131415161718192021//define(function(window)&#123; //构造函数fn function fn(str)&#123; this.str=str; &#125; fn.prototype.format = function()&#123; var arg = arguments; return this.str.replace(/\\&#123;(\\d+)\\&#125;/ig,function(a,b)&#123; return arg[b]||\"\"; &#125;); &#125; window.fn = fn;&#125;)(window);//use(function()&#123; var t = new fn('&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;'); //类似参数化的输出 console.log(t.format('http://www.alibaba.com','Alibaba','Welcome')); //&lt;p&gt;&lt;a href=\"http://www.alibaba.com\"&gt;Alibaba&lt;/a&gt;&lt;span&gt;Welcome&lt;/span&gt;&lt;/p&gt;&#125;)();你可以能会奇怪这里a和b到底是什么。分析下：两个都是立即执行函数，所以顺序执行先定义后执行。fn.prototype.format是添加在原型的方法，可以让所有实例共享，然后向全局环境window挂载fnfn是全局的构造函数，下面一个立即执行函数创建了一个实例，传入字符串为参数，然后用console.log()输出调用format的结果format函数执行，传入三个参数。到了原型的format函数的执行arg为arguments[3],是上面传来的三个参数。this为var t = new fn(&#39;&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;&#39;);的t因为正则式有ignore和global，所以可以全局匹配并且忽略大小写。重点来了这里的a是匹配串，b是捕获串，返回值会用来替换匹配串这里记录下程序执行过程。a为{0},b为0。返回值为arg[0]就是http://www.alibaba.com因为是全局匹配，所以有第二次替换匹配串。a为{1},b为1。返回值为arg[0]就是Alibaba省略replace后面是function的用法比较少见，有第二个参数的就更少见了。这里顺手输出了replace中function的arguments来看看。12arguments[\"&#123;1&#125;\", \"1\", 17, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"]总结API：stringObject.replace(regexp/substr,replacement)所以replacement这个function有四个参数，分别是匹配串捕获串匹配串(这里是从’{‘开始)在 stringObject 中出现的位置原来的字符串注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"}]},{"title":"常见数据结构算法","slug":"7-dataStructure","date":"2016-03-04T14:57:08.000Z","updated":"2016-03-04T16:01:32.000Z","comments":true,"path":"2016/03/04/7-dataStructure/","link":"","permalink":"http://www.manfredhu.com/2016/03/04/7-dataStructure/","excerpt":"","text":"前言数据结构的重要性就不多说了，一名合格的程序猿/媛，必修的科目。这里列举常见的前端开发面试会遇到的数据结构面试题，好像基本都是要手写代码的。这里的代码不限制于javascript语言，默认升序排列，有特别的地方会指出来。冒泡排序[稳定 平均O(n^2)，最好O(n)，最坏O(n^2)]12345678910function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; swap(arr[j + 1], arr[j]); &#125; &#125; &#125;&#125;选择排序[稳定 平均最好最坏都为O(n^2)]123456789101112function selectSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; var min = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr[min], arr[i]); &#125;&#125;快速排序[不稳定 平均最好O(nlogn),最坏O(n^2) 需要辅助空间]123456789101112131415161718function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1); var left = [], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(pivot, quickSort(right));&#125;二分查找[logn]12345678910111213141516function binarySearch(arr, key) &#123; var low = 0, high = arr.length, middle; while (low &lt; high) &#123; middle = Math.floor((low + high) / 2); if (key === arr[middle]) &#123; return key; &#125; else if (key &lt; arr[middle]) &#123; high = middle - 1; &#125; else if (key &gt; arr[middle]) &#123; low = middle + 1; &#125; &#125; return -1;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"数据结构","slug":"笔记/数据结构","permalink":"http://www.manfredhu.com/categories/笔记/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.manfredhu.com/tags/数据结构/"}]},{"title":"javascript-closure","slug":"6-javascript-closure","date":"2016-01-22T15:56:19.000Z","updated":"2017-01-15T15:32:47.000Z","comments":true,"path":"2016/01/22/6-javascript-closure/","link":"","permalink":"http://www.manfredhu.com/2016/01/22/6-javascript-closure/","excerpt":"","text":"词法作用域（Lexical scoping）、声明上下文对象（Declaration context object）说到变量，我们会关注变量的两个东西。作用域-空间来理解变量的存在生命周期-时间来理解变量的存在变量的词法作用域是指在程序源代码定义的这个变量的区域。通常分为函数和全局两部分。12345var scope = \"global\"; //全局作用域function func() &#123; var scope = \"local\"; //函数作用域，只在这个函数内存活 return scope;&#125;那如果换成下面这样的呢？12345678910var scope = \"global\"; //全局作用域function checkscope()&#123; var scope = 'local'; //外层函数的作用域 function nested() &#123; var scope = 'nested'; //内层函数的作用域 return scope; &#125; return nested();&#125;console.log(checkscope()); //nested结论：当代码被编译器读取，词法作用域就已经确定了而这跟下面的变量作用域和闭包又会有关联,词法作用域到函数执行时依然是有效的。浏览器提前做好了大部分的工作，所以JS很快，so fast!!编译过程干了什么？传统的编译器会干这些东西词法分析过程，将代码读取并且扫描代码，分解成一个一个的词语法分析过程，分解语法短语构造语法树语义分析过程，审查代码是否有错，收集各个阶段类型的信息代码优化过程，对中间代码进行优化，使其更加高效生成目标代码，即二进制的本地代码具体到浏览器的引擎，也不外乎是这几个过程。我们能明显感受到的就是下面几个过程。声明函数、变量——声明提升检查代码，优化——代码执行效率大大提高，有ERROR上面两个过程，很明显可以体会到上面1-4步的过程。而最后一步，学过计算机的都懂的。我们来看下面的代码体会下编译过程干的事情——声明提升123456var scope = \"global\";function f() &#123; console.log(scope); //undefined var scope = \"local\"; console.log(scope); //local&#125;这段代码跟下面是等价的，只是下面的看起来更清晰,编译器干的事情也更少。1234567var scope = \"global\";function f() &#123; var scope; console.log(scope); //undefined scope = \"local\"; console.log(scope); //local&#125;变量的作用域和生命周期JS中变量的生命周期跟函数有关，函数内定义的变量在函数执行结束后会释放。JS中变量的作用域也跟函数有关，内层函数可以随作用域链访问外层函数的变量。具体原因就是作用域链的存在。所以你不难看出，为什么JS里面函数非常非常重要，也许你应该听过了：JavaScript的世界里函数是一等公民正正因为你用的变量的生命周期和作用域都跟函数有关。你平常是否想到了呢？但是闭包是个bug，它为你提供了破坏这种已定规则的限制。为你的代码提供无限可能，这也许就是JavaScript真正的魅力所在，它让一切变得可能。函数如果嵌套的话，随作用域链来定，如果作用域链上没有则访问不到。会出现ReferenceError执行环境（execution context）、作用域链（scope chain）的创建上面都是程序还没运行的时候干的事情，下面来说下程序运行起来会发生什么。当JavaScript在运行的时候，也就是某个函数被调用时，会创建一个执行环境（execution context），以及相应的作用域链。然后使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)，也有称为作用域对象（scope object）的。这东西你摸不到看不见，但是它却真正存在着——就像真理活动对象（activation object）、作用域对象（scope object）当我们的代码有多个函数嵌套的时候，一个个作用域对象就被串联起来形成作用域链（Scope chain）闭包我至少见过N种定义闭包概念的版本，让我们来欣赏一下：函数对象可以通过作用域相互关联，函数体内部的变量可以保存在函数作用域内这种观点引申出来的就是，所有JavaScript函数都是闭包。因为它们都是对象，都关联到作用域链。函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量包裹起来了这是从计算机科学文献中引申出来的闭包的解释。闭包是指有权访问另一个函数作用域中的变量的函数这是《JavaScript高级程序设计第三版》的定义。也就是说至少需要2个函数才能构成闭包闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。这是MDN的解释。闭包由两部分构成：函数以及创建改函数的环境环境由闭包创建时在作用域中的任何局部变量组成。现在觉得，上面说的其实都有道理。特别是第二个和第三个解释,所以我觉得最最准确描述就是下面两句了。闭包是指有权访问另一个函数作用域中的变量的函数","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"}]},{"title":"Object.defineProperties的实际作用（MEAN开发Model层的写法）","slug":"5-MEANdevelop-ModelProblem","date":"2016-01-21T06:43:50.000Z","updated":"2016-03-10T15:04:24.000Z","comments":true,"path":"2016/01/21/5-MEANdevelop-ModelProblem/","link":"","permalink":"http://www.manfredhu.com/2016/01/21/5-MEANdevelop-ModelProblem/","excerpt":"","text":"Object.defineProperties是什么？有什么用？这个问题比较听起来可能比较难以理解，确实我也是在项目中遇到的才会去想。以前看到《高级程序设计》的时候，有这么一种东西，定义一个对象。大概第几章忘了，看下下面的代码估计能想起来是什么。12345678910111213141516171819202122232425262728293031var User = &#123;&#125;; //声明一个空对象Object.defineProperties(User, &#123; //填充对象属性 _id: &#123; writable: true, //设置属性是否可写，默认为true configurable: false, //设置属性是否可以配置，默认为true。当设置为false时不能用delete删除 enumerable: false, //设置属性是否可以枚举，默认为true.即for-in循环对象的时候可以输出属性 value: 0 //默认值 &#125;, id: &#123; set: function(value) &#123; if(value &gt; 0) &#123; this._id = value; //数据库设置的为主键从0开始递增 &#125; &#125;, get: function() &#123; return this._id; &#125; &#125;&#125;);var privateId = Object.getOwnPropertyDescriptor(User, '_id');console.log(privateId.value); //0var userId = Object.getOwnPropertyDescriptor(User, 'id');console.log(userId.get()); //还没设置呢，输出undefineduserId.set(10); //设置id为10console.log(userId.get()); //输出10，设置有效userId.set(-10);console.log(userId.get()); //输出10，设置无效大概就是Object.defineProperties这个东西吧，可以定义属性。定义一个属性用的是Object.defineProperty。不过通常对象都是多个属性的啦，所以基本用的都是Object.defineProperties。其实刚开始我看到这个属性觉得——嗯，有这个东西。但是具体哪里会用到，有什么作用，还真的没去思考太多。只是知道有这个东西，但是普通的前端开发，貌似也没怎么用到这个东西，直到——做项目的时候遇到了-_-!!MEAN开发Model层的写法副标题扯到MEAN开发了，之前做的项目里面，前端用的是AngularJS，后台用的是ExpressJS+node.js数据交互不用想都知道是Ajax啦。所以从第一天开始就开开心心撸代码啦，嗯，差不多就这样。^_^写后台的时候遇到了几个坑爹的问题吧，首先是登陆模块。AngularJS用$httppost到/loginData一个表单到后台比如是下面这样的1234var json = &#123; username: \"ManfredHu\", password: \"123456\"&#125;;后台用ExpressJS的路由监听这个URI12345app.post('/loginData', function(req, res) &#123; console.log(\"接受到login页面的登陆信息\"); //调用login控制器传入req,res UserCtrl.login(req, res);&#125;);这个ExpressJS的路由其实类似JavaWeb里面的web.xml那个配置servlet的东西。就是一个请求过来，你到底要调用哪个Controller到处理。这里专门为User写了个Controller取名UserCtrl，通过CMD的形式组织，exports暴露了一个login的方法专门处理request/response。然后问题就坑爹了，前端数据的验证怎么做？如果直接将JSON传入Dao层执行数据库的查找等等的匹配操作。那么其实问题其实还挺大的，你要考虑如果有人专门来POST数据测试你的服务器呢？当然我相信大家都是好人不会去干这种事，不过从安全性来讲，应该是要有一层验证的，而且后面的Dao层也会接受一个对象去执行增删查改等等操作这里讲的是后台的数据验证所以上面的Object.defineProperties就派上用场了，应该要将这个json组装成一个Model，且这个Model应该有类似C#、Java一样的私有属性private、公有方法public等等。C#的属性的概念其实相比字段就是多了一层过滤层，因为属性都是合法的字段。123456789101112131415public class Student &#123; private string name; //字段 public string Name //属性 &#123; set &#123; name=value; //这里是给私有属性name赋值 &#125; get &#123; return name; //这里取出私有属性name的值 &#125; &#125; &#125;Java的类似，不过没有C#属性的概念，所有的都称为方法。123456789public class Student &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;所以其实JavaScript要模仿这些传统的后台，也要有一个类似类的概念的东西——Object.defineProperties上面的代码类似声明了一个类，定义了私有的属性_id,公有的方法id,里面有set和get方法。那其实思路就变得很简单了，将POST的JSON数据包装成Model（这个过程会检验属性的正确性），然后对Model进行DAO操作。JavaScript模拟传统后台的东西就完全出来了。当然其实这部分包装成Model的过程完全可以不考虑，但是验证的过程你要写在Controller或者其他地方，既然都要写的，那还不如像传统后台一样多一层Model层。而且运行node.js的Chrome的V8解析器完全可以忽略Object.defineProperties的兼容性问题。综上所述,Object.defineProperties在开发后台的时候，用处非常大。可以用来创建实体类。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"AngularJS笔记","slug":"4-angular-note","date":"2016-01-20T05:00:38.000Z","updated":"2017-05-24T13:20:08.000Z","comments":true,"path":"2016/01/20/4-angular-note/","link":"","permalink":"http://www.manfredhu.com/2016/01/20/4-angular-note/","excerpt":"","text":"AngularJS兼容性1.3.0版本放弃了IE8（官网有兼容的方法）引入了单向数据绑定AngularJS的MVVM的原理与传统的MVC不同，这里的view不是jsp或者aspx之类的。M也不一样，这里是ViewModel。AngularJS通过Binder/Data-binding engine(通常称为Binder)将模板Template与ViewModel关联起来且通过dirty-checking来实现实时的更新指令的执行过程加载阶段从angular.js下载到客户端开始执行进入引导阶段，AngularJS会初始化自身需要的组件，查看ng-app边界，然后加载模块，使用依赖注入来注入依赖。编译阶段(compile)编译阶段模板将被搜索指令，然后指令会链接到AngularJS内置库或自定义指令代码相应的部分上。指令detective与作用域scope相结合产生实时视图。链接阶段(link)当引导和编译阶段完成之后，AngularJS进入运行时数据绑定阶段。这个阶段的特点是任何在作用域的更改都会反映在视图上，并且视图的更改也会更新到作用域。也称为双向绑定。AngularJS的MVVM是借助$scope实现的$scope有事件机制，如$emit(“EventName”)向上传播和$broadcast(“EventName”)向下传播$scope是一个普通的JS对象（POJO—-plain old javascript object普通JS对象）$scope提供了一些工具方法 $watch() / $apply()$scope是表达式的执行环境（或者叫作用域）$scope是一个平行DOM结构的树形结构的对象子$scope对象会继承父$scope上的属性和方法每个应用都有且只有一个rootScope的对象，通常是在 ng-app 上这样子层标签就可以继承父级标签的方法（个人猜测$scope是挂载在DOM结构的一组JS对象，映射关- 系，与jQ的data数据缓存原理类似）Angular默认的请求头12Accept: application/json,text/plain,X-Requested-With: XMLHttpRequest设置请求头的第一种方法，如果想把请求头设置到每一个发送出去的请求上，则可以将其设置为AngularJS的默认值，可以通过$httpProvider.defaults.headers配置对象来设置123456angular.module('MyApp',[]).config(function($httpProvider) &#123; //删除AngularJS默认的X-Request-With头 delete $httpProvider.default.headers.common['X-Requested-With']; //为所有GET请求设置DO NOT TRACK $httpProvider.default.headers.get['DNT'] = '1';&#125;);第二种方法是不将其作为默认值，则可以将头信息作为配置对象的一部分传递给$http服务Angular转换请求和响应转换请求如果请求的配置对象属性中包含JS对象，那么就把这个对象序列化成JSON格式转换响应如果检测到了XSRF（Cross Site Request Forgery）跨站请求伪造，则直接丢弃，如果检测到了JSON响应，则使用JSON解析器对其进行反序列化如果想自定义转换规则则设置transformRequest和transformResponse作为key来配置转换函数12345678var module = angular.module('myApp');module.config(function($httpProvider)&#123; $httpProvider.defaults.transformRequest = function(data) &#123; //使用jQuery的param方法 //把JSON数据转化成字符串形式 return $.param(data); &#125;&#125;);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"AngularJS","slug":"笔记/AngularJS","permalink":"http://www.manfredhu.com/categories/笔记/AngularJS/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"AnuglarJS","slug":"AnuglarJS","permalink":"http://www.manfredhu.com/tags/AnuglarJS/"}]},{"title":"CSS笔记","slug":"3-CSS-note","date":"2016-01-17T12:27:02.000Z","updated":"2017-02-10T18:05:31.000Z","comments":true,"path":"2016/01/17/3-CSS-note/","link":"","permalink":"http://www.manfredhu.com/2016/01/17/3-CSS-note/","excerpt":"","text":"清除浮动老生常谈的话题，面试经常问的问题解决方法有很多种，这里讲几种子元素加clear1234&lt;div class=\"news\"&gt; &lt;p&gt;Some Text&lt;/p&gt; &lt;br class=\"clear\"&gt;&lt;/div&gt;12345678910.news&#123; background: gray; border: solid 1px black;&#125;.news p&#123; float: right;&#125;.clear&#123; clear: both;&#125;这种方法可以扩展出很多种不同的方法，如JS动态添加，设置一个公共的类然后添加，或者直接就是一段内联style的html代码，但是原理都是用到了clear这个属性父元素BFC化HTML文档流是盒子模型的，BFC就是组织盒子模型的形式，当元素的类型如标签(p和span)不一样的时候，其表现出来的样子是不一样的。所以BFC就是让这个元素看起来像盒子的一种代称，BFC全称 Box Formatting Context。CSS2.1还有IFC,即Inline Formatting Context。BFC布局规则：内部的Box会在垂直方向，一个接一个地放置Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此BFC的区域不会与float box重叠BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此计算BFC的高度时，浮动元素也参与计算产生BFC的条件：当然普通的块级元素默认呈现块级的样子，但是通过CSS我们可以可以让某些元素呈现BFC的形态（块级形态）根元素(html元素)float不为none的元素(包括left,right,inherit三个，因为float只有四个值)position为absolute或fixeddisplay为inline-block,table-cell,table-caption,flex,inline-flexoverflow不为visible(包括hidden,scroll,auto,inherit四个值)如下面的为在父元素加float属性使其BFC化1234&lt;div class=\"news\"&gt; &lt;p&gt;Some Text&lt;/p&gt; &lt;br class=\"clear\"&gt;&lt;/div&gt;12345678910.news&#123; background: gray; border: solid 1px black;&#125;.news p&#123; float: right;&#125;.clear&#123; clear: both;&#125;透明度opacityopacity属性是CSS3新增的属性，取值为0.0(完全透明)到1.0(完全不透明)，后代元素也会一起被影响12345p&#123; filter: alpha(opacity=80); /*IE5-7，注意这里取值80*/ opacity: 0.8; /*IE8+*/ color: #000;&#125;RGBARGBA是扩展透明度的一种格式，a代表alpha透明度。IE9+支持RGBA写法。1234p&#123; background-color: rgba(0,0,0,0.8); /*取值0-1*/ color: #fff;&#125;RGBA与opacity的区别是：opacity会影响整个元素，而RGBA影响单一的属性。PNG图片的问题png图片的最大优势是支持alpha透明度，但是IE6不直接支持PNG透明度，PNG透明度自IE7才支持。好的是现在已经逐渐淘汰了IE6，拥有布局的问题默认拥有布局的元素：body/htmltable/tr/tdimghrinput/select/textarea/buttoniframe/embed/object/applet/marquee所以其实div和span是没有布局的。设置以下CSS属性会让元素获得布局。float: left/rightdisplay: inline-blockwidth/heightzoom: 任何值（只有IE）IE7中以下属性也触发布局(下面三个属性只有IE7+才支持)overflow: hidden/scroll/automin-width: 任何值max-width: 除none之外的任何值条件注释lt &lt;lte &lt;=gt &gt;gte &gt;=条件注释写法如下，这里的是XHTML写法，所以后面会以/&gt;结尾，HTML5写法最好是没有反斜杠1234567891011&lt;!-- [if IE 6]&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/ie6.css\" /&gt;&lt;![endif]--&gt;&lt;!-- [if !IE 6]&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/ie6.css\" /&gt;&lt;![endif]--&gt;&lt;!-- [if gte IE 6]&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/ie6.css\" /&gt;&lt;![endif]--&gt;IE常见的BUG及其解决方法下面这些BUG都是很有代表性的，在我做的项目中下面的bug基本都遇到了。-_-!!这运气真不是一般好。当然现在说起IE6兼容很多人可能会嗤之以鼻，但是我觉得在天朝大国这个连学校都在用着XP的地方，身为一名合格的前端，IE6兼容必须要过关。双外边距浮动BUG在元素有外边距且浮动的时候1234div.someone&#123; float: left; margin-left: 20px;&#125;解决方法对float的元素设置display:inline12345div.someone&#123; float: left; margin-left: 20px; display: inline;&#125;3像素文本偏移bug当文本与一个浮动元素相邻时这个bug有可能出现1234567div.myFloat&#123; float: left; width:200px;&#125;p&#123; margin-left:200px;&#125;解决方法(IE6以上)1234567p&#123; height: 1%; /*拥有布局*/ margin-left: 0;&#125;.myFloat&#123; margin-left: -3px; /*重要的一句，等于左边的浮动元素的宽度缩小了3px*/&#125;IE6的重复字符bug当一系列浮动元素排列在一排，如果最后的元素重复出现则是这个bug。ps：通常是代码有添加注释的情况解决方法运用负外边距清除注释IE6的“躲猫猫”bug当一个浮动元素后面跟着一些非浮动元素，然后是一个清理元素，所有这些元素包含在一个设置了背景颜色或图像的父元素中。如果清理元素碰到了浮动元素，那么中间的非浮动元素看起来像消失了，只有在刷新页面的时候才出现。解决方法去掉父元素上的背景颜色或图像避免清理元素与浮动元素接触容器指定行高将浮动元素和容器元素的position属性设置为relative","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"CSS","slug":"笔记/CSS","permalink":"http://www.manfredhu.com/categories/笔记/CSS/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"http://www.manfredhu.com/tags/CSS/"}]},{"title":"到了HTML5时代写HTML代码要注意的东西","slug":"2-someAboutHTML5","date":"2016-01-17T11:16:21.000Z","updated":"2017-02-10T18:05:57.000Z","comments":true,"path":"2016/01/17/2-someAboutHTML5/","link":"","permalink":"http://www.manfredhu.com/2016/01/17/2-someAboutHTML5/","excerpt":"","text":"DOCTYPE这是一个写在HTML头部的东西，浏览器会根据不同的DOCTYPE来识别不同的模式，后面的渲染和优化也会不一样，作为一个前端我们会严格要求自己。所以通常会copy一下的是不是^_^。但是在Eclipse中默认的不是HTML5的DOCTYPE,切记切记改过来噢亲。常见的DOCTYPE有1.HTML 4.01 Strict1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;2.XHTML 1.0 Strict12&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;标签不再自闭合如果你从XHTML开始严格要求自己，你会经常写这样的代码1&lt;input type=\"text\" placeholder=\"请输入作者……\" id=\"writer\" name=\"writer\" /&gt;本来这应该是没错的，但是如果转到HTML5时代的话，后面的/&gt;变成&gt;会更好。自己有时候也没意识过来，在XHTML时代这种叫自闭合标签，但是在HTML5时代，不需要了。字符编码不用写那么长了还有的，如charset也不用像下面这样写了。1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"&gt;取而代之的是下面这样简便的写法1&lt;meta charset=\"utf-8\"&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"HTML","slug":"笔记/HTML","permalink":"http://www.manfredhu.com/categories/笔记/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://www.manfredhu.com/tags/HTML/"},{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"}]},{"title":"博客园博客已迁移到此","slug":"1-firstArchive","date":"2016-01-17T11:16:10.000Z","updated":"2017-05-24T13:38:33.000Z","comments":true,"path":"2016/01/17/1-firstArchive/","link":"","permalink":"http://www.manfredhu.com/2016/01/17/1-firstArchive/","excerpt":"","text":"欢迎您来到我的新博客，我是ManfredHu.原博客园的博主，博客园博客已停止使用以后全部文章更新会转移到这个博客。谢谢大家观看！！^_^哈哈哈","categories":[],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://www.manfredhu.com/tags/杂文/"}]}]}