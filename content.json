{"meta":{"title":"ManfredHu胡文峰的个人博客","subtitle":null,"description":"Stay hungry, stay foolish. Keep looking, don't settle.","author":"ManfredHu","url":"http://www.manfredhu.com"},"pages":[{"title":"","date":"2017-02-10T17:13:32.000Z","updated":"2016-03-26T19:16:40.000Z","comments":true,"path":"404.html","permalink":"http://www.manfredhu.com/404.html","excerpt":"","text":"404"},{"title":"","date":"2017-02-10T17:13:32.000Z","updated":"2016-03-26T18:34:06.000Z","comments":true,"path":"baidu_verify_KNYdPFyuaj.html","permalink":"http://www.manfredhu.com/baidu_verify_KNYdPFyuaj.html","excerpt":"","text":"KNYdPFyuaj"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2016-11-10T07:11:10.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.manfredhu.com/categories/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2016-11-10T07:11:10.000Z","comments":true,"path":"archives/index.html","permalink":"http://www.manfredhu.com/archives/index.html","excerpt":"","text":""},{"title":"About Me","date":"2017-04-25T18:19:57.000Z","updated":"2017-04-25T18:19:57.000Z","comments":true,"path":"about/index.html","permalink":"http://www.manfredhu.com/about/index.html","excerpt":"","text":"Name Nickname: manfredhu Rtx: pphu Chinese Name: 胡文峰 SchoolGDUT(Guangdong University of Technology)，广东工业大学 Origin PlaceGuangdong，Shanwei，宇宙银河系太阳系地球亚洲中国广东省汕尾市 Job现就职Tencent腾讯深圳总部，担任Web前端开发工程师 Contact QQ: 279331641 E-mail: 279331641@qq.com Wechat: id为hwf_pp或者扫描下面二维码 推荐如有意加入腾讯这个大家庭，请留言并将简历投递到我的邮箱 :)"},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2016-11-10T07:11:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.manfredhu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS的rem单位","slug":"26-rem","date":"2017-05-06T13:43:19.000Z","updated":"2017-05-09T15:16:36.000Z","comments":true,"path":"2017/05/06/26-rem/","link":"","permalink":"http://www.manfredhu.com/2017/05/06/26-rem/","excerpt":"","text":"改变font-size来进行自适应rem 这个属性，通过在 html 元素设置一个初始大小，然后全部单位用 rem 来计算，则页面自适应。 兼容性现在大部分浏览器IE9+，Firefox、Chrome、Safari、Opera ，如果我们不修改相关的字体配置，都是默认显示 font-size是16px 即： 123html &#123;font-size:16px;&#125; 则设置了 &lt;html&gt; 之后，后面的大小样式会这样写，如 12345678910111213141516171819202122232425262728293031323334p &#123;font-size: 0.75rem; //12÷16=0.75（rem）&#125;所以你很容易想到，根据屏幕宽度和高度来动态改变 `&lt;html&gt;` 的 `font-size` 的大小，那么页面的大小也随之变化了。# 结合JS做自适应布局下面是一段做自适应布局的JS脚本```js/*** 判断用户client width* 然后给html设置一个font-size* 目的是为了方便rem做自适应布局*/(function (doc, win) &#123; var docEl = doc.documentElement, //判断是横竖屏 resizeEvt = 'orientationchange' in window ? 'orientationchange':'resize', func = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; //按照比例缩放 var docElWidth = 100 * (clientWidth / 320); //最大值 if (docElWidth &gt; 200) docElWidth = 200; // console.log(docElWidth); docEl.style.fontSize = docElWidth + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, func, false); doc.addEventListener('DOMContentLoaded', func, false);&#125;)(document, window);","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.manfredhu.com/tags/CSS/"}]},{"title":"JS正则终极篇","slug":"25-js-regexp","date":"2017-03-21T13:50:52.000Z","updated":"2017-04-05T13:43:43.000Z","comments":true,"path":"2017/03/21/25-js-regexp/","link":"","permalink":"http://www.manfredhu.com/2017/03/21/25-js-regexp/","excerpt":"","text":"香港有一个叫郑则仕的演员，就是上面这个了，每次我打正则式，都是联想的他的名字。 从开始学习正则到逐渐熟悉，偶尔不用经常会忘记。常常要翻出来查着用，遇到高深的用法常常不知所措，如果你也是这样，那就快快保存这篇博文吧，想不出来了，从头看一遍，保证你回想起全部正则的知识。 装逼OK，开始开车。 创建RegExp对象直接量 /pattern/attributes 12var reg = /\\d+/g;var a = &#123;a:1&#125;; 这种写法如同直接对象 new一个 new RegExp(pattern, attributes); 12var reg = new RegExp(/\\d/,\"i\")var a = new Object(&#123;a:1&#125;); 这种写法如同使用构造函数构建 参数i/g/m的作用attributes作为模式选择，有下面几种可以选择。 参数 含义 作用 i ignore 区分大小写 g global 全局匹配 m multiline 多行匹配 举个栗子： 1234var reg = /[a-z]/;var reg2 = /[a-z]/g;console.log(\"abcdefg\".match(reg)); //[\"a\", index: 0, input: \"abcdefg\"]console.log(\"abcdefg\".match(reg2)); //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"] 这里用到了Sting下的match方法，稍后会说道。这里先看着 RegExp下的一些方法方法：test()返回值： Boolean类型，true 或 false举例：1234var reg = /\\d+/; reg.test(&#123;a:123&#125;); //falsereg.test(123); //truereg.test('manfredhu'); //false 不难看出，test方法用在一些测试环境下，比如检测某个字符串是否存在某个特定字符的时候如上栗子，要监测字符串是否具有数字，只有第二个符合。 方法：exec()返回值： 被匹配的值，返回一个数组，数组为 匹配串 下标 整个串 没有发现匹配，则返回null 举例：123var reg = /\\d+/; reg.exec('d123'); //[\"123\", index: 1, input: \"d123\"] reg.exec('manfredhu'); //null 参数g在exec()方法的工作原理没有g参数的exec()方法只会执行一次 12345678var reg = /\\d+/; var str = 'd123d123d123';var result = reg.exec(str); console.log(result,reg);//[\"123\", index: 1, input: \"d123d123d123\"] /\\d+/result = reg.exec(str);console.log(result,reg);//[\"123\", index: 1, input: \"d123d123d123\"] /\\d+/ 而拥有g参数的exec()方法却是不一样的，工作原理如下 找到第一个 “e”，并存储其位置 如果再次运行 exec()，则从存储的位置开始检索，并找到下一个 “e”，并存储其位置 12345678var reg = /\\d+/g; var str = 'd123d123d123';var result = reg.exec(str); console.log(result,reg);//[\"123\", index: 1, input: \"d123d123d123\"] /\\d+/result = reg.exec(str);console.log(result,reg);//[\"123\", index: 5, input: \"d123d123d123\"] /\\d+/ 这里加了g参数，第一次匹配返回匹配开头的下标1，第二次返回下标5. 方法：compile()返回值： 无compile() 方法用于改变 RegExp。compile() 既可以改变检索模式，也可以添加或删除第二个参数。 12345var patt1=new RegExp(\"e\");console.log(patt1.test(\"The best things in life are free\")); //truepatt1.compile(\"d\",\"g\");console.log(patt1); // /d/gconsole.log(patt1.test(\"The best things in life are free\")); //false 正则表达式正则符号比较多，常用的如下: 常用元字符 符号 含义 [abc] 查找方括号之间的任何字符 [^abc] 查找不属于abc的任何字符 [A-z] 查找任何从大写 A 到大写 z 的字符 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 量词如字面意思，就是描述匹配的数量的。 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 这里的量词还是比较重要的，最后两个估计有的同学没见过。 正向预查与负向预查 ?=n 正向预查 在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， ‘Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 ?!= 负向预查 在任何不匹配的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 RegExp下的一些属性 属性 描述 global RegExp 对象是否具有标志 g。 ignoreCase RegExp 对象是否具有标志 i。 multiline RegExp 对象是否具有标志 m。 lastIndex or index 一个整数，标示开始下一次匹配的字符位置。 source 正则表达式的源文本。 lastIndex属性 该属性存放一个整数，它声明的是上一次匹配文本之后的第一个字符的位置。 上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。 该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 提示和注释重要事项：不具有标志 g 和不表示全局模式的 RegExp 对象不能使用 lastIndex 属性。提示：如果在成功地匹配了某个字符串之后就开始检索另一个新的字符串，需要手动地把这个属性设置为 0。 栗子翻上去看 2.2.1. 参数g在exec()方法的工作原理 String对象下的一些正则方法方法：search(regexp)用途： 检索与正则表达式相匹配的值，可以对比String.indexOf(string,fromIndex)方法，但是不同的是这里可以传入一个正则表达式作为参数。参数： 接受一个正则表达式作为参数 返回值： 匹配首字母的下标 没有匹配返回-1 举例：123var str=\"Visit W3School!\"console.log(str.search(/W3School/)); //6console.log(str.search(/w3school/)); // -1 方法：match(str|regexp)用途： 找到一个或多个正则表达式的匹配。参数： 接受一个字符串或者正则式作为参数。返回值： 返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。 举例: 12345var str = \"For more information, see Chapter 3.4.5.1\";var re = /(chapter \\d+(\\.\\d)*)/i;var found = str.match(re);console.log(found); //[\"Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 26, input: \"For more information, see Chapter 3.4.5.1\"] 这个例子的返回值可以看看，返回的数组的第一个值为正则式的匹配串，第二个值开始为()捕获的捕获串，这里的正则有两对小括号，所以应该有2个捕获串，就是返回值数组的第二个和第三个。倒数第二个参数为第一个捕获串的首字母的下标。倒数第一个参数为整个字符串。 带有g参数12var str = \"1 plus 2 equal 3\";console.log(str.match(/\\d+/g)); //[\"1\", \"2\", \"3\"] 综合起来1234var str = \"For more information, see Chapter 3.4.5.1 chapter\";var re = /(chapter \\d+(\\.\\d)*)/ig;var found = str.match(re);console.log(found); //[\"Chapter 3.4.5.1\"] 可以看到带有g参数的，返回值只有匹配串。 方法：split(separator,howmany)用途： 把字符串分割为字符串数组，String.split() 执行的操作与 Array.join 执行的操作是相反的。 参数： 参数separator为必需，字符串或正则表达式，从该参数指定的地方分割string。 参数howmany为可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 返回值： 分割后的字符串数组。 举例: 1234var str=\"How are you doing today?\";console.log(str.split(\" \")); //[\"How\", \"are\", \"you\", \"doing\", \"today?\"]console.log(str.split(\"\")); //[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]console.log(str.split(\" \",3)); //[\"How\", \"are\", \"you\"] 方法：replace(regexp,func)用途： replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 参数： 第一个参数为规定子字符串或要替换的模式的 RegExp 对象。 第二个参数为一个字符串值。规定了替换文本或生成替换文本的函数。 从参数组合来看有四种组合，下面举例四种情况。 返回值： 处理后的字符串。 举例: 参数为字符串、字符串的替换功能12var str=\"Visit Microsoft!\";console.log(str.replace(\"Microsoft\", \"W3School\")); //Visit W3School! 参数为正则表达式、字符串的更高级的替换功能12var str=\"Visit Microsoft!\";console.log(str.replace(/Microsoft/, \"W3School\")); //Visit W3School! 参数为正则表达式、函数1234567var str = '&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;';str.replace(/\\&#123;(\\d+)\\&#125;/ig,function(a,b)&#123; console.log(arguments);&#125;);//[\"&#123;0&#125;\", \"0\", 12, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"]//[\"&#123;1&#125;\", \"1\", 17, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"]//[\"&#123;2&#125;\", \"2\", 30, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"] 这里可以看出，接受函数作为第二个参数的时候，函数会收到的参数： 第一个参数是正则表达式的匹配串 第二个是正则表达式的捕获串，实际上，中间的参数具体有多少个取决于正则表达式中子表达式的个数 倒数第二个参数是捕获到的部分的首字母在整个字符串中的位置索引，从0开始 最后一个参数是调用replace()方法的字符串本身","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"}]},{"title":"MySQL使用及在Mac上的区别","slug":"24-how-to-use-mysql-on-mac","date":"2017-02-26T12:59:36.000Z","updated":"2017-04-05T13:44:00.000Z","comments":true,"path":"2017/02/26/24-how-to-use-mysql-on-mac/","link":"","permalink":"http://www.manfredhu.com/2017/02/26/24-how-to-use-mysql-on-mac/","excerpt":"","text":"MySQL用的比较多的，应该是学生时代，作为一款入门款的关系型数据库，还是挺好用的。首先是下载MySQL的安装包，然后安装，直接搜官网安装就好了。 之前都是在windows上用的mysql，习惯之后换了电脑在Mac上面用遇到了不少坑。记录如下 下载MySQLMac下载地址： 官网下载链接戳这里 安装后进入MySQL命令模式下载dmg之后安装，安装完要进入MySQL，按照windows的使用习惯是这样的，问题就在于在windows的时候它有叫我设置用户名和密码，在Mac上没有。。。 我试过了几个密码，123456，123,没有密码都提示错误。后面发现可能是root，不过懒得试了。搜了一下破解方法，最后成功破解。 破解方法 停止 mysql server. 通常是在 &#39;系统偏好设置&#39; &gt; MySQL &gt; &#39;Stop MySQL Server&#39;PS：可以在Alfred搜mysql直接调出来 打开终端，输入：sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 打开另一个新终端，输入:sudo /usr/local/mysql/bin/mysql -u root 无密码进入 修改密码：UPDATE mysql.user SET authentication_string=PASSWORD(&#39;新密码&#39;) WHERE User=&#39;root&#39;; 同步修改到内存：FLUSH PRIVILEGES; 终端下输入mysql -u root -p如果进入则成功 安装NavicatNavicat这货是windows和mac上都有的数据库管理软件，用习惯之后你会发现比mysql自带的workbench还要爽，在windows用了过来已经改不了了，果断下一个，链接在这里 Navicat登陆mysqlhostName: localhostport: 3306userName: rootpassword: 123456savePassword: YESencoding: utf-8 习惯这个配置了哈哈哈","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"},{"name":"mysql","slug":"mysql","permalink":"http://www.manfredhu.com/tags/mysql/"}]},{"title":"React + Reflux 渲染性能优化原理","slug":"23-reactRenderingPrinciple","date":"2016-11-08T15:00:41.000Z","updated":"2017-04-05T13:44:04.000Z","comments":true,"path":"2016/11/08/23-reactRenderingPrinciple/","link":"","permalink":"http://www.manfredhu.com/2016/11/08/23-reactRenderingPrinciple/","excerpt":"","text":"ReactReact的优点有很多，现在很多应用都接入React这个框架。在我看来，有下列优点： Facebook团队研发并维护——有团队维护更新且有质量保证 在MVVM结构下只起View的作用——简单接入，不需要花费大量人力重构代码 组件化形式构建Web应用——复用性强，提高开发效率 用Virtual DOM减少对DOM的频繁操作提高页面性能——批量操作减少重排（reflows）和重绘(repaints)次数——性能对比旧的方式有提高 React对重排和重绘的提高雅虎性能优化比较重要的点，老司机自行忽略。如下图，HTML被浏览器解析为DOM树，CSS代码加载进来解析为样式结构体，两者关联组成渲染树，之后浏览器把渲染树绘制出来就是我们看到的网页了。这里如果我们对DOM树或者样式结构体做一些操作，如删除某个节点，样式改为隐藏（display:none）等等，会触发重排进而导致重绘。 触发重排的条件 DOM元素的数量属性变化 DOM树的结构变化——节点的增减、移动 某些布局属性的读取和设置触发重排——offsetTop/offsetWidth/scrollTop等等导致子级、后续兄弟元素、父节点因重新计算布局而重排 触发重绘的条件 简单样式属性的变化——颜色、背景色等 重排导致的重绘 而React维护了一个Virtual DOM将短时间的操作合并起来一起同步到DOM，所以这也是它对整个前端领域提出的最重要的改变。 为什么引入Reflux？上面说了React在MVVM结构下只起View的作用，那么除了View，MVVM下还有Model，ViewModel。而纯粹的View，会让整个逻辑耦合在一层下，数据也需要层层传递，不方便控制和复用。 故业内也有一堆的分层框架——如最早的flux，现在部门在用的Reflux，以及Redux。对比Redux，Reflux更容易理解和上手——这也是现状，学习成本越低，接入现有业务就越容易。 Refluxreflux的架构非常简单，就是三部分 Action 理解为一个命令或者动作，通过它来向组件发出”指令” Store 为ViewModel部分，组件的一些状态属性会存储在这里 View Component 为组件模板 所以Reflux只是让我们，更好的去操作组件，通过一个Action命令，叫组件去干嘛，组件自己通过写好的代码，对命令做出反应(变化为不同的state状态)。 React+Reflux起到的作用现在你已经有了两个小工具了，写一个组件，通过Action调用组件就可以了。写到这里，你应该能体会到，所有的引入就是为了让代码写起来更有效率，更易用，复用性更强。 Pure Component纯净的组件：在给定相同props和state的情况下会渲染出同样结果其优点有这么几点： 我们写的组件都应该是只依赖props和state的，而不应该依赖其他全局变量或参数 纯净的组件方便复用、测试和维护 组件生命周期React组件有两部分 第一部分是初始化的生命周期: getDefaultProps geInitialState componentWillMount render componentDidMount 第二部分是被action触发，需要更新： shouldComponentUpdate componentWillUpdate render conponentDidUpdate shouldComponentUpdateshouldComponentUpdate这个方法可以说是一个预留的插入接口。在上面更新的时候，第一步就是调用的这个方法判断组件是否该被重新渲染。 shouldComponentUpdate是在React组件更新的生命周期中，用于判断组件是否需要重新渲染的一个接口，它有两个返回值： 返回true，则进入React的Virtual DOM比较过程 返回false，则跳过Virtual DOM比较与渲染等过程 如上图，这是一棵React Virtual DOM的树。 C1在ShouldComponentUpdate返回了true，即默认值，代表需要更新，进入Virtual DOM Diff过程，返回false，不相同，需要更新 C2在ShouldComponentUpdate返回了false,不再更新，C4,C5因为被父节点在ShouldComponentUpdate中返回了false，所以不再更新 C3在ShouldComponentUpdate返回了true进入Virtual DOM Diff过程，比对结果为false，新旧不一样，需要更新 轮到C6,ShouldComponentUpdate返回了true，进入Virtual DOM Diff的过程，返回了false，即新旧两个节点不相同，所以这个节点需要更新 C7在ShouldComponentUpdate返回了false，即不需要更新，节点不变 C8在ShouldComponentUpdate返回了true,进入Virtual DOM Diff比对过程，结果为true，新旧相等，不更新 大概就是这么一个过程，在这里，Diff算法其实还是比较复杂的，比较好的做法是我们来写入ShouldComponentUpdate来自己控制组件的更新，而不是依赖React帮我们做比较。 进入正文前面讲了那么多，相信懂React的都懂了，就不再详细讲了，Diff算法有兴趣的可以自己去翻源码，网上也有一堆模拟实现的例子。 接下来介绍一个探索reflux&amp;react渲染优化的例子。这里试图，模拟一个比较现实的例子，抛开很多业务代码，让问题变得直接。 首先例子有三个组件，两个按钮，5个数字，还有一个重复打印文本的大组件。 1basicDemo 是没有优化的例子，每50ms会发出action更改store数据触发渲染 2perfDemo 使用addons插件Perf分析页面性能的例子 3pureRenderMixinDemo 使用addons插件pureRenderMixin优化页面性能的例子 4updateDemo 使用了addons插件update优化页面性能的例子 5immutableDemo 使用了Immutable.js优化页面性能的例子 源码传送门 说明 gulpfile.js为gulp构建代码，会将tpl.js的JSX代码翻译为js代码，需要的可以自己修改，每次转化模板需要gulp运行一下 modulejs模块加载器和myView单页SPA框架为腾讯通讯与彩票业务部前端团队这边的基本框架，具体的请戳这里查看 需要关注的文件 index.html 页面入口，规定了执行的模块 app.js 应用程序入口 todoAction.js (reflux架构下，demo的action) todoStore.js (reflux架构下，demo的store) tpl.js 组件的jsx文件 简单用法 cd ./xxx/(这里的xxx为上面对应的 ……./4updateDemo/ 目录) http-server -p 8888端口可以自定义，http-server模块已在node_module目录下，担心版本依赖问题，已上传node_module目录，直接打开就可以了 打开浏览器便可浏览，详情请看控制台 basicDemo1basicDemo目录是一个最原始的目录，这里你可以看到我们哪里出现了问题。 cd ./example 打开这个没优化过的例子的目录http-server -p xxxx 这里端口随意，不冲突就好浏览器访问并打开控制台，会看到1235 tpl.js:32 createNum组件被更新了 tpl.js:10 TextComponent被更新了2 tpl.js:57 createBtn组件被更新了 初始化createNum组件被渲染了5次，因为有5个，createBtn组件被渲染了两次，因为有点击开始和点击结束两个按钮。通过不同的传参而改变形态。 点击开始会触发action，让store的数据每次+1，点击结束会清除定时器 点击开始可以看到控制台的数据每次都会刷新整个界面的所有组件，特别是有一个大组件TextComponent，是重复5000次文本的，每次重新渲染就有很多的损耗。这就是我们要优化的地方——减少某些关键部分的重新渲染的次数，减少无用对比的消耗 这里你可以打开Chrome控制台的Timeline来看一下，点击开始，打开Timeline面板，每1S左右会有一个脚本执行的高峰期。 我们知道特别是在移动端，CPU和内存的资源显得尤为稀缺（大概只能占用正常CPU和内存的10%，微信手Q等可能会因为友商系统对应用程序的优先级设计使这个限制略有提高——我说的就是小米哈哈哈），所以这样说来，性能这一块在移动手机web显得非常非常重要。 PerlPerl是react-addons带来的性能分析工具，这里的perfDemo是结合Chrome插件的例子。要向全局暴露一个window.Perl变量，然后就可以愉快的配合Chrome插件使用了 React-addons插件版本的Perf插件提供原生的API——用在首次渲染部分 Chrome插件——用在有交互的部分 console tool——需要查看对比新旧值的情况下 这里的wasted time就是在做属性没变化的重复渲染的过程，可以优化。用法与Chrome开发工具的TimeLine用法类似，点击start开始记录，后点击stop结束 PureRenderMixin一个简单的通用优化工具，通过浅对比(shallowCompare)方法对比新旧两个组件的状态，达到减少重复渲染的目的。 注意这里组件的store必须无关联，原因是shallowCompare的时候，比较的是组件关联的store的数据，而例子里面store是一个，其他组件num的变化也会引起这里TextComponent组件的更新 这里将store与顶级组件APP关联起来，然后在子孙组件下自定采用props传递的方式处理(传递基本类型的数据)，这样就可以让pureRenderMixin的通用化了，唯一的缺点是，传递props要控制，只把组件需要的属性传递下去，这里会比较麻烦，但是这样又是性能较高又比较好理解的处理方式(相对其他要拷贝属性的方式) *store下，option里面的对象，受pureRenderMixin的限制，不可以出现引用类型 PureRenderMixin其实是封装了更底层的shallowCompare接口的 简单用法如下:1234567var PureRenderMixin = require('react').addons.PureRenderMixin;React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 就加了一个mixins，看起来简单优雅有木有。可以在众多组件里面copy通用啊有木有那这里干了什么？1234React.addons = &#123; CSSTransitionGroup: ReactCSSTransitionGroup, LinkedStateMixin: LinkedStateMixin, PureRenderMixin: ReactComponentWithPureRenderMixin, //看这里 123456var ReactComponentWithPureRenderMixin = &#123; //帮你写了一个shouldComponentUpdate方法 shouldComponentUpdate: function (nextProps, nextState) &#123; return shallowCompare(this, nextProps, nextState); &#125;&#125;; 1234function shallowCompare(instance, nextProps, nextState) &#123; //分别比较props和state属性是否相等 return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);&#125; 1234567891011121314151617181920212223242526function shallowEqual(objA, objB) &#123; if (objA === objB) &#123; //store嵌套层级太深这里就会返回true，引用类型内存指向同一空间 return true; &#125; if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) &#123; return false; &#125; var keysA = Object.keys(objA); var keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; return false; &#125; // Test for A's keys different from B. var bHasOwnProperty = hasOwnProperty.bind(objB); for (var i = 0; i &lt; keysA.length; i++) &#123; if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) &#123; return false; &#125; &#125; return true;&#125; 所以PureRenderMixin这个插件，只能比较state和props为基本类型的部分。如果有更加深层次的store数据嵌套，就要借助于update插件或者Immutablejs来深拷贝store的数据另存一份了。 用update优化（也称Immutable Helper）update是addons里面的一个方法，旨在对拷贝对象复杂的过程来做一些语法上的优化，具体可以看react官方文档 1234567//extend复制对象属性的时候var newData = extend(myData, &#123; x: extend(myData.x, &#123; y: extend(myData.x.y, &#123;z: 7&#125;), &#125;), a: extend(myData.a, &#123;b: myData.a.b.concat(9)&#125;)&#125;); 123456//用update的时候，提供了一些语法糖让你不用写那么多var update = require('react-addons-update');var newData = update(myData, &#123; x: &#123;y: &#123;z: &#123;$set: 7&#125;&#125;&#125;, a: &#123;b: &#123;$push: [9]&#125;&#125;&#125;); cd ./updateDemo 打开这个用addons.update优化过的例子的目录http-server -p xxxx 这里端口随意，不冲突就好 这个例子与上面一个例子唯一的不同是这里用了addons.update来进行store数据的复制，具体的可以看todoStore和tpl这两个模块的代码，其他基本无修改 这里update是参考了MongoDB’s query的部分语法，具体的可以看这里,类比数组方法，返回一个新的实例。 {$push: array} 类似数组的push方法 {$unshift: array} 类似数组的unshift方法 {$splice: array of arrays} 类似数组的splice方法 {$set: any} 整个替换目标 {$merge: object} 合并目标和object的 keys. {$apply: function} 传递当前的值给 function 并用返回值更新它 但是由Timeline的观察来看，复制对象属性的性能远比刷新一个大组件的性能高。 ImmutablejsImmutable.js是Facebook为解决数据持久化而独立出来的一个库，传统的，比如我们有 123456var a = &#123;b:1&#125;;function test(obj)&#123; obj.b = 10; return obj;&#125;test(a); //10 函数对对象的操作，你不会知道这个函数对对象进行了什么操作。也就是说是封闭的。而Immutable每次对对象的操作都会返回一个新对象 Immutable.js提供了7种不可变的数据类型:List Map Stack OrderedMap Set OrderedSet Record,对Immutable对象的操作均会返回新的对象，例如: 123456var obj = &#123;count: 1&#125;;var map = Immutable.fromJS(obj);var map2 = map.set('count', 2);console.log(map.get('count')); // 1console.log(map2.get('count')); // 2 引入Immutable.js，需要对现有的业务代码进行改动，通常是对tpl和store两部分进行操作，初始化数据的时候生成一个Immutable的数据类型，之后每次get,set操作都会返回一个共享的新的对象。 50ms渲染一次，重复渲染200次的截图，引入了immutable用了其set方法： 50ms渲染一次，重复渲染200次的截图，引入了immutable用了其update方法： seamless-immutable &amp;&amp; Observejs一个是immutable的阉割版，一个是AlloyTeam推的。两者都是通过Object.defineProperty(IE9+)对set和get操作进行处理，优点是文件比较小。 写在最后自己设想，组件化运用到极致，应该是像微信weui那样 有一套非常适合接入，复用性非常强的组件库。拿来就用，不需要再次开发 应该兼顾起上面说的减少重复渲染的部分 开发友好 这里也思考一些可能做到的变化： 将一个组件的action/store/JSX/样式代码Style 写在一个文件里，这样方便修改和调用，封闭组件内部实现细节，对外只暴露action操作和store的一些get方法，这样可以修改或者是获取到组件的某些现在时刻的属性（也有同学是直接封装为一个对象，通过对象暴露其store,action） 组件共享或依赖的数据，应在公共父级的store或独立成一个单独的部分，然后采用props传递的形式或从独立的store里面取数据 License源码传送门MIT. Copyright (c) 2016 ManfredHu.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"},{"name":"React","slug":"React","permalink":"http://www.manfredhu.com/tags/React/"}]},{"title":"谈谈url这东西","slug":"22-url","date":"2016-08-16T14:58:40.000Z","updated":"2017-04-05T13:44:09.000Z","comments":true,"path":"2016/08/16/22-url/","link":"","permalink":"http://www.manfredhu.com/2016/08/16/22-url/","excerpt":"","text":"URL 统一资源定位符（或称统一资源定位器/定位地址、URL地址等，英语：Uniform / Universal Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）。——维基百科 一个完整的URL通常有这样的几部分构成： 12345标准格式：scheme://host:port/pathname?search#hash例子：http://www.x2y2.com/fisker/post/0703/gg.mm.html?ver=1.0&amp;id=6#imhere 格式部分 例子对应的部分 获取代码 protocol http: window.location.protocol host www.x2y2.com window.location.host port http默认为80，https默认为443，本例为空 window.location.port pathname /fisker/post/0703/gg.mm.html window.location.pathname search ?ver=1.0&amp;id=6 window.location.search hash #imhere window.location.hash window.location.href 和 window.location.replace window.location.href 是一个可读可写的属性。读则返回整个URI字符串，写则跳转页面。 window.location.replace 是一个方法，同样用于页面跳转，只是同时会把历史纪录替换掉，所以你后退回不去原来的链接，而 window.location.href 是有记录的。 注意：这里只可以跳转到同个host下的不同pathname。 12345//如果你打开www.baidu.com在控制台输入window.location.href = \"www.qq.com\";//则url会变成 https://www.baidu.com/www.qq.com//百度会告诉你它根本不认识这货而跳转到错误搜索//测试环境为Chrome","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"基础","slug":"笔记/基础","permalink":"http://www.manfredhu.com/categories/笔记/基础/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"},{"name":"基础","slug":"基础","permalink":"http://www.manfredhu.com/tags/基础/"}]},{"title":"classNames模块","slug":"21-classNames","date":"2016-07-12T15:18:35.000Z","updated":"2017-04-05T13:44:14.000Z","comments":true,"path":"2016/07/12/21-classNames/","link":"","permalink":"http://www.manfredhu.com/2016/07/12/21-classNames/","excerpt":"","text":"classNames今天分享一个好玩的东西，它叫 classNames ,这个是一个翻译的版本，原版链接在这里它是一个小工具。我是在React项目里面用到它的。一用就停不下来了 它是什么？它是一个简单的对类名进行条件判断并且拼装的小工具。通过条件判断把对应的class串接起来，可以更清晰的展示组件的状态对应的css.总的来说，就是让你的代码可读性更高 它用在哪里？React官方推荐用它，当然，既然是小工具，那么肯定扩展性是非常强的。不仅仅是React!!不仅仅是React!!不仅仅是React!!重要的事情我们说三遍 为什么要用它？项目CSS代码的规范遵循的是BEM，所以我们有很多的类名是有状态定义的，比如 .sidebar__item--active 。你应该可以一眼看出来，这是一个侧边导航栏的激活状态，在选中的时候显示。但是通常还有一个默认状态 .sidebar__item ，那么这个时候，你通常会加多一个判断语句，因为你需要判断是不是激活的。 12345678910var SideBar = React.createClass(&#123; // ... render () &#123; var sideBarClass = 'sidebar__item'; if (this.state.isActive) &#123; sideBarClass += '--active'; &#125; return &lt;div className=&#123;sideBarClass&#125;&gt;&#123;this.props.text&#125;&lt;/div&gt;; &#125;&#125;); 那么假设你还有一个自定义颜色的 .sidebar__item-orange 类。那你的代码会多一个 if 判断. 12345678910111213var SideBar = React.createClass(&#123; // ... render () &#123; var sideBarClass = 'sidebar__item'; if (this.state.isActive) &#123; sideBarClass += '--active'; &#125; if (this.props.color) &#123; sideBarClass += '' + this.props.color; //'+'优先于'+=' &#125; return &lt;div className=&#123;sideBarClass&#125;&gt;&#123;this.props.text&#125;&lt;/div&gt;; &#125;&#125;); 假如……好了没那么多假如了，你的类名有多长，你的 if 就会有多长。所以作为一个有追求的前端，不能忍!! 怎么用？还是上面的例子 123456789101112131415var cl = require('classnames');var SideBar = React.createClass(&#123; // ... render () &#123; var sideBarClass = cl(&#123; 'sidebar__item': true, '--active': this.state.isActive, [this.props.color] :this.props.color, //这里用的是ES6的语法，可以用JSX编译工具如babel转换出来 .... .... .... &#125;); return &lt;div className=&#123;sideBarClass&#125;&gt;&#123;this.props.text&#125;&lt;/div&gt;; &#125;&#125;); 有多少可以来多少，不怂好吗。引用了一个模块，我们的代码就优雅了好多了，可能你还会担心，这模块大不大啊，引入的话会不会得不偿失啊。我们看一下源代码吧。 123456789101112131415161718192021222324252627282930313233343536373839(function () &#123; var hasOwn = &#123;&#125;.hasOwnProperty; function classNames () &#123; var classes = []; for (var i = 0; i &lt; arguments.length; i++) &#123; var arg = arguments[i]; if (!arg) continue; var argType = typeof arg; if (argType === 'string' || argType === 'number') &#123; classes.push(arg); &#125; else if (Array.isArray(arg)) &#123; classes.push(classNames.apply(null, arg)); &#125; else if (argType === 'object') &#123; for (var key in arg) &#123; if (hasOwn.call(arg, key) &amp;&amp; arg[key]) &#123; classes.push(key); &#125; &#125; &#125; &#125; return classes.join(' '); &#125; //CommonJS规范 if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports = classNames; //AMD规范 &#125; else if (typeof define === 'function' &amp;&amp; typeof define.amd === 'object' &amp;&amp; define.amd) &#123; // register as 'classnames', consistent with npm package name define('classnames', [], function () &#123; return classNames; &#125;); //其他 &#125; else &#123; window.classNames = classNames; &#125;&#125;()); 代码真心短得可怜，而且还可以再DIY,最后三个if，其实你可以选择你项目用的规范来引入。默认支持 CommonJS规范/AMD规范/全局定义 三种。 我们再观察一下原理部分，看有没有什么bug。知己知彼才能放心插入嘛 一个内部数组classes，然后对参数进行判断后将参数添加到内部数组里参数类型判断条件 string或者number类型直接push到数组 Array类型则递归这个数组 Object类型则把键为true的加入数组 最后join了数组返回一个字符串。代码很简单，但是创意无限。非常推荐大家用这个模块。有问题可以留言哈。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"分享","slug":"分享","permalink":"http://www.manfredhu.com/tags/分享/"}]},{"title":"Interesting JavaScript","slug":"20-interestingJavascript","date":"2016-07-07T14:43:02.000Z","updated":"2017-04-05T13:44:21.000Z","comments":true,"path":"2016/07/07/20-interestingJavascript/","link":"","permalink":"http://www.manfredhu.com/2016/07/07/20-interestingJavascript/","excerpt":"","text":"声明提升写出下面代码的运行结果 12345678910var a,b;(function()&#123; console.log(a); console.log(b); var a=b=3; console.log(a); console.log(b);&#125;)();console.log(a);console.log(b); A. undefined,undefined,3,3,undefined,3B. undefined,undefined,3,3,undefined,undefinedC. 0,0,3,3,undefined,undefinedD. undefined,undefined,3,3,0,0 正确答案：A解释：代码相当于下面这样的过程 123456789101112var a,b;(function()&#123; var a; console.log(a); //undefined console.log(b); //undefined a=3; b=3; console.log(a); //3 console.log(b); //3&#125;)();console.log(a); //undefinedconsole.log(b); //3 变量定义规则下面符合一个有效的javascript变量定义规则的是？ A. _$te$t2B. withC. a bcD. 2a 正确答案： A考点：ECMAScript语法解析：with为关键字，空格不行，数字开头的不行 document.getElementById和document.getElementsByTagNameJavaScript中document.getElementById的返回值的类型和document.getElementsByTagName的返回值类型分别是？ A. Array,NodeListB. Object, HTMLCollectionC. String,NodeListD. Function,NodeList 正确答案： B解析：这题可能有争议，浏览器测试代码如下 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Id与TagName类型检测&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"test\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function checkType(element)&#123; console.log(Object.prototype.toString.call(element)); &#125; checkType(document.getElementById('test')); //[object HTMLDivElement] checkType(document.getElementsByTagName('div')); //[object HTMLCollection] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; if/var下面关于块内函数的做法哪些是正确的？A. if(x){ function foo(){}}B. if(x){ var function foo(){}}C. if(x){ foo = function(){}}D. ECMAScript明确的规范了块级函数，JavaScript实现了这个规范 正确答案：B解析：测试报错 hasOwnProperty下列代码 123var obj=&#123;&#125;……obj.hasOwnProperty(\"val\"); 中hasOwnProperty的作用是？A. 判断obj对象是否具有val的属性B. 判断obj对象是否具有val的值C. 判断obj的原型对象是否具有val的属性D. 判断obj的原型对象是否具有val的值 正确答案：A解析：hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false call和apply下面有关JavaScript中 call和apply的描述，错误的是？ A. call和apply都属于Function.prototype的方法，所以每个function实例都有call，apply属性B. 两者传递的参数不一样，call函数第一个参数都是传入给当前对象的对象，apply不是C. apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入D. call传入的则是直接的参数列表。call方法可将一个函数的对象上下问从出事的上下文改变为thisObj指定的新对象。 正确答案：B解析:apply和call都是改变函数内部this指向的方法，挂载在Function.prototype下 script标签（不定项选择题）给网页添加javascript的方式有 1234A. 使用script标签，将JavaScript代码写到&lt;script&gt;&lt;/script&gt;之间B. 添加外部javascript文件C. 使用行内javascriptD. 使用@import引入javascript文件 正确答案：A，B，C解析：只有CSS可以用@import方法，题目其实可以换成CSS，则全部正确 12345给网页添加css的方式有A. 使用style标签，将JavaScript代码写到&lt;style&gt;&lt;/style&gt;之间B. 添加外部css文件C. 使用行内cssD. 使用@import引入css文件 parseInt与map[“1”, “2”, “3”].map(parseInt)的输出结果是A. [1,NaN,NaN]B. [1,2,3]C. [NaN,NaN,NaN]D. 发生错误 正确答案： A. [1,NaN,NaN]解析： Array.prototype.map(func(currentValue, index, arrary),thisObj)map接受两个参数, 一个回调函数 callback, 一个回调函数的this值。其中回调函数接受三个参数 currentValue, index, arrary parseInt 只接受两个两个参数 string, radix(基数).基数。该值介于 2 ~ 36 之间,如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。如果为0，则直接输出字符串 如下的例子来看this的运用和基数的例子： 1234567891011var obj = &#123; value:1&#125;;[\"1\", \"2\", \"3\"].map(function(currentValue, index, arrary)&#123; console.log(this); //输出3次obj&#125;,obj);console.log(parseInt('1', 0)); //1console.log(parseInt('123', 0)); //123console.log(parseInt('2', 1)); //NaNconsole.log(parseInt('3', 2)); //NaN 当[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)的时候，传入parseInt的参数为currentValue,index Function.prototype.name1234function foo() &#123; &#125;var oldName = foo.name;foo.name = &quot;bar&quot;;console.log([oldName, foo.name]); A. [‘foo’,’bar’]B. [‘foo’,’foo’]C. [‘bar’,’bar’]D. [‘bar’,’foo’] 答案：B.[‘foo’,’foo’]; 函数的name属性指向函数名，挂载在Function.prototype下，所以不要给函数赋值属性name哈。并且这个属性是不可改变的. 所以下面这样的例子就不要出现了12function foo() &#123;&#125;foo.name = \"bar\"; //bad,你居然真忘了Function.prototype.name是一个不可修改的属性！！ 测试代码：1console.log(Function.prototype.hasOwnProperty('name')); //true 正则test方法的参数问题12var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()] A. false, trueB. false,trueC. true,trueD. true,false答案: C.true, true 如题所示，test方法如果参数为null或者不屑，则默认返回true 变量作用域写出这段代码的运行结果 123456789&lt;SCRIPT type=\"text/javascript\"&gt; var bb = 1; function aa(bb) &#123; bb = 2; console.log(bb); &#125;; aa(bb); console.log(bb);&lt;/SCRIPT&gt; 正确答案： 2 1 +-操作符如下代码输出的结果是什么： 1234console.log(1+ \"2\"+\"2\");console.log(1+ +\"2\"+\"2\");console.log(\"A\"- \"B\"+\"2\");console.log(\"A\"- \"B\"+2); 正确答案：122 //数字与字符串+则数字默认转换为字符串32 //+号会将字符串2先转化为数字，这种也是常用的将字符串转换为数字的方式NaN 2NaN 解析：插播——常见的将字符串转换为数字的方法： parseInt,具体使用请看前面第8题 +&quot;123&quot; 类似这种写法，比如某个参数不确定是不是数字可以这样 +data.len Number方法 从带宽（精简压缩后）考虑会用第二种，所以通常会在代码上大量看到这种写法 null和Object的关系[typeof null, null instanceof Object]的输出结果是 正确答案：object, false解析：null为一个空的对象，这个对象存在但是里面一点东西都没有，相当于有堆空间但是里面没有属性。而undefined可以理解为连堆空间都没有（至少表现出来是这样的不是吗？）null instanceof Object为false是因为null连属性都没有，更没有检测原型链的_proto_和prototype了。 +运算符优先于?:运算符var val = ‘smtg’;console.log(‘Value is ‘ + (val === ‘smtg’) ? ‘Something’ : ‘Nothing’);正确答案： ‘Something’ 变量作用域12345678910写出下面代码的执行效果var name = &apos;World!&apos;;(function () &#123; if (typeof name === &apos;undefined&apos;) &#123; var name = &apos;Jack&apos;; console.log(&apos;Goodbye &apos; + name); &#125; else &#123; console.log(&apos;Hello &apos; + name); &#125;&#125;)(); 正确答案： Goodbye Jack 编译语法分析后代码（声明提升）如下 12345678910var name = 'World!';(function () &#123; var name; if (typeof name === 'undefined') &#123; name = 'Jack'; console.log('Goodbye ' + name); //Goodbye Jack &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); ## 写出下面题的答案 1234567var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); 正确答案：不会输出，因为END是最大值了，解析：在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停 浮点数的不准确性输出0.1+0.2 === 0.3的结果，并简单地解释。解析：经典的题目，浮点数因为存在误差，所以不能用===判定，通常在金额处理的时候会乘以10/100倍来小数部分的数据 正则表达式replace的高级用法写出答案 1\"1 2 3\".replace(/\\d/g, parseInt) 答案：1, NaN, 3解析：replace() 方法的参数第二个参数可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。 1.该函数的第一个参数是匹配模式的字符串2.接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数3.接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置4.最后一个参数是 stringObject 本身。 题目中因为没有子表达式匹配，即()括起来的匹配项，所以传入parseInt的参数三次分别为： 123parseInt(&quot;1&quot;, 0) //1，因为当基数为0时候直接输出第一个参数parseInt(&quot;2&quot;,2) //NaN，因为2进制只有01两个数字parseInt(&quot;3&quot;,4) //3，因为不超过四进制的最大值4 getPrototypeOf根据proto获取类型123function f() &#123;&#125;var a = f.prototype, b = Object.getPrototypeOf(f);console.log(a === b); 答案：false解析如下： 1234567function f() &#123;&#125;var a = f.prototype; //Objectvar c = new f();var b = Object.getPrototypeOf(f); //functionvar d = Object.getPrototypeOf(c); //Obejctconsole.log(a === b); //falseconsole.log(d === a); //true 函数的原型是一个对象，而函数的原型会是函数，对象的原型会是对象题目这里就是让你混淆普通函数的原型到底是什么？函数还是对象？答案是函数，因为普通函数的_proto_指向的是Function.prototype，所以Object.getPrototypeOf拿到的是function 你可以狠狠戳这里去看我以前写的15条规则解析JavaScript对象布局 这里应该可以看的很清楚了，函数Foo的prototype是Foo.prototype而Object.getPrototypeOf拿的是_proto_指向的Function.prototype,所以输出的是一个function。而普通对象，如图的o1,o2，_proto_指向的是Object.prototype [,]和join1[,,,].join(\", \") 答案: “, , “解析： 12[,,,].lenth //3[,,,].join('-') //-- 所以这题很明显了，三个逗号默认忽略最后一个，然后用’-‘会在两项中间添加连接符 Function.length和new Function.length123var a = Function.length, b = new Function(1,'2234').length;console.log(a === b); 答案 false解析：a为1，b为0，不相等 Math.min()和Math.max()在没有参数时候的奇葩情况12var min = Math.min(), max = Math.max()min &lt; max 答案；false解析：min为Infinity，b为-Infinity，结果是min &gt; max min() 方法可返回指定的数字中带有最低值的数字。Math.min(x,y) 如果没有参数，则返回 Infinity。如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。 max() 方法可返回两个指定的数中带有较大的值的那个数。Math.max(x…) 如果没有参数，则返回 -Infinity。如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。 闭包123456789function aa() &#123; console.log(\"aaa\"); return function()&#123; console.log(\"bbb\"); &#125;;&#125;console.log(aa);console.log(aa());console.log(aa()()); 答案：123456789function aa() &#123; console.log(\"aaa\"); return function()&#123;console.log(\"bbb\");&#125;;&#125;aaafunction()&#123;console.log(\"bbb\");&#125;;aaabbbundefined 第一个输出aa的函数体，大家都懂第二个执行了aa()，输出文本&quot;aaa&quot;，同时返回了里面的匿名函数第三个在第二步的基础上执行了匿名函数，最后再输出一个bbb，最后因为执行函数没有返回值，返回了undefined 类数组（array like)类数组对象是什么？说一下你知道的JavaScript里面类数组对象有哪些，类数组怎么转化为数组？ 类数组: 指向对象元素的数字索引下标以及 length 属性告诉我们对象的元素个数,但是不具有诸如 push 、 forEach 以及 indexOf 等数组对象具有的方法常见例子: DOM方法 document.getElementsByClassName() 的返回结果（实际上许多DOM方法的返回值都是类数组）以及特殊变量 arguments 所以通常要有一个转换的过程，借助 Array.prototype.slice 可以实现: 1Array.prototype.slice.call(arguments) //arguments转化为普通数组 构造函数与静态方法写出下面代码输出的结果并写出你的解题思路？ 1234567891011121314151617function Foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;Foo.getName = function () &#123; console.log (2);&#125;;Foo.prototype.getName = function () &#123; console.log (3);&#125;;var getName = function () &#123; console.log (4);&#125;;function getName() &#123; console.log (5);&#125; //请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 答案： 1234567Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2new Foo().getName();//3new new Foo().getName();//3 典型闭包下面代码的运行结果是？ 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;DOM进阶&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; var buttons=document.getElementsByName(&apos;button1&apos;); for(var i=0;i&lt;buttons.length;i++)&#123; buttons[i].onclick=function()&#123; console.log(i); &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body &gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮1&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮2&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮3&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮4&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;button1&quot; value=&quot;按钮5&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 这个错新手估计会犯，当初的我也是。闭包，点那个按钮都是输出 buttons.length 的值，这里是5","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"对象深复制","slug":"19-extendMethod","date":"2016-06-14T14:59:03.000Z","updated":"2017-04-05T13:44:47.000Z","comments":true,"path":"2016/06/14/19-extendMethod/","link":"","permalink":"http://www.manfredhu.com/2016/06/14/19-extendMethod/","excerpt":"","text":"对象引用这里主要举例jQuery的$.extend方法，首先是对象的深复制的背景：对象和数组是引用的，所以如果你用 12345var arr = [1,2,3,4,5];var arr2 = arr;arr2.push(6);console.log(arr); //[1, 2, 3, 4, 5, 6]console.log(arr2); //[1, 2, 3, 4, 5, 6] 但是有时候这不是我们要的结果，我们要将arr缓存起来，在某个时候重新还原arr为原来的值。这个时候就坑爹了，要复制整个对象或者数组。这个时候深复制就来了。 如果你不用jQuery的，你要自己写的话，还真的挺麻烦的。jQuery的$.extend方法的几种调用方法 $.extend(object1)直接扩展jQuery $.extend(target [,object1] [,object2])复制不递归 $.extend([deep], target, object1 [,objectN])递归复制 这里的deep是一个Boolean的值 $.extend(object1/function)直接扩展jQuery1234567891011121314var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;; // Merge object2 into object1$.extend( object1); // Assuming JSON.stringify - not available in IE&lt;8console.log($.apple) //0console.log($.banana) //Object &#123;weight: 52, price: 100&#125;console.log($.fn.cherry) //undefinedconsole.log($.banana === object1.banana); //true 把对象的属性copy到$下了，这里的$可能是Zepto或者jQuery，一样的。默认不会递归复制，这里可以看到banana还是复制的引用。$.extend这种写法jquery自己也用的很多，可以看到其实代码的后面一堆的$.extend或者是$.fn.extend这种写法，包括插件也用的很多。 $.extend(target [,object1] [,object2])复制不递归12345678910111213141516171819var object1 = &#123; apple: [0], banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100, egg: [1,2,3,4]&#125;;// Merge object2 into object1$.extend( object1, object2 );console.log(JSON.stringify( object1 )); //&#123;\"apple\":[0],\"banana\":&#123;\"price\":200&#125;,\"cherry\":97,\"durian\":100,\"egg\":[1,2,3,4]&#125;console.log(object1.egg === object2.egg); //true 这里将object2的属性合并到了object1中，object2和object1共有的属性会直接覆盖object1的属性，没有的会合并到object1里面。没有递归深层的属性，就是简单的复制属性而已。 $.extend([deep], target, object1 [,objectN])递归复制12345678910111213141516171819var object1 = &#123; apple: [0], banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100, egg: [1,2,3,4]&#125;;// Merge object2 into object1$.extend(true, object1, object2 );console.log(JSON.stringify( object1 )); //&#123;\"apple\":[0],\"banana\":&#123;\"weight\":52,\"price\":200&#125;,\"cherry\":97,\"durian\":100,\"egg\":[1,2,3,4]&#125;console.log(object1.egg === object2.egg); //false 这里传入了一个true的参数开启递归深复制，object1和object2的属性不会直接拿个引用过去，而是检查不同的地方，将相同的地方覆盖，没有的地方复制，引用的对象数组也被拷贝了一份过去，而不是拷贝引用而已。 没有源码你说啥呢？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 对$.fn.extend添加方法，之后将引用赋给$.extendjQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, //target是最后返回的对象，如果没有就创建一个对象 i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; deep = target; // skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target) ) &#123; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 对象的属性复制是分开的，boolean,number,string这三个和object,array处理是不一样的。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"关于实习的一些看法","slug":"18-internship","date":"2016-06-14T14:41:30.000Z","updated":"2017-04-05T13:45:05.000Z","comments":true,"path":"2016/06/14/18-internship/","link":"","permalink":"http://www.manfredhu.com/2016/06/14/18-internship/","excerpt":"","text":"这是一篇自己在腾讯实习一个半月的总结，仅供参考，非喜勿喷。 实习是干嘛的？实习就是公司让你适应从学校到职业生涯的转换的一个试练，你能转变过来才有资格留下来继续走下去。 实习累不累？说实话，新人都会觉得比较累，因为有太多不懂的东西，有太多的东西要学，有很多以前素不相识的人要认识。所以一句话：实习累，但是是一个痛并快乐的过程，因为你可以看着自己每天在成长。 你学到了什么？没来到腾讯之前在学校，完全不会知道别的公司是如何开发的。或许你会自己YY一遍，但是真正来了之后才发现，实习招聘的要求是多么基本，比如面试官会问你看过XX框架的源码没有？其实潜台词是我们这里的代码没有注释或者基本没有注释，如果你看不懂就就GG了。又比如面试官问你写CSS和JS你喜欢哪一个，潜台词是：我们这里分为重构和前端，对应不同的工作，你更喜欢从事哪一个工作？现在看来，面试的一切问题都不是无的放矢，都有背后的潜台词存在。 面试很难吗？难，因为你需要的不只是平常的积累和实力，还有很多运气成分。你遇到了什么面试官，面试官对你的评价，直接决定了你能不能来到公司，以及来到公司是做什么的。实习生很多，评价不一样，从事的工作也不一样，有人简单有人难，有人苦逼有人悠闲。这些你控制不了，所以看见别人悠闲的时候，可以想一想是不是你面试的时候表现太好了。面试官对你评价太高了。当然，问题不外乎老生常谈的那些面经上面的问题，但是那是一个坎，过了就过了，没过的加紧学习就好，工作之后会遇到，但是没那么多时间让你去学，所以要你提前储备知识。 关于霸面有人很害怕霸面，有人又觉得霸面不好。其实看人，如果你真的很想要这份offer，厚下脸皮也没什么。当然，霸面只支持小部分人，人太多秩序会乱HR就不愿意了，这是属于工作失职。但是换句话说：如果你连你的面试官都害怕，那以后如果你的隔壁坐着的如果是总监你要怎么面对？所以能霸面的孩子起码这一关是过了，不会胆怯。 关于前端和后台的划分近年来前端很热门大家都知道，但是为什么热门？ 因为出了node，后台能干的前端也能干，但是node对比C++的性能，还是C++比较好，虽然node也可以嵌入C++的代码执行，但是那样前端又要学C++成本就太高了，基本不可能实现。但是少部分的运用还是可以的，比如node直接调用后台底层接口，那样业务逻辑就在node里面了，前端可以直接控制服务器数据的发送，这样前端相对来说自由度就高了点了，相当于网络传输这部分全部划归前端来做（有的业务随时有需要更换后台接口的，接入node这一层之后灵活很多） node会越来越像java，随着ES6的出现与普及，ES6的语法糖会用的越来越多，而这语法糖跟java基本上一样，所以学了java的你，有了ES6写node会如鱼得水 前端要不要学设计？广义上前端有三门语言是必学的HTML和CSS和JavaScript，但是术业专攻要求下HTML和CSS会在一起，JavaScript和各种框架又会在一起。所以有重构和前端开发两种要求，作为一名新手，建议是两种都要学，还有余力可以提高一下设计感。优先级可以这么来分：前端-&gt;后台-&gt;设计/产品/运营(这些在人少的时候应该有接触) 后台应该干什么？写页面吗？错了，现在的后台应该只关注逻辑，关注点在你应该给客户端（各种终端）提供什么样的数据上，如何优化服务器，增加并发，代码架构是否能适应多业务的需求，增删查改的操作能不能做成公共模块直接传入参数搞定。而不是写一个又一个简单的小页面让前端去加样式。有一种趋势是APP嵌入浏览器，然后放的是页面。现在很火的，QQ/微信/Facebook的手机应用，统一都在转换这种方法，而不是用原生的安卓和iOS。所以你会听到ReactNative等等词汇的出现，这种方法也是未来的趋势，道理很简单——减少开发的成本。node也属于后台的范畴，道理与C++相通，后台的同学可以研究下。 前端很牛掰的样子，我去学前端把？任何企业要求的岗位都有其存在的价值，相信存在即合理，认清楚自己的兴趣在哪里，并坚持走下去。不要过度追求潮流和未来的薪水，你会追不上时代的变化的。有句挺有道理的话：你干这事的时候觉得累，那是职业;你干这事的时候不觉得累，那是事业。 实习没进入BAT怎么办？种瓜得瓜，种豆得豆，你现在的处境是你以前造成的，你的未来是你现在造成的。相信自己是金子总会发光，不用妄自菲薄一定要进BAT。适合自己的才是最好的，BAT的工作压力也很大，不一定适合现在的你，在小公司有小公司的悠闲自在。 在学校和在公司的区别是什么？压力，在公司你要担心KPI，留用，HC名额等等。在学校你可以偷懒去外面玩几天，在公司没有这种机会的孩纸。 你的导师和leader会是你的面试官吗？不一定，正常来说你一面的面试官会是你的leader，二面会是总监。但是这是不一定的，有的业务很缺人你也会被调过去用的。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://www.manfredhu.com/tags/杂文/"},{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"}]},{"title":"event.target的亲兄弟event.currentTarget","slug":"17-eventCurrentTarget","date":"2016-05-30T01:32:06.000Z","updated":"2017-04-05T13:45:09.000Z","comments":true,"path":"2016/05/30/17-eventCurrentTarget/","link":"","permalink":"http://www.manfredhu.com/2016/05/30/17-eventCurrentTarget/","excerpt":"","text":"做项目的时候遇到的一个挺好玩的属性，就是event.currentTarget这个东西，可能我们以前用的比较多的是event.target。 场景我们在列表下&lt;li&gt;标签绑定了事件，然后&lt;li&gt;下是一堆的&lt;i&gt; 标签用作动画。并且&lt;li&gt;上有用属性定义着要跳转的地址。 提取例子1234&lt;ul id=\"outer\"&gt; &lt;li id=\"inner\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=\"result\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829body &#123; padding: 25px; font-family: Helvetica, Arial, sans-serif;&#125;#outer &#123; float: left; padding: 50px; margin: 0 0 25px; background-color: #086FA1;&#125;#inner &#123; width: 100px; height: 100px; background-color: #3CA0D0;&#125;#result &#123; clear: left;&#125;code &#123; font-size: 1.2em;&#125;p, ul &#123; margin: 0 0 25px;&#125; 1234567891011121314151617181920212223var outer = document.getElementById('outer'), result = document.getElementById('result');outer.addEventListener('click', function (e) &#123; var html = ''; if (e.target === outer &amp;&amp; e.currentTarget === outer) &#123; html += '&lt;p&gt;Outer element was clicked directly - it is &lt;code&gt;e.target&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;e.currentTarget&lt;/code&gt;.&lt;/p&gt;'; &#125; if (e.target !== outer &amp;&amp; e.currentTarget === outer) &#123; html += '&lt;p&gt;Outer element is the current target, but it was not clicked directly - it is &lt;code&gt;e.currentTarget&lt;/code&gt;.&lt;/p&gt;'; &#125; html += [ '&lt;ul&gt;', '&lt;li&gt;&lt;code&gt;e.target === &amp;lt;div id=\"', e.target.id, '\"&amp;gt;&lt;/code&gt;&lt;/li&gt;', '&lt;li&gt;&lt;code&gt;e.currentTarget === &amp;lt;div id=\"', e.currentTarget.id, '\"&amp;gt;&lt;/code&gt;&lt;/li&gt;', '&lt;/ul&gt;' ].join(''); result.innerHTML = html; &#125;); 总结针对不同的属性，总结两点如下： event.target捕获发出事件的目标，也是就相当于事件的产生者的意思 event.currentTarget则是相当于事件冒泡被设置好监听的对象捕获了。 所以如果遇到外层元素如果设置了监听函数而里面还有其他元素的情况下，为了防止点击里面的元素通过event.target获取不到事件对象，可以用event.currentTarget来获取。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"ES6快速学习","slug":"16-learn-ES6","date":"2016-05-20T11:19:36.000Z","updated":"2017-04-05T13:45:13.000Z","comments":true,"path":"2016/05/20/16-learn-ES6/","link":"","permalink":"http://www.manfredhu.com/2016/05/20/16-learn-ES6/","excerpt":"","text":"ECMAScript6，由ECMA组织发布的一个新的JS语言标准。现在比较火的是一个叫babel的编译器，可以将ES6的语法代码转化为ES5，即现在主流浏览器能支持运行的语言。而React这个火到不行的框架在0.13版本之后将JSX的编译器由JSTransform和react-tools转换到Babel，也顺手将Babel这个支持ES6的编译器带火了，现在React编写已支持ES6语法了。 转化器只是手段，更多的说的话，现在的ES6被推广主要还是减少我们写代码的数量。 能自动化的过程不要手动去解决 这是懒人的标准思维。所以总的来说，未来几年ES6会逐渐普及并被应用于项目。Node都到了6.0了你还有理由不学ES6吗？ 下面一个一个来做例子，推荐scratch.js，一个Chrome浏览器的插件，安装完成在控制台可以看到多了一项选项，点击进去就可以打代码了，打完点击按钮Run就能运行代码了，Toggle output可以让你看到翻译的ES5的语法。 Arrows箭头函数1234567//ES6var a = [9,5,2,7].map(v =&gt; v+1)//ES5var a = [9, 5, 2, 7].map(function (v) &#123; return v + 1;&#125;); 这里将v作为参数传入返回v+1。那如果有多个参数怎么办呢？ 1234567//ES6var a = [9,5,2,7].map((v,k) =&gt; v+1)//ES5var a = [9, 5, 2, 7].map(function (v, k) &#123; return v + 1;&#125;); 其实要注意的一点是ES6的开始拥有块级作用域的概念，如函数里面的this就已经支持了。 12345678910111213141516171819//ES6function pushOne() &#123; this.nums.forEach(v =&gt; &#123; if(v % 2 === 0) &#123; this.arr.push(v); &#125; &#125;)&#125;//ES5function pushOne() &#123; var _this = this; this.nums.forEach(function (v) &#123; if (v % 2 === 0) &#123; _this.arr.push(v); &#125; &#125;);&#125; let和const块级作用域的结构，用let代替var来声明变量那么写法真的就跟Java和C#没什么区别了。12345function f() &#123; let x = 1; console.log(x);&#125;f(); //1 但是如果是下面这样，就不行了12345function f() &#123; &#123;let x = 1;&#125; console.log(x);&#125;f(); 因为let x被{}括起来的块级作用域限定了范围了,再看一个const的例子: 12345function f() &#123; const x = \"pphu\"; console.log(x);&#125;f(); //pphu 但是如果修改了const声明的值，就不行了123456function f() &#123; const x = \"pphu\"; console.log(x); x = \"ManfredHu\";&#125;f(); //Error 其实这些语法都已经成为规范了，不用太去考虑翻译变成什么了，除非浏览器放弃ES6，否则ES6就将火下去。 剩余参数1234function f(x,y,...a) &#123; return (x+y) + a.length&#125;console.log(f(1,2,\"just do it\",true,9527)) //6 展开操作符123var params = ['Hello',true,7];var other = [1,2,...params];console.log(other); //[1, 2, \"Hello\", true, 7] 炫酷没有？直接迭代了params的值copy到other中，我们来试试引用的。 1234var arr = [1,2,3]var params = [arr,'Hello',true,7];var other = [1,2,...params];console.log(other); //[1, 2, Array[3], \"Hello\", true, 7] 翻译的代码是用到了concat来合并数组项的 字符串模板模板这东西，用的多了，没想现在ES6也支持了，所以以后还能用的更爽。123var name = 'ManfredHu' ;var msg = `Hello World ,$&#123;name&#125;!`console.log(msg); //Hello World ,ManfredHu! 这货一出来突然发现以后不用自己拼装字符串了，很多代码习惯全部要改。越来越优雅越来越简单了。 对象 有这么一个关于程序员（媛）的笑话：你想要对象？new一个啊，这么容易 123456let x = 1,y =2;let obj = &#123; x,y //直接声明了obj的x和y属性&#125;console.log(obj.x) //1console.log(obj.y) //2 Class类这个应该是ES6比较有亮点的地方，JAVA和C#都有了类了，C++也是。所以很多童鞋写JavaScript总是有一种找不到方向的感觉。 1234567891011121314151617181920class Shape&#123; constructor(id,x,y)&#123; this.id = id this.move(x,y) &#125; move(x,y)&#123; this.x = x this.y = y &#125;&#125;class Reactangle extends Shape &#123; constructor(id,x,y,width,height)&#123; super(id,x,y) this.width = width this.height = height &#125;&#125;console.log(new Reactangle(1,2,3,10,20)) //Reactangle &#123;id: 1, x: 2, y: 3, width: 10, height: 20&#125; 还可以这么玩1234567var Shape = class&#123; constructor(h,w)&#123; this.h= h this.w= w &#125;&#125;console.log(new Shape(10,20)) //Shape &#123;h: 10, w: 20&#125; static静态方法12345678910class Man&#123; constructor(name)&#123; this.name = name &#125; static getSex()&#123; return &quot;Man&quot; &#125;&#125;console.log(Man.getSex()) //Man 进制的问题12console.log(0b111) //二进制111转化为十进制7console.log(0o11) //八进制11转化为十进制9 解构赋值12345let foo = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];let [a,b,c] = foo;console.log(a) //onwconsole.log(b) //twoconsole.log(c) //three Promise new Promise(fn) 返回一个promise对象 在fn 中指定异步等处理· 处理结果正常的话，调用resolve(处理结果值) 处理结果错误的话，调用reject(Error对象) 两种状态，完成OR拒绝 promise对象被 resolve 时的处理(onFulfilled) promise对象被 reject 时的处理(onRejected) Promise.resolve一般情况下我们都会使用 new Promise()来创建promise对象，但是除此之外我们也可以使用其他方法。静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。 如：1Promise.resolve(42); 可以认为是以下代码的语法糖。123new Promise(function(resolve)&#123; resolve(42);&#125;); 在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.manfredhu.com/tags/ES6/"}]},{"title":"浪潮之巅个人感想","slug":"book-topOfWave","date":"2016-04-20T05:31:46.000Z","updated":"2017-03-13T15:50:55.000Z","comments":true,"path":"2016/04/20/book-topOfWave/","link":"","permalink":"http://www.manfredhu.com/2016/04/20/book-topOfWave/","excerpt":"","text":"作者：ManfredHu链接：http://www.manfredhu.com/2016/04/20/book-topOfWave/声明：版权所有，转载请保留本段信息，否则请不要转载 AT&amp;T 跟随长途通信兴起的企业，后来被美国反垄断法强制分成四个子公司。鼎鼎大名的贝尔实验室，C语言和Unix操作系统诞生的地方，后面被拆分也就没了。 再好的技术也要有好的企业发展方向来主导 IBMIBM注重与政府部门，国企和军队的合作，虽然错失了微机和互联网的浪潮，但是却在历次经济危机中存活了下来，并且现在仍然是世界上员工人数最多、营业额和利润最高的技术公司之一。 好像CVTE也是这种模式，B2B模式，也就是与政府部门、企事业单位合作，这样不会受到市场太大冲击 Apple 乔老爹的经历，堪称传奇吧？大学半年不到，辍学学自己感兴趣的书法课，其实我略好奇一个原来搞技术的人突然去学书法会是怎么样一种心态，不过不得不说，如果程序员有了一丝艺术气息，绝对是一种与众不同的体验。因为身边就有很多这样的例子，字写的非常好看，然后喜欢小清新的那些东西。 如果要说苹果的第一次失败的原因的话，我认为是微软联合了大众将苹果比如绝地，兼容机的横行完全蚕食了苹果的市场，至少在那个全世界还讲求温饱的阶段，能体会苹果工业设计极致和用户体验的人不多。 首先你要能生存下去，然后才是其他方面上的享受。在现在的社会，温饱问题基本不大，所以产品应该更加关注提升用户精神愉悦，用户体验上的方面 还有从苹果技术与对用户体验平衡上的观点来考虑，它的选择是这样的 对用户体验最执着的追求，不管技术实现多么难，总是服务于用户的。看苹果历代的产品就可以看出来。 乔布斯第二次创业的公司，就是一个做动画的公司吧简单来说。反正这也是延续了乔老爹一贯的作风——追求走在时代前面的东西，并且在接下去用户需要的。话说谢霆锋也是创办了一个公司，叫PO朝霆好像，反正感觉国内电影这几年发展迅速，做后期特效的肯定发展非常好。但是最主要的还是觉得霆锋起步非常早，而且坚持了下来，自己又是艺人，有很多资源可以利用。 摩尔定律计算机硬件每18个月价格减半。所以你是不是在等着手机降价？小米的饥饿销售？ 安迪-比尔定律运算速度性能的提高被软件的速度拖慢，但是软件的开发却越来越快越来越工程化。这样就吃掉了硬件性能提升的优势，当然相应的就是软件的功能越来越多，比如我们的APP动辄几百M，一个游戏动辄几十G，这在以前根本无法想象。但是现在已经习以为常了。就这样大鱼吃小鱼，小鱼吃虾米，不停的促进IT行业的进步。 从编程语言来看也是这样的道理 Java效率比C++的低，C++的比C的低，C的比汇编的低 反摩尔定律一个IT公司如果今天和18个月前卖掉同样多同样的产品，则营业额就降低一半。所以为什么说IT公司劳动强度高？其实是有原因的。 大环境逼迫着你需要不停的去进步，去完成安迪-比尔定律的循环 英特尔公司 微机芯片帝国，现在我们在组装电脑的时候可能会有这样的选择：到底买英特尔的CPU还是AMD的？ 别人会告诉你：如果你要稳定就买英特尔的，AMD的虽然便宜但是不好用。 英特尔的芯片基本垄断了PC端的市场，在90年代跟微软组成的WinTel阵营逼迫着IBM放弃PC这块大蛋糕 但是现在也有对手了，随着移动设备兴起的：ARM ARM是一种基于精简指令的处理器，在移动设备如手机，PAD等用的多 如果你还像我高中一样以为芯片只有电脑CPU那种，那就快快改变过来吧。 ARM的模式也挺独特的，它不生产芯片，它只设计芯片，然后让各大厂商去生产芯片，可以说ARM控股公司就是个研究所。但是人家有分钱的，人家赚的是专利。 微软用着WindowXP和Microsoft Office十几年了吧。巨硬（微软）肯定知道的啦。基本上垄断了PC操作系统级别的市场。 当然它还想进军移动操作系统的市场，但是随着安卓和iOS的把控，微软还是没什么戏了感觉。虽然它不止一次想用WinPhone去占领市场，不过还是没有太大作用。 微软垄断了PC端的操作系统、借助捆绑优势进而垄断办公软件、浏览器（IE） Bill Gate和Jobs的交锋也堪称经典，原来的微软只有DOS，而乔布斯的大意让微软有研发Window3的机会。后面乔布斯重回Apple的时候，又是比尔盖茨给他机会翻身。相爱相杀的两个人堪称佳话啊，好像网上还有段视频，是乔布斯对全公司宣布的和微软合作的那个情况，刚宣布是全场哗然，后面说到要为苹果开发Office的时候才有欢呼声。 甲骨文公司甲骨文公司的代表产品——Oracle数据库 不知道大家听过这样的说法没有，IBM的服务器，EMC的存储器，Oracle的数据库。这就是以前的一套企业搭建服务器后台的一套方案了。 当然现在EMC被戴尔收购了。也没有IOE垄断的说法了。这方面是阿里巴巴的功劳。 后面的Oracle趁着经融危机收购了Sun，获得了Java，收购了MySQL,用收购来的东西跟Google打官司。因为Google的安卓就是基于Java的。虽然最后失败了，不过这种并购的手段还是很让人佩服的，原来的Sun臃肿，产品多而不赚钱，但是被Oracle收购后每个东西都能有作用，不管是专利诉讼还是合并，都带动了企业原来的产品技术，或者是为未来的发展铺平了道路。 思科在90年代靠着互联网的热潮，做着路由器兴起的思科公司。 允许自己的员工在公司内部创业，然后收购员工创立的公司。怎么感觉BAT现在的收购有点类似的感觉？ 雅虎最早的门户网站，相当于现在的搜索引擎如百度和Google，用户通过这个去访问别的网站获取资讯。 中国随之诞生的门户网站——搜狐、网易和新浪 当然后面随着搜索引擎的流行，现在门户网站都基本没什么人用了吧。 但是大型的门户网站在赚了第一桶金之后，现在还是能稳定的生存下去。要开始找到另外的增长点，否则只是坐吃山空。 惠普惠普公司的创立，联系到斯坦福大学，就是那个乔布斯读了半年的那个大学。刚开始没有什么名气，后面学校搞了个工业园，更企业合作，校企合作，学校输送人才，企业消化，这样互相发展才真正是进步。 风险投资在我的大学阶段，参加过的创业比赛大大小小不计其数，对其中财务一块算是比较陌生但是却在比赛中占有很大一块比例的。比如通常会有这样的一个表格 注册资本比例 风险投资 众筹 创业团队 无形资产 25% 10% 45% 25% 风投：全称风险投资（Venture Capital），简称VC。大部分是以投资高新技术为主，由职业金融家投入到新兴的、迅速发展的、具有巨大竞争潜力的企业中的一种权益资本。 也可以说，小型的创业团队的发展其实大部分靠的就是风投或者天使投资，这两个概念的区别其实不大，大金额我们会叫风险投资，十几万的会叫天使投资。通常风投会是别的公司或者机构，天使投资会是个人。 GoogleGoogle从诞生的时候就是个传奇，两位创始人在斯坦福大学的帮助下拿到太阳总裁的10万刀的投资，开始了征程。 而且我们或许会听到Google的办公环境多好多好，但是我们或许不会发现一个事实——Google是全世界单位博士聚集数量最多的地方。这是Google对员工的另类补偿可以这么说，如果对一些大牛束缚太多真的就不太好了。这点也是Google觉得做的比较好的地方，当然Google的员工也是真心厉害或者是因为大部分员工都是工程师，所以才可以有这样的“特权”。 或许我们国内的公司会模仿Google的模式，比如有一条可以滑下去几楼高的滑道，但是我发现——上面都是灰，也就是说其实平常是没有人去玩的。。。。。 而Google的是铝合金的。。。。 要说Google的特权那就多了去了，什么上班可以带宠物啊等等，不过其实方针就是体现关爱员工尊重员工罢了，现在的IT公司大部分都会在招聘的时候这样说的。 Google的赢利模式：广告！！靠搜索广告来支撑公司收入，这点和百度差不多，不过百度是竞价排名和出售搜索页面的右侧广告位来赚钱。Google有一点做的比较好的，广告不多，但是收费很高，与搜索结果的相关度比较高。这样导致的结果就是用户会越来越喜欢Google简洁的界面，广告的点击转换率会比较高。 长期发展来说，这样简介和收费高的广告门槛有助于Google保持在普通用户心目中的地位，也让对手无利可图。这点可以跟百度一些查询结果满页都是广告形成鲜明的对比。 毕竟对于一个搜索引擎来说，用户的粘性才是最重要的，变现可以有很多种方法，不需要以牺牲用户体验去变现。 facebook我们老是叫它脸书，其实真的不是一本书。。。facebook基本垄断了现在全世界的社交网络（除了中国大陆）。说到facebook的发家史也是挺好玩的，创始人的意图本来是想着——那个叫约约约？（反正蜀黍我们不约）在大学里面首先流行起来了，因为注册是用学生的邮箱注册的，所以真实度很高。后面随着学生离开大学，facebook就走出了大学校园，开始做社交了。随着社交越做越大，渐渐的有点追赶Google的趋势了，特别是人才的竞争，其实你看一些框架就能看出个大概了，Angular是Google的，React是facebook的。框架当然是要适应他们具体公司的业务需求的。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"读书笔记","slug":"笔记/读书笔记","permalink":"http://www.manfredhu.com/categories/笔记/读书笔记/"}],"tags":[{"name":"book","slug":"book","permalink":"http://www.manfredhu.com/tags/book/"}]},{"title":"JavaScript编程题","slug":"15-veryGoodForUsing","date":"2016-04-02T06:42:57.000Z","updated":"2017-04-05T13:45:17.000Z","comments":true,"path":"2016/04/02/15-veryGoodForUsing/","link":"","permalink":"http://www.manfredhu.com/2016/04/02/15-veryGoodForUsing/","excerpt":"","text":"几道觉得挺有意思的编程题，感觉做下来，自己对一些新方法的看法有了新的变化。比如indexOf,reduce,Array.isArray,forEach这些方法，以前一看到兼容性是IE9+就有点害怕，项目中不敢用，导致后面越来越陌生，不过现在一想的话。其实只要用Polyfill或者提前fix掉就可以了。^_^而且随着浏览器的更新迭代，这些方法肯定会获得更多的支持。 ps:希望新手更要多用这些方法，在特别是学日常学习训练的时候 更新：参加腾讯笔试的编程题，觉得挺有意思的，补上，不过可惜选择语言的时候没有JavaScript。郁闷了好久-_-!! 蛇形矩阵（2016腾讯校招编程题）作为一种常用的数学数列，是由1开始的自然数一次排列成的一个N*N的正方形矩阵，数字一次由外而内的递增，如下面实例： 1234567891011121314151617n=3的蛇形矩阵1 2 38 9 47 6 5n=6的蛇形矩阵 1 2 3 4 5 620 21 22 23 24 719 32 33 34 25 818 31 36 35 26 917 30 29 28 27 1016 15 14 13 12 11此题要求输入蛇形矩阵宽度N，输出整个蛇形矩阵结果，注意输出格式要求按照矩阵从上至下的依次按行输出，每行中间无需换行输出。样本输入： 3样本输出： 1 2 3 8 9 4 7 6 5 自己写的答案（欢迎补充）^_^ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//可以把代码复制到Chrome控制台运行;(function() &#123; function fixIsArray() &#123; if (!Array.isArray) &#123; Array.isArray = function(arr) &#123; return Object.prototype.toString.call(arr).slice(8, -1) === \"Array\"; &#125; &#125; &#125; fixIsArray(); //fix Array.isArray（Array.isArray在IE9+支持） function Arr2D(d) &#123; if (typeof d !== 'number') throw new Error('Arr2D():arguments d must be number'); this.d = d; this.arr = this.init2DArr(d); &#125; Arr2D.prototype.reat2DArr = function() &#123; var c = 0, //环数 i = 0, //行 j = 0, //列 out = 1, //总数 z, n = this.d, a = this.arr; //检验参数 if (!Array.isArray(a)) throw new Error('reat2DArr():arguments a must be Array'); if (typeof n !== 'number') throw new Error('reat2DArr():arguments n must be Number'); z = n * n; while (out &lt;= z) &#123; i = 0; /*每轮后初始化下i,j*/ j = 0; for (i += c, j += c; j &lt; n - c; j++) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; for (j--, i = i + 1; i &lt; n - c; i++) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; for (i--, j = j - 1; j &gt;= c; j--) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; for (j++, i = i - 1; i &gt; c; i--) &#123; if (out &gt; z) break; a[i][j] = out++; &#125; c++; &#125; return this; &#125;; Arr2D.prototype.printArr = function() &#123; var a = this.arr, n = this.d, lineStr; if (!Array.isArray(a)) throw new Error('printArr():arguments a must be Array'); for (i = 0; i &lt; n; i++) &#123; lineStr = \"\"; for (j = 0; j &lt; n; j++) &#123; lineStr += ' ' + a[i][j]; &#125; console.log(lineStr); &#125; return this; &#125;; //初始化二维矩形数组 Arr2D.prototype.init2DArr = function(m) &#123; var arr = [], i, j; for (i = 0; i &lt; m; i++) &#123; arr[i] = []; for (j = 0; j &lt; m; j++) &#123; arr[i][j] = 0; &#125; &#125; return arr; &#125;; //调用函数,测试数据数据为3 var arr = new Arr2D(3); arr.reat2DArr().printArr();&#125;)(); 大招来了：特别的回文字符串（2016腾讯校招编程题）所谓回文字符串，就是一个字符串，从左到右和从右到左读是完全一样的。比如”aba”、”c”。对于一个字符串，可以通过删除某些字符而变成回文字符串，如”cabebaf”，删除’c’,’e’,’f’后剩下子串’abba’就是回文字符串。要求，给定任意一个字符串，字符串最大长度1000，计算出最长的回文字符串长度。如’cabebaf’的回文字符串包括’c’,’aba’,’abba’等，最长回文”abba”长度为4。输入：字符串输出：最大的回文字符串长度。示例：输入：cabbeaf输出：4 问题：个人是觉得上面这道题的描述是有问题的，比如cabebaf，那么abeba算不算回文？通常应该是算的。但是按照题目的意思则是abba才算回文，abeba是不算的。 而且这里有干扰项，输入示例的cabbeaf中，要删除字符e才能检测出回文abba。所以这跟普通的回文判断完全不一样。 普通的估计用这样的方法就能判断了 12345//判断如abba,abeba这样的字符串function testArr(str) &#123; //将字符串切割为字符数组，倒序反转再判断跟原来的字符串是否一样 return str.split('').reverse().join('') === str;&#125; 但是这里不是普通的题目，所以刚开始我想的是用indexOf和lastIndexOf来做，通过字符串的逐渐缩小范围，indexOf和lastIndexOf又可以避免要删除字符e的尴尬。 12345678910111213141516171819202122232425262728293031323334353637383940;(function() &#123; //输入：cabbeaf //4 String.prototype.roundWord = function() &#123; var i = 0, str = this, count = 0, //回文计数 left, right = str.length - 1, max = 0, flag = false; if (str.length &lt;= 0) throw new Error(\"roundWord(): arguments str/this must be string\"); while (i &lt; str.length) &#123; charOne = str.charAt(i); left = str.indexOf(charOne, i); if (!flag) &#123; right = str.lastIndexOf(charOne); &#125; else &#123; right = str.lastIndexOf(charOne, right); &#125; if (left !== right &amp;&amp; left &lt; right) &#123; //头尾有相同字符 if (++count &gt;= max) max = count; flag = true; //开始有回文 &#125; i++; &#125; return count*2; &#125;; var str = \"cababeacf123\"; console.log(str.roundWord()); //6 str = \"cabbeaf\"; console.log(str.roundWord()); //4&#125;)(); 用reduce统计一个数组中单词出现的次数1234567891011var arr = [\"apple\",\"orange\",\"apple\",\"orange\",\"pear\",\"orange\"]; function getWordCnt()&#123; //以下应掏空 return arr.reduce(function(prev,next,index,arr)&#123; prev[next] = (prev[next] + 1) || 1; //这句是重点,刚开始都是undefined的时候undefined+1会是NaN return prev; &#125;,&#123;&#125;);&#125; console.log(getWordCnt()); 注意：这里传入了{}作为初始参数，所以第一个prev会是一个空对象，所以第一次的prev[next]会是undefined，而这里用了赋值 给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false1234function containsRepeatingLetter(str) &#123; //以下应掏空 return /([a-zA-Z])\\1/.test(str); // \\1指代第一个括号的匹配项&#125; 在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\\1就是引用第一个分组，\\2就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。 已知fn为一个预定义函数，实现函数curryIt需要补全的代码12345678var fn = function(a, b, c) &#123; return a + b + c&#125;;curryIt(fn)(1)(2)(3); //6function curryIt(fn) &#123; //这里补充&#125; 可以试着玩一下，这里是用的函数的柯里化 1234567891011121314151617181920var fn = function(a, b, c) &#123; return a + b + c&#125;;console.log(curryIt(fn)(1)(2)(3)); //6function curryIt(fn) &#123; //以下应掏空 if(typeof fn !== 'function') throw new Error(\"curryIt():fn must be function\"); var len = fn.length; //获取函数形参数量 var slice = Array.prototype.slice; var arg = slice.call(arguments, 1); return function() &#123; arg = arg.concat(slice.call(arguments)); if(arg.length &lt; len) &#123; //当等于函数需要的形参数量时候调用 return arguments.callee; &#125;else&#123; return fn.apply(null,arg); &#125; &#125;&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"SublimeText3常用快捷键和优秀插件（亲测）","slug":"11-SublimeText3Plug","date":"2016-03-26T19:26:48.000Z","updated":"2017-01-18T07:21:23.000Z","comments":true,"path":"2016/03/27/11-SublimeText3Plug/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/11-SublimeText3Plug/","excerpt":"","text":"这篇是自己在之前的博客写的，貌似慕课拿了5000+的Page view，其他各种转载就不说了。 2016/5/29更新MarkDown插件 SublimeText是前端的一个神器，以其精简和可DIY而让广大fans疯狂。好吧不吹了直入正题 -_-!! 首先是安装，如果你有什么软件管家的话搜一下就好，一键安装。然后，有钱的土豪就自己买个吧，穷逼就搜下注册码看下有没有土豪共享咯。 既然是神器，肯定有你不知道的东西不是，下面这部分来讲操作。PS：大部分图片和文字来自网络，这里只是略微排版方便查阅。 测试操作系统：Win10测试软件版本：SublimeText3 3059 SublimeText3 操作部分就近选择相同项: ctrl+d把光标放在一个单词上，按下ctrl+d，将选择这个单词。一直按住ctrl且按D多次，将选择当前选中项的下一个匹配项。通过按住ctrl，再按D三次，将选择三个相同的文本。 选择当前文件所有匹配项: alt+f3选择文件中的所有匹配项。小心使用这个，因为它能选择一个文件中的所有匹配项. . 选择文本的包裹标签: ctrl+shift+’ （ESC键下面的那个）这是一个法宝。也许你希望所有属性保持不变，但只是想选择标签。这个快捷键为你这样做，会注意到你可以在一次操作多个标签。ps：需要Emmet插件（可以直接到后面看插件的安装） 向上扩展一层: ctrl+shift+a如果你把光标放在文本间再按下上面的键将选择文本，就像ctrl+d。但是再次按下它，将选择父容器，再按，将选择父容器的父容器。ps：需要Emmet插件（可以直接到后面看插件的安装） 选择括号内的内容: ctrl+shift+m这有助于选择括号之间的一切。同样适用于CSS。 选择括号内的内容: ctrl+shift+↑或 ctrl+shift+↓ 选择括号内的内容: ctrl+shift+d如果你已经选中了文本，它会复制你的选中项。否则，把光标放在行上，会复制整行。 增加和减少缩进: ctrl+[ 或 ] 单行剪辑或选中项: ctrl+x 粘贴并复制格式: ctrl+shift+v 用标签包裹行或选中项: alt+shift+w 移除未闭合的容器元素: ctrl+shift+;这会移除与你的光标相关的父标签。对清除标记很有帮助。 大写和小写: 大写ctrl+k+u、小写ctrl+k+l 注释选中项/行: ctrl+/这个在所有语言下都可用， 对行和选中项都可用。 删除一行: ctrl+shift+k SublimeText3 插件部分首先是安装包管理器Package Control，SublimeText3的指令已经更新了，SublimeText2更新上来的童鞋注意下Ctrl+`打开控制台或者View-&gt;Show Console菜单打开命令行 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 就是上面这串东西了，然后就可以接下来的安装插件了 Tips: 插件名字链接到github，网络不好的童鞋自行下载包扔到Preferences-&gt;Browse Packages打开的文件夹下面，然后解压，重启Sublime就行 emmet这个没有什么好说的，类似jQuery的语法，编码蹭蹭往上提。不过要求PyV8环境（安装完后你会看到有一个文件夹），最好还是选择在线装吧。ctrl+shift+P 输入 install Package 等待读取服务器列表，输入emmet第一个就是了ps：最好看一下github里面的简单教程 侧边栏增强插件SideBarEnhancements这个也没有什么好说的，谁用谁知道，大大增强右键列表的功能，装上就能用。 控制台呼出插件Terminal用node，Grunt等等要调出控制台的娃知道的，简直神奇有木有，装上就能用。 Tips:快捷键 ctrl+shift+T呼出当前文件路径的控制台在Mac下时command+shift+t哈，也可以设置呼出的为iTerm2 具体的看这里iTerm的版本自己打开iTerm看看，2的设置不一样的。可以加打开文件的参数，这样打开就在你的文件对应的目录下了，简单有效。 代码提示插件SublimeCodeIntel这个也没什么废话吧，支持多语言的高速编码的代码提示工具。装上后还不能直接使用，查了一下原因要配置你可以点击Preferences-&gt;Browse Packages-&gt;SublimeCodeIntel然后添加一个.codeintel文件夹再再在文件夹里面添加一个config文件（Windows创建.codeintel文件夹需要输入.codeintel.） config文件配置： 1234567891011121314151617181920212223242526&#123; &quot;PHP&quot;: &#123; &quot;php&quot;: &apos;/usr/bin/php&apos;, &quot;phpExtraPaths&quot;: [], &quot;phpConfigFile&quot;: &apos;php.ini&apos; &#125;, &quot;JavaScript&quot;: &#123; &quot;javascriptExtraPaths&quot;: [] &#125;, &quot;Perl&quot;: &#123; &quot;perl&quot;: &quot;/usr/bin/perl&quot;, &quot;perlExtraPaths&quot;: [] &#125;, &quot;Ruby&quot;: &#123; &quot;ruby&quot;: &quot;/usr/bin/ruby&quot;, &quot;rubyExtraPaths&quot;: [] &#125;, &quot;Python&quot;: &#123; &quot;python&quot;: &apos;/usr/bin/python&apos;, &quot;pythonExtraPaths&quot;: [] &#125;, &quot;Python3&quot;: &#123; &quot;python&quot;: &apos;/usr/bin/python3&apos;, &quot;pythonExtraPaths&quot;: [] &#125;&#125; 其实只要有JS就够了，不过或许某天你要写PHP了呢是吧，留着吧。 然后打开Sublime创建个文件试一下，如果还不行就按下 ctrl+shift+space 开启提示功能 代码排版插件Sublime-HTMLPrettify以前用的是什么TAG，CssComb和JSFormat，但是某一天发现这款集成prettify的插件后就一直没换过了,不要被插件的HTML迷惑，这是一款可以用于HTML，CSS，Javascript的集成排版插件 Tips:安装完快捷键ctrl+shift+h 一键格式化代码 CSS3前缀补充插件Autoprefixerctrl+shift+P 输入 install Package 等待读取服务器列表，输入autoprefixer第一个就是了要装Node.js，没有的话去下载安装吧插件使用CanIUse资料库，能精准判断哪些属性需要什么前缀 Tips:使用方法：在输入CSS3属性后（冒号前）按Tab键 SublimeText3 添加右键菜单和快捷开启浏览器添加右键菜单有时候要开个文件要开个SublimeText3，又要拉文件，麻烦。这里介绍将Sublime添加到右键菜单。 打开注册表，开始→运行→regedit 在 HKEY_CLASSSES_ROOT→ * → Shell 下面新建项命名为SublimeText 右键SublimeText项，新建字符串值，命名为Icon，值为 “sublime_text.exe所在路径,0”，例如：C:\\Program Files\\Sublime Text 3\\sublime_text.exe,0 右键SublimeText项，新建项，命名为command，默认值为 “sublime_text.exe所在路径 %1”，例如：C:\\Program Files\\Sublime Text 3\\sublime_text.exe %1 一键浏览文件Preferences-&gt;Key Bindings - User打开用户快捷键设置，copy下面的设置 123456789101112131415161718192021222324252627282930313233343536373839404142[ //firefox &#123; &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //chorme &#123; &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Users\\\\manfr\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //IE &#123; &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //safari &#123; &quot;keys&quot;: [&quot;f4&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;C:\\\\Program Files (x86)\\\\Safari\\\\Safari.exe&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;] 稍微解释下，keys是按键，application是浏览器应用程序路径，注意反斜杠的要转义。extensions是匹配所有的文件后缀格式。 Tips:查了下默认的快捷键，SublimeText3中f1-f12中只有f11被默认为全屏命令，其他的没设置。也就是说，你可以装十个八个浏览器一字排开按过去测试。 SublimeText3 问题部分（自己遇到过的）自动更新有时候会弹出自动更新的框，解决方法： 找到Preferences -&gt; Settings-User（设置用户） 在最后一个花括号结尾（“｝”）前添加一句：&quot;update_check&quot;:false 然后请关闭Submine Text并重启，即不会再弹出更新提醒了 不能获取插件列表 Package Control：There are no packages available for installation cmd下输入ping sublime.wbond.net链接一下看下sublime.wbond.net这个域名的ip 打开C:\\Windows\\system32\\drivers\\etc\\hosts文件。在最后面加上例如 50.116.34.243 sublime.wbond.net这样的对应关系，IP是上面测试的 然后请关闭Submine Text并重启，即不会再弹出更新提醒了 参考Sublime Text 3前端开发常用优秀插件介绍——黄映焜Gif多图：我常用的 16 个 Sublime Text 快捷键 | 氪星人 补充Ubantu配置部分（补）最近在玩Ubantu，所以将环境切了过去。这里补充一下吧。 装SublimeText3首先是安装，试了一下SublimeText2的（去官网默认就是下的2的-_-!!）发现调不出安装包列表，后面也没去详细研究直接下了个SublimeText3的安装包装上。附上Ubantu下SublimeText3-64bit的链接：http://www.sublimetext.com/3 装node插件的安装跟上文差不多，唯一比较苦逼的就是装node（插件依赖node环境）的时候了，不知道为什么安装好了输入node -v老是没有显示版本，搞了好久最后无奈去Github下了个node的安装包才搞定。 Tips:一定要确认node -v和npm -v可以输出版本号才表示node安装完成 附上ubantu装node的N种方法的帖子：http://www.linuxidc.com/Linux/2015-07/119588.htm 一键浏览文件还有就是设置一键浏览文件的时候了，浏览器安装的目录跟Windows有点区别，看下面： 12345678910111213141516171819202122[ //firefox &#123; &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;/usr/lib/firefox/firefox&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;, //chorme &#123; &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: &#123; &quot;paths&quot;: [], &quot;application&quot;: &quot;/opt/google/chrome/google-chrome&quot;, &quot;extensions&quot;: &quot;.*&quot; &#125; &#125;] 火狐是Ubantu自带的，目录如上。然后chrome是我自己装的，基本上也应该是这个目录。装好之后找个文件按F1和F2检测下就好。搞下来其实觉得没什么，主要是刚接触Ubantu系统对一些东西不太熟悉，后面加强。Thx ^_^ MarkDown插件MarkdownEditing这货很不错，快捷键什么都有了。具体的可以看github的介绍 markdown-preview这个插件是实时预览的插件，把下面这段加在Preferences-&gt;Key Bindings-User下就可以按ctrl+m预览了。12345&#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview_select&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;&#125; &#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"Sublime","slug":"Sublime","permalink":"http://www.manfredhu.com/tags/Sublime/"}]},{"title":"JavaScript的动态特性(通过eval,call,apply和bind来体现)","slug":"12-EvalCallApplyBind","date":"2016-03-26T16:45:01.000Z","updated":"2017-01-18T07:11:40.000Z","comments":true,"path":"2016/03/27/12-EvalCallApplyBind/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/12-EvalCallApplyBind/","excerpt":"","text":"JavaScript是一种基于面向对象的、函数式的、动态的编程语言。现在发展到已经可以用在浏览器和服务器端了。 这里不谈面向对象，也不去提及函数式编程，就单单讨论动态性。什么称为动态？ 语言的动态性，是指程序在运行时可以改变其结构。 通俗地说就是没运行你根本不知道这段代码会出现什么情况，可能某个变量跟声明的时候不一样了，可能某个函数的作用域变了。如果有用到动态特性，很多时候你只能凭借经验来判断这段代码的执行流程。 个人觉得JavaScript的动态性可以用下面几个函数的使用来总结 eval apply和call bind eval函数123eval(alert(\"汪峰又上头条了！\")); // --&gt;汪峰又上头条了！alert(window.eval === eval); // --&gt;truealert(eval in window); // --&gt;false 这里大概能看明白用法了，eval是一个挂载在window对象下面的函数，而且eval是不可枚举的。 eval函数的动态性体现在可以在脚本执行的时候，动态改变某些东西。 上面的例子就体现了这点，eval()括号里面可以执行语句，可以在程序执行的时候动态改变某些东西。 下面来讨论eval函数另外一个比较坑爹的问题：eval的作用域问题 举个栗子： 12345678var i = 100;function myFunc() &#123; var i = \"text\"; window.eval('i = \"hello\"'); alert(i); // 现代浏览器提示text，IE6-8提示hello&#125;myFunc();alert(i); // 现代浏览器提示hello，IE6-8提示100 为什么会这样呢？ 原因就是不同的浏览器JS引擎对eval函数的作用域设定是不一样的。这里我们指定的window.eval函数，意在让i的值改为hello字符串。但是不同浏览器JS解析内核对eval函数的作用域的设定是不同的，IE6-8因为用的是JScript内核，所以eval读到i是myFunc函数里面的var i = &quot;text&quot;的i，所以将myFunc函数里面的text改为hello之后就是显示hello了。而现代浏览器则认为window.eval是改变的是全局i=100的值。 那如果window.eval改为eval呢？ 1234567var i = 100;function myFunc() &#123; var i = \"text\"; eval('i = \"hello\"'); &#125;myFunc();alert(i); // --&gt;100 恭喜恭喜^_^，这里的eval没有指定window作用域，所以浏览器统一输出100。 eval函数默认改变的就是当前作用域下的变量值。 附上常见浏览器JS引擎和内核的列表（不完全）： 公司 浏览器 JS引擎 渲染引擎 Microsoft IE6-8 JScritp Trident IE9-11 Chakra Trident Edge Chakra Edge Mozilla Firefox JagerMonkey Gecko Google Chrome V8 Blink Apple Safari Webkit SquirrelFish Extreme Opera Opera12.16+ Blink Carakan 这些只是属于JS引擎和内核的一部分而已（现有的），其他版本的请自行搜索。 apply和callapply和call的基本用法apply和call的使用非常相似，举个栗子： 12345678910var name = \"JaminQian\", obj = &#123; name: \"ManfredHu\" &#125;;function myFunc() &#123; alert(this.name);&#125;myFunc(); // --&gt;JaminQianmyFunc.call(obj); // --&gt;ManfredHu 这里的作用就是改变this的指向，我们知道this其实在不同的环境下的指向是不一样的。有时候是window全局对象，有时候是某个对象，通过apply和call，我们就可以随意改变函数里面this的指向来达到我们的动态性。 再看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435function Animal()&#123; this.name = \"Animal\"; this.args = arguments; //在实例上缓存构造函数的参数 this.showName = function()&#123; console.log(this.name); &#125;; this.getArgsNum = function()&#123; console.log(this.args); &#125;&#125; function Cat(num1,num2,num3)&#123; Animal.apply(this,arguments); //继承Animal this.name = \"Cat\";&#125;function PersianCat()&#123; //波斯猫 Cat.apply(this,arguments); //继承Cat this.name = \"PersianCat\";&#125;var animal = new Animal(); var cat = new Cat(1,2,3);var PersianCat = new PersianCat([1,\"2\",[3]]);//输出this.nameanimal.showName(); //--&gt;Animalanimal.showName.call(cat); //--&gt;Catanimal.showName.call(PersianCat); //--&gt;PersianCat//获取构造函数的参数animal.getArgsNum(); //--&gt;[]cat.getArgsNum(); //--&gt;[1,2,3]PersianCat.getArgsNum();//--&gt;[[1,\"2\",[3]]] 这里的生物链是Animal-&gt;Cat-&gt;PersianCat(波斯猫)，生物学的不好不知道对不对暂且忽略哈^_^。然后是不停的用call在构造函数继承父类的属性（借用构造函数继承，也称为对象冒充），但是又有自己的特殊属性name，也就模仿着实现了面向对象的继承与多态。 最后是apply一个最常用的做法，将参数毫无保留地传递到另外一个函数上。 apply和call的实用用法获取数组的最大值、最小值如果让你来用JS求一个数组的最大值最小值的方法的话，你可能回想到遍历，可能会问下是不是有序的，用折半查找算法。但是这里的用法是比较巧妙滴。 12345678910111213var numbers = [5,\"30\",-1,6, //这里定义了一个数组，numbers[1]是一个字符串\"30\" &#123; a:20, //其中最后一个元素是一个对象，重写了valueOf方法 valueOf:function() &#123; return 40 &#125; &#125;,];//求数组的最大最小值var max = Math.max.apply(Math,numbers), min = Math.min.call(Math,-10,2,6,10);console.log(max); //--&gt;40console.log(min); //--&gt;-10 大概说一下：我们知道JS是非常懒的，只有当需要字符串的时候会去调用Object.prototype.toString()方法转化成字符串，而当需要数值的时候去调用Object.prototype.valueOf()方法转化为数字。这里就是用到了valueOf来转化字符串&quot;30&quot;为数值30了。当然如果全部是数字的情况就更简单了，这里不赘述了。 在原来的数组追加项如果有人问你要合并两个数组要怎么做？ 你可以会想到Array.prototype.concat()方法 123456var arr1 = [22, 'foo', &#123; age: \"21\"&#125;, -2046];var arr2 = [\"do\", 55, 100];var arr3 = arr1.concat(arr2);console.log(arr3); //--&gt;[22, \"foo\", Object, -2046, \"do\", 55, 100] OK合并完成，你也可能会想到用循环arr2然后push每一项到arr1的方法。 那比较优雅的合并数组的方法呢？狗血编剧肯定会写有的啦。 123456var arr1 = [22, 'foo', &#123; age: \"21\"&#125;, -2046];var arr2 = [\"do\", 55, 100];Array.prototype.push.apply(arr1,arr2); //注意这里用的是apply，传入的是数组console.log(arr1); //--&gt;[22, \"foo\", Object, -2046, \"do\", 55, 100] 有没有一种四两拨千斤的赶脚？ 验证数组类型某天，BOSS要你将AB两个同事的代码重构一下提升下效率，那么对于重复的部分肯定要抽象出来。嗯，两边都有一个检测数组的操作，很自然，你要封装一个isArray函数来判断。 然后你一拍大腿，丫的不是有原生的判断isArray的方法了吗？OK你搜了一遍发现了一个坑爹的问题：IE9+才有Array.isArray()方法，那OK，做好兼容不就行了嘛？ 1234567function isArray(value) &#123; if(typeof Array.isArray === \"function\") &#123; //ES5新增加的判断数组的方法，IE9+支持 return Array.isArray(value); &#125; else &#123; return Object.prototype.toString.call(value) === \"[object Array]\"; &#125;&#125; 逻辑非常简单粗暴，就是下面的兼容的方法要仔细看下，原理就是数组调用Object.prototype.toString()的时候会返回&quot;[object Array]&quot;字符串。当然这里可以扩展下，类型检测大体来说基本类型检测用typeof是够的，像number, string,boolean,undefined都可以用typof检测。对于自定义引用类型的话用instanceof和Object.prototype.hasOwnProperty或者constructor属性也是够的。 比较容易出错的地方在检测数组和检测函数这两个地方，特别是有iframe的地方，原来的检测方法失效，所以要特别注意。 检测数组如上所述，是比较公认的方法。检测函数的话用typeof foo === &quot;function&quot;(假定foo是一个函数)来检测。 类数组用数组的方法类数组是什么就不说了，有兴趣的可以翻一下之前的文章，搜一下类数组或者array-like就有了。 其实这里用的最多的，估计就是jQuery了，抽象一下jQuery源码的用法。或者你可以去Look下有加了点中文注释版的jQuery源码，下面代码不能运行，只是加深下理解而已。 12345var arr = [];var slice = arr.slice; //数组的slice方法toArray: function() &#123; return slice.call( this ); //这里就是可以将类数组转化为可以用原生数组的一个方法&#125; 类数组转化为数组的方法不外乎两种：一种是slice，一种是concat。 bind函数jQuery中的bind方法说到bind这里本篇的正题就到了，什么是bind？如果你用老版本的jQuery用的比较多你可能经常会这样写（jQuery1.7+之后是推荐用on来绑定事件的）： 123$( \"#foo\" ).bind( \"click\", function() &#123; alert( \"User clicked on 'foo.'\" );&#125;); 意思非常明确了，就是给id为foo的元素绑定click事件和一个匿名的回调函数。 当然你也可以绑定多种类型的事件 123$( \"#foo\" ).bind( \"mouseenter mouseleave\", function() &#123; $( this ).toggleClass( \"entered\" );&#125;); 更详细的用法请参考jQuery官网的.bind()的API 原生JavaScript中的bind方法还有一种是原生的bind函数，在ECMAScript5为Function.prototype添加了一些原生的扩展方法，其中就包括Function.prototype.bind。 不信的话你可以在谷歌或者火狐下运行下下面的代码看看，IE就比较傻逼了，IE9+才支持bind方法。 1console.log(Function.prototype.bind); //--&gt;bind() &#123; [native code] &#125; 老式浏览器兼容bind的方法(来自MDN)： 1234567891011121314151617181920212223if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== \"function\") &#123; //调用的不是函数的时候抛出类型错误 throw new TypeError(\"Function.prototype.bind() error\"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //缓存this，调用返回的函数时候会用到 fNOP = function () &#123;&#125;, fBound = function () &#123; //用闭包缓存了绑定时候赋予的参数，在调用的时候将绑定和调用的参数拼接起来 return fToBind.apply(this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 下面我们来看下JS原生bind的基本用法： 123456789101112131415function foo() &#123; console.log(this.name); console.log(arguments);&#125;var obj = &#123; name: 'ManfredHu'&#125;//将foo绑定obj的作用域，返回一个绑定了作用域的新的函数var newFunc = foo.bind(obj, '我是参数1', '我是参数2'); newFunc(); //output:(最好自己试一下)//ManfredHu//Arguments[2] 0: \"我是参数1\" 1: \"我是参数2\" so，其实用法也很简单。原理简单说一下：bind将原来的函数copy了一份，并且绑定了copy副本的上下文。当然这里的上下文体现出来的就是this的指向了，而且后面就算你想改都改不了。 1234567891011var obj = &#123;&#125;;function foo() &#123; return this;&#125;var foo2 = foo.bind(obj); //复制函数绑定上下文var obj2 = &#123;&#125;;obj2.foo2 = foo2;console.log(obj === foo2()); //--&gt;trueconsole.log(obj === window.foo2()); //--&gt;trueconsole.log(obj === obj2.foo2()); //--&gt;true 这里尝试用window和obj2来改变函数运行的上下文，都没有成功。 下面就是终结部分了，比较高能。 某天闲逛时候看到了一篇很有趣的译文，起初看了下，有的地方没看的太懂，而且也赶着去做别的事，就先搁一边了，后面有空去看的时候发现这篇译文，或者说是代码。灰常犀利，不管是作用还是写法处处都将JS的动态特性体现得淋漓尽致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var context = &#123; foo: \"bar\" &#125;;function returnFoo () &#123; //返回this.foo的简单函数 return this.foo;&#125;returnFoo(); //--&gt;undefined（因为window.foo不存在）var bound = returnFoo.bind(context); //用bind绑定函数上下文bound(); //--&gt;\"bar\"（因为上面被绑定了上下文了，这里输出context.foo）returnFoo.call(context); //--&gt; bar（call的基本用法）returnFoo.apply(context); //--&gt; barcontext.returnFoo = returnFoo; //将函数引用赋给context对象context.returnFoo(); //--&gt; bar（returnFoo函数里面的this是context）//----------------------------------------------------------------------- // 上面的应该都不会很难，下面是比较实用的部分，每一句都要看得懂之后才往下看//-----------------------------------------------------------------------[1,2,3].slice(0,1); //--&gt;[1]（简单的分割数组，比较麻烦是不是）var slice = Array.prototype.slice; //更简单的做法，将原型上的slice方法缓存到本地，方便快捷调用//因为没有绑定上下文，slice也不知道去截取哪个数组slice(0, 1); //--&gt; TypeError: can't convert undefined to object//同上，还是因为没有绑定上下文，slice也不知道去截取哪个数组slice([1,2,3], 0, 1); //--&gt; TypeError: ...//绑定了上下文，跟上面的[1,2,3].slice(0,1);一样，但是slice方法被封装起来了slice.call([1,2,3], 0, 1); //--&gt; [1]//跟上面差不多，只是换成了apply方法的调用，参数变成了数组的形式slice.apply([1,2,3], [0,1]); //--&gt; [1]//精髓的一句，上面的演进只是为了解释这一句而已，整个的思想就是“封装”，方便调用//就是将slice.call这句简写成slice一句就完成了//我们上面其实用的很多都是函数绑定对象，但是却忘记了其实JS函数也是对象，也可以被绑定//这里将slice当作对象，用call去绑定它，返回一个绑定了的函数，方便后面复用，也就是缓存的作用slice = Function.prototype.call.bind(Array.prototype.slice);//跟上面的slice.call([1,2,3], 0, 1);对比一下发现原来把call封装到slice里面去了slice([1,2,3], 0, 1); //--&gt; [1]//上面一句看懂了这句就很好懂了，bind.call省略为bind的意思var bind = Function.prototype.call.bind(Function.prototype.bind);//OK，经过我们的处理，slice和bind的功能都很厉害了//回到最初的例子var context = &#123; foo: \"bar\" &#125;;function returnFoo () &#123; return this.foo;&#125;//现在来使用神奇的\"bind\"函数//bind(function,context)//@function 待绑定上下文的函数//@context 绑定的上下文//@return 返回一个绑定了上下文的函数//按照以前的书写顺序是这样的:returnFoo.bind(context,[args1,args2……])//书写顺序完全改变了有木有？封装起来了有木有？var amazing = bind(returnFoo, context);amazing(); // --&gt; bar 总结 bind和call以及apply都可以动态改变函数执行的上下文，可以说很好地体现了JavaScript的动态特性 JavaScript的动态特性远不止上面的eval(),call/apply,bind()这些 多试着用这些东西，可以更好地理解JS这门语言，而且，代码会变得优雅，代码量复用的几率也会增大 引用参考：MDN官方文档——Function.prototype.bind()张小俊128——Javascript中的Bind，Call和Apply","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"JavaScript中this关键字的使用比较","slug":"14-thisKeyWords","date":"2016-03-26T16:24:33.000Z","updated":"2017-03-13T15:41:59.000Z","comments":true,"path":"2016/03/27/14-thisKeyWords/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/14-thisKeyWords/","excerpt":"","text":"这篇是自己在之前的博客写的，各种转载就不说了。 this关键字在JavaScript中，用的不能说比较多，而是非常多。那么熟悉this关键字的各种用法则显得非常关键。 this有时候就是我们经常说的上下文，这个东西的指代对象。它灵活多变，有时候你看它是对象，有时候是window宿主对象。 this指向宿主对象123456function myWindow() &#123; this.id = 1; // 等价于window.id = 1 console.log(this); // 这里的this就是window了 console.log(this.id); // 1&#125;myWindow(); 这种情况比较普遍，也就是指向宿主对象的情况，在客户端是 window对象 在node里是 Global对象 第一个说，下面看第二种。 this指向调用函数的对象的时候1234567function myObj() &#123; console.log(this.x); // 在这个例子里面是obj对象&#125;var obj = &#123;&#125;;obj.x = \"xx\";obj.myObj = myObj;obj.myObj(); // xx 这里的myObj()函数里面的 this 指向的就是obj这个外部传递来的对象了。注意看 obj.myObj() 这里前面的 obj. 这里，因为myObj是obj这个对象的方法，下面obj作为对象调用了myObj这个函数，所以这里的this就是指向调用函数的对象了。 this指向构造函数生成的新对象的时候12345678910111213// 作为构造函数的函数记得首字母要大写function People(gender) &#123; this.gender = gender; this.sayGender = function() &#123; console.log(this.gender); &#125;&#125;// 输出man,函数this是新的People&#123;&#125;对象var girl = new People(\"women\"); // 输出women,函数this是指向girl&#123;gender:\"women\"&#125;对象girl.sayGender(); 这里的执行过程理一下，首先 new People(&quot;man&quot;) 这句做了几件事情： 根据构造函数创建一个空的对象People{} 然后传递到People里面（这里才叫开始构造的过程，添砖加瓦的意思） 然后这里开始的函数里面的this就是指向传进来新的People{}对象了 这里就是构造函数生成对象的一个简单的过程了，可以自己模拟着执行以下。 this指向需要继承属性的对象的时候（apply和call）123456789101112function People(gender) &#123; this.gender = gender; this.sayGender = function() &#123; console.log(this.gender); &#125;&#125;var sally = new People(\"women\");var bob = &#123; // bob是直接量创建的,但是没有sayGender方法可以用 gender: \"man\";&#125; 所以这里如果bob要用 sayGender() 方法的话要怎么破呢？这个时候就要用到 apply() 或者 call() 了，这两个方法差不多。 apply(obj, arguments) 这里的arguments是一个参数数组 call(obj,argument) 这里没有复数 所以bob要调用 sayGender() 的话，就要用到 call() 方法或者 apply() 方法了。 这个其实可以理解为继承的一种，Java里面继承分为实现继承跟接口继承两种，JavaScript的继承是只有实现继承的，但是实现继承JavaScript里面又有很多种，比如原型链继承，还有这里的 apply() 和 call() 也算是继承的一种。 123456789101112131415function People(gender) &#123; this.gender = gender; this.sayGender = function(str) &#123; console.log(this.gender); &#125;&#125;var sally = new People(\"women\");var bob = &#123; // bob是直接量创建的,但是没有sayGender方法可以用 gender: \"man\";&#125;sally.sayGender(\"这是什么性别的？\"); // 这是什么性别的？womensally.sayGender.call(bob,\"这是什么性别的？\"); // 这是什么性别的？man 这里最后一句代码的执行过程分析下： 将bob{gender: “man”}这个对象传递到People里面 更改函数里面this指向 继续执行函数里面其他代码 这里可以看出，bob这个对象继承要继承另外一个对象的某个方法的时候可以用上面这种写法 function.call(obj, argument) 同时也可以知道，this在函数里面的指向其实是可以有很多种的，要根据不同的环境来判断。 下面开始apply的例子，在开始 apply() 的例子之前先普及一下基本知识： 首先普及下一个概念 类数组（array-like） ，类数组其实我们平时接触的很多的。比如函数里面的 arguments对象 ，注意这里说的是 arguments对象 而不是 arguments数组 。因为arguments不是一个数组而是一个对象，只是我们平时用的时候喜欢用 arguments[0] 这样的写法所以看起来像数组而已。类数组通常的定义就是 有维护一个length属性 和 可以根据数字下标来获取元素 比如 arguments[0] 这样的一个对象。 不信的话我们可以测试下的： 12345function arrayLike() &#123; console.log(arguments instaceof Array); // false console.log(arguments instaceof Object); // true&#125;arrayLike(); 其实JavaScript里面的数组对象叫 关联数组 ，也就是我们数据库表那样的 键-值对 组成的形式。所以你如果以为JavaScript可以像其他语言那样优化循环比如 for(var i=0; i&lt;100; i++) 这样的过程的话你就想多了。 甚至，JavaScript的对象内部实现也是关联数组 ，比如你可以定义键为0而值为其他的对象。 123456var obj = &#123; 0: \"12345\"&#125;var arr = [\"12345\"];console.log(obj[0]); // 12345console.log(arr[0]); // 12345 有没有觉得JavaScript内部的实现其实很简单？或者可以说原理基本上就一个，但是通过简单的加点属性减点属性让对象跟数组看起来完全不一样。其实内部的实现原理是一模一样的。 废话扯得有点多，下面看 apply() 方法的例子： 1234567891011121314151617function People(gender) &#123; this.gender = gender; this.sayGender = function() &#123; var str = Array.prototype.join.call(arguments,\"\"); // arguments为类数组 console.log(str + this.gender); // &#125;&#125;var sally = new People(\"women\");var bob = &#123; gender: \"man\"&#125;var textArr = \"这是什么性别的？\".split(\"\"); // 这里将字符串分割为数组sally.sayGender.apply(bob, textArr); // 这是什么性别的？man 大概就到这里吧，有兴趣的可以留言讨论下。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"15条规则解析JavaScript对象布局（__proto__、prototype、constructor）","slug":"13-proto-prototype-constructor","date":"2016-03-26T16:05:41.000Z","updated":"2017-02-10T17:22:54.000Z","comments":true,"path":"2016/03/27/13-proto-prototype-constructor/","link":"","permalink":"http://www.manfredhu.com/2016/03/27/13-proto-prototype-constructor/","excerpt":"","text":"这篇是自己在之前的博客写的，各种转载就不说了。 大家都说JavaScript的属性多，记不过来，各种结构复杂不易了解。确实JS是一门入门快提高难的语言，但是也有其他办法可以辅助记忆。下面就来讨论一下JS的一大难点-对象布局，究竟设计JS这门语言的人当时是怎么做的？设计完之后又变成了什么？ 原型、构造函数和实例三者的关系我们来看一张图： 相信大家对这张图都不陌生了，构造函数有一个prototype属性指向其原型。相反原型也有一个constructor指向构造函数。与此同时实例也有一个constructor指向构造函数，这简直就是互相捆绑生怕找不到啊不是吗？ 还有一个我们称之为秘密链接的proto属性，原谅我第一眼见到这个属性就觉得特别的怪，_下划线都用上了，驼峰命名规则呢？好吧，这是部分浏览器暴露出来的一个指针而已，可能当时设计的时候随便写出来，突然发现这货有点用就留下了（纯属个人猜测）。 附上上图的检测代码不信的童鞋可以自己玩玩： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;JS函数原型，函数，实例的关系证明&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; function Foo()&#123;&#125; //构造函数 var a = new Foo(); //实例 console.log(Foo===Foo.prototype.constructor); //true console.log(a.constructor===Foo); //true console.log(Foo.prototype===Foo.prototype); //true console.log(a.__proto__===Foo.prototype); //true&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript Object Layout上面只是基础而已，下面才是真正的重点，为了修改这张图我可是煞费苦心，绞尽脑汁，不知道死了多少脑细胞。 可能大家已经看晕了，没事冲杯咖啡慢慢看。下面是相应的证明代码，友情提示sublimeText看更爽： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;JavaScript对象布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; //以下代码全部为true console.log(\"1:\"+(Object.prototype.__proto__ === null)); console.log(\"2:\"+(Function.prototype.__proto__===Object.prototype)); console.log(\"3.1:\"+(Number.__proto__ === Function.prototype)); console.log(\"3.2:\"+(Boolean.__proto__ === Function.prototype)); console.log(\"3.3:\"+(String.__proto__ === Function.prototype)); console.log(\"3.4:\"+(Object.__proto__ === Function.prototype)); console.log(\"3.5:\"+(Function.__proto__ === Function.prototype)); console.log(\"3.6:\"+(Date.__proto__ === Function.prototype)); console.log(\"3.7:\"+(Error.__proto__ === Function.prototype)); console.log(\"3.8:\"+(Array.__proto__ === Function.prototype)); console.log(\"3.9:\"+(RegExp.__proto__ === Function.prototype)); console.log(\"4.1:\"+(Math.__proto__===Object.prototype)); console.log(\"4.2\"+(JSON.__proto__===Object.prototype)); function Foo()&#123;&#125; //构造函数 var f1 = new Foo(); //实例 console.log(\"5:\"+(Foo===Foo.prototype.constructor)); console.log(\"6.1:\"+(f1.__proto__===Foo.prototype)); console.log(\"7:\"+(f1.constructor===Foo)); console.log(\"8.1:\"+(Number.prototype.__proto__===Object.prototype)); console.log(\"8.2:\"+(Boolean.prototype.__proto__===Object.prototype)); console.log(\"8.3:\"+(String.prototype.__proto__===Object.prototype)); console.log(\"8.5:\"+(Function.prototype.__proto__===Object.prototype)); console.log(\"8.6:\"+(Date.prototype.__proto__===Object.prototype)); console.log(\"8.7:\"+(Error.prototype.__proto__===Object.prototype)); console.log(\"8.8:\"+(Array.prototype.__proto__===Object.prototype)); console.log(\"8.9:\"+(RegExp.prototype.__proto__===Object.prototype)); console.log(\"9:\"+(Foo.__proto__===Function.prototype)); var manfred = new Object();//实例对象 console.log(\"10:\"+(manfred.__proto__===Object.prototype)); console.log(\"11:\"+(Foo.prototype.__proto__===Object.prototype)); //manfred为object构造函数产生，manfred.constructor指向function Object()构造函数 console.log(\"12:\"+(manfred.constructor.__proto__===Function.prototype)); console.log(\"13:\"+(manfred.constructor===Object.prototype.constructor)); var hu = new Function(); console.log(\"14:\"+(hu.constructor.__proto__===Function.prototype)); console.log(\"15:\"+(hu.constructor===Function.prototype.constructor)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 相信看完这些代码和原图比较之后大家对JS对象之间的关系已经了如指掌了，确实一开始我也让这货搞得头晕晕的，但是画出这张图之后已经觉得没什么了。大家可以自己动手画一下。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"2015年阿里巴巴校招题目","slug":"10-AlibabaExamination","date":"2016-03-24T12:17:37.000Z","updated":"2017-02-10T17:26:12.000Z","comments":true,"path":"2016/03/24/10-AlibabaExamination/","link":"","permalink":"http://www.manfredhu.com/2016/03/24/10-AlibabaExamination/","excerpt":"","text":"以下题目是阿里巴巴2015校招的题目，纯粹个人恶趣味发作写着玩的。有错的地方欢迎联系交流^_^ 第一题1234567//第一题var array1 = [1,2];var array2 = array1;array1[0] = array2[1];array2.push(3);console.log(array1) //[2 2 3]console.log(array2) //[2 2 3] 第二题12345678910111213//第二题function a(x, y) &#123; return function() &#123; y = function() &#123; x = 2; &#125;; var x = 3; y(); console.log(x); //2 &#125;.apply(this.arguments);&#125;a(); 第三题1234567891011//第三题var name = 'World!';(function() &#123; if(typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye' + name); //Goodbye Jack &#125;else&#123; console.log('Hello' + name); &#125;&#125;)(); 第四题1234567//第四题下面那些语句的结果是trueFunction instanceof Object //trueObject instanceof Function //truetypeof Object.prototype === 'object' //truetypeof Function.prototype === 'object' //false 第五题1234567//第五题一个页面存在A元素和B元素;B元素浮在A元素之上;在B元素上绑定了touchstart事件，在touchstart事件处理函数中的哪些操作会导致A元素触发click事件？（这里是HTML5的点击穿透BUG，click事件会在touchstart和touchend后面发生，所以如果在touchstart将B元素移除则A元素会受到click触发）A.设置B元素CSS属性display为none //YesB.设置B元素CSS颜色C.将B元素从DOM树上删除 //YesD.设置B元素CSS属性visibility为hidden 第六题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//第六题编写一个javascript函数，可以在页面上异步加载js,在加载结束后执行callback，并在IE和Chrome下都能执行//方法一function loadScript(url,callback) &#123; //兼容IE和Chrome获取XMLHttpRequest对象 var xhr = (function() &#123; if(window.XMLHttpRequest) &#123; return new XMLHttpRequest(); &#125;else if(window.ActiveXObject) &#123; return new ActiveXObject('Microsoft.XMLHTTP'); &#125;else&#123; throw new Error(\"loadScript():XMLHttpRequest Init Error\"); &#125; &#125;)(); xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4) &#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123; callback(); &#125; &#125; &#125; //用GET方式异步加载JavaScript代码 xhr.open('GET',url,true); xhr.send(null);&#125;//方法二function loadScript(url, callback) &#123; //同步 var script = document.createElement(\"script\"); script.type = \"text/javascript\"; if (script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if (script.readyState == \"loaded\" || script.readyState == \"complete\") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function() &#123; callback(); &#125;; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125; 第七题1234567891011121314151617181920212223//第七题//为字符串实现一个render方法，实现下面的变量替换功能(function() &#123; String.prototype.render = renderFunc; function renderFunc(obj) &#123; if(typeof obj !== 'object') throw new Error('The arguments must be obj'); return this.replace(/\\$\\&#123;([^&#125;]+)\\&#125;/gi, function(a, b) &#123; //这里的a是 $&#123;name&#125; //b是name return obj[b] ? obj[b] : ''; &#125;); &#125; var greeting = 'my name is $&#123;name&#125;,age $&#123;age&#125;'; var result = greeting.render(&#123; name: 'XiaoMing', age: 11 &#125;); console.log(result); //my name is XiaoMing,age 11&#125;)(); 第八题12345678910111213141516171819202122232425262728//第八题//用JS实现随机选取10-100之间的不同的10个数字，存入一个数组并降序排序(function() &#123; function creatNumber(num) &#123; if(typeof num !== 'number') return; var arr = []; for (var i = 0; i &lt; num; i++) &#123; arr.push(parseInt(Math.random() * 90 + 10)); &#125; return arr; &#125; //降序排列 function sortOrder(a,b) &#123; return b-a; &#125; function getIsArray() &#123; return Array.isArray ? Array.isArray : function(arr) &#123; return Object.prototype.toString.call(arr).slice(8, -1) === 'Array'; &#125; &#125; var arr = creatNumber(10); var isArray = getIsArray(); if(!isArray(arr)) throw new Error(\"init Array Error\"); console.log(arr.sort(sortOrder));&#125;)();","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"Canvas一般用法","slug":"9-Canvas","date":"2016-03-10T12:54:38.000Z","updated":"2016-12-02T17:42:04.000Z","comments":true,"path":"2016/03/10/9-Canvas/","link":"","permalink":"http://www.manfredhu.com/2016/03/10/9-Canvas/","excerpt":"","text":"what is CanvasCanvas是HTML5的绘图接口，可以提供用JavaScript绘制位图的功能。 APICanvas的API众多，这里举几个常用的。(好久没看都快忘了。。。) 1.beginPath() 让canvas根据需要计算图形的内部和外部范围，通常在绘图开始会有2.moveTo(),lineTo() 移动和画线函数，但是不会马上绘制(paint)3.stroke(绘制)和fill(填充)会马上绘制图形显示出来4.lineWidth可以改变线条宽度5.strokeStyle可以改变绘制颜色 缓存Canvas成数据用canvas.toDataURL(type)可以获取data URL格式的Canvas数据 DEMO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function createCanopyPath(context) &#123; //绘制树 context.beginPath(); context.moveTo(-25, -50); context.lineTo(-10, -80); context.lineTo(-20, -80); context.lineTo(-5, -110); context.lineTo(-15, -110); context.lineTo(0, -140); context.lineTo(15, -110); context.lineTo(5, -110); context.lineTo(20, -80); context.lineTo(10, -80); context.lineTo(25, -50); context.closePath();&#125;function drawTrails() &#123; var canvas = document.getElementById('trails'); var context = canvas.getContext('2d'); context.save(); //移动画布 context.translate(130, 250); //绘制树的上半部分 createCanopyPath(context); //线条宽度 context.lineWidth = 4; //拐角显得平滑 context.lineJoin = 'round'; //设置颜色并且绘制 context.strokeStyle = '#663300'; context.stroke(); //填充颜色 context.fillStyle = '#339900'; context.fill(); context.fillStyle = '#663300'; context.fillRect(-5, -50, 10, 50); //恢复初始状态 context.restore(); // Save the canvas state and draw the path context.save(); context.translate(-10, 350); context.beginPath(); // The first curve bends up and right context.moveTo(0, 0); //绘制曲线 context.quadraticCurveTo(170, -50, 260, -190); // The second curve continues down and right context.quadraticCurveTo(310, -250, 410,-250); // Draw the path in a wide brown stroke context.strokeStyle = '#663300'; context.lineWidth = 20; context.stroke(); // Restore the previous canvas state context.restore();&#125;window.addEventListener(\"load\", drawTrails, true);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"Canvas","slug":"笔记/Canvas","permalink":"http://www.manfredhu.com/categories/笔记/Canvas/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"Canvas","slug":"Canvas","permalink":"http://www.manfredhu.com/tags/Canvas/"}]},{"title":"string.Replace用法","slug":"8-stringReplace","date":"2016-03-06T02:45:26.000Z","updated":"2017-02-10T18:04:01.000Z","comments":true,"path":"2016/03/06/8-stringReplace/","link":"","permalink":"http://www.manfredhu.com/2016/03/06/8-stringReplace/","excerpt":"","text":"replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 基本用法12var str=\"Manfred Hu\"document.write(str.replace(/Manfred/, \"WenFeng\")); //页面输出WenFeng Hu 这是比较基本的用法，还有一种是第二个参数不是&quot;WenFeng&quot;而是一个函数的时候。 第二种用法123456789101112131415161718192021//define(function(window)&#123; //构造函数fn function fn(str)&#123; this.str=str; &#125; fn.prototype.format = function()&#123; var arg = arguments; return this.str.replace(/\\&#123;(\\d+)\\&#125;/ig,function(a,b)&#123; return arg[b]||\"\"; &#125;); &#125; window.fn = fn;&#125;)(window);//use(function()&#123; var t = new fn('&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;'); //类似参数化的输出 console.log(t.format('http://www.alibaba.com','Alibaba','Welcome')); //&lt;p&gt;&lt;a href=\"http://www.alibaba.com\"&gt;Alibaba&lt;/a&gt;&lt;span&gt;Welcome&lt;/span&gt;&lt;/p&gt;&#125;)(); 你可以能会奇怪这里a和b到底是什么。分析下： 两个都是立即执行函数，所以顺序执行先定义后执行。fn.prototype.format是添加在原型的方法，可以让所有实例共享，然后向全局环境window挂载fn fn是全局的构造函数，下面一个立即执行函数创建了一个实例，传入字符串为参数，然后用console.log()输出调用format的结果 format函数执行，传入三个参数。到了原型的format函数的执行 arg为arguments[3],是上面传来的三个参数。this为var t = new fn(&#39;&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;&#39;);的t 因为正则式有ignore和global，所以可以全局匹配并且忽略大小写。重点来了 这里的a是匹配串，b是捕获串，返回值会用来替换匹配串 这里记录下程序执行过程。 a为{0},b为0。返回值为arg[0]就是http://www.alibaba.com 因为是全局匹配，所以有第二次替换匹配串。 a为{1},b为1。返回值为arg[0]就是Alibaba 省略 replace后面是function的用法比较少见，有第二个参数的就更少见了。 这里顺手输出了replace中function的arguments来看看。 12arguments[\"&#123;1&#125;\", \"1\", 17, \"&lt;p&gt;&lt;a href=\"&#123;0&#125;\"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;\"] 总结API：stringObject.replace(regexp/substr,replacement) 所以replacement这个function有四个参数，分别是 匹配串 捕获串 匹配串(这里是从’{‘开始)在 stringObject 中出现的位置 原来的字符串 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"}]},{"title":"常见数据结构算法","slug":"7-dataStructure","date":"2016-03-04T14:57:08.000Z","updated":"2016-03-04T16:01:32.000Z","comments":true,"path":"2016/03/04/7-dataStructure/","link":"","permalink":"http://www.manfredhu.com/2016/03/04/7-dataStructure/","excerpt":"","text":"前言数据结构的重要性就不多说了，一名合格的程序猿/媛，必修的科目。这里列举常见的前端开发面试会遇到的数据结构面试题，好像基本都是要手写代码的。这里的代码不限制于javascript语言，默认升序排列，有特别的地方会指出来。 冒泡排序[稳定 平均O(n^2)，最好O(n)，最坏O(n^2)]12345678910function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; swap(arr[j + 1], arr[j]); &#125; &#125; &#125;&#125; 选择排序[稳定 平均最好最坏都为O(n^2)]123456789101112function selectSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; var min = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr[min], arr[i]); &#125;&#125; 快速排序[不稳定 平均最好O(nlogn),最坏O(n^2) 需要辅助空间]123456789101112131415161718function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1); var left = [], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(pivot, quickSort(right));&#125; 二分查找[logn]12345678910111213141516function binarySearch(arr, key) &#123; var low = 0, high = arr.length, middle; while (low &lt; high) &#123; middle = Math.floor((low + high) / 2); if (key === arr[middle]) &#123; return key; &#125; else if (key &lt; arr[middle]) &#123; high = middle - 1; &#125; else if (key &gt; arr[middle]) &#123; low = middle + 1; &#125; &#125; return -1;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"数据结构","slug":"笔记/数据结构","permalink":"http://www.manfredhu.com/categories/笔记/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.manfredhu.com/tags/数据结构/"}]},{"title":"javascript-closure","slug":"6-javascript-closure","date":"2016-01-22T15:56:19.000Z","updated":"2017-01-15T15:32:47.000Z","comments":true,"path":"2016/01/22/6-javascript-closure/","link":"","permalink":"http://www.manfredhu.com/2016/01/22/6-javascript-closure/","excerpt":"","text":"词法作用域（Lexical scoping）、声明上下文对象（Declaration context object）说到变量，我们会关注变量的两个东西。 作用域-空间来理解变量的存在 生命周期-时间来理解变量的存在 变量的词法作用域是指在程序源代码定义的这个变量的区域。通常分为函数和全局两部分。 12345var scope = \"global\"; //全局作用域function func() &#123; var scope = \"local\"; //函数作用域，只在这个函数内存活 return scope;&#125; 那如果换成下面这样的呢？ 12345678910var scope = \"global\"; //全局作用域function checkscope()&#123; var scope = 'local'; //外层函数的作用域 function nested() &#123; var scope = 'nested'; //内层函数的作用域 return scope; &#125; return nested();&#125;console.log(checkscope()); //nested 结论：当代码被编译器读取，词法作用域就已经确定了而这跟下面的变量作用域和闭包又会有关联,词法作用域到函数执行时依然是有效的。浏览器提前做好了大部分的工作，所以JS很快，so fast!! 编译过程干了什么？传统的编译器会干这些东西 词法分析过程，将代码读取并且扫描代码，分解成一个一个的词 语法分析过程，分解语法短语构造语法树 语义分析过程，审查代码是否有错，收集各个阶段类型的信息 代码优化过程，对中间代码进行优化，使其更加高效 生成目标代码，即二进制的本地代码 具体到浏览器的引擎，也不外乎是这几个过程。我们能明显感受到的就是下面几个过程。 声明函数、变量——声明提升 检查代码，优化——代码执行效率大大提高，有ERROR 上面两个过程，很明显可以体会到上面1-4步的过程。而最后一步，学过计算机的都懂的。我们来看下面的代码体会下编译过程干的事情——声明提升 123456var scope = \"global\";function f() &#123; console.log(scope); //undefined var scope = \"local\"; console.log(scope); //local&#125; 这段代码跟下面是等价的，只是下面的看起来更清晰,编译器干的事情也更少。 1234567var scope = \"global\";function f() &#123; var scope; console.log(scope); //undefined scope = \"local\"; console.log(scope); //local&#125; 变量的作用域和生命周期JS中变量的生命周期跟函数有关，函数内定义的变量在函数执行结束后会释放。JS中变量的作用域也跟函数有关，内层函数可以随作用域链访问外层函数的变量。具体原因就是作用域链的存在。 所以你不难看出，为什么JS里面函数非常非常重要，也许你应该听过了： JavaScript的世界里函数是一等公民 正正因为你用的变量的生命周期和作用域都跟函数有关。你平常是否想到了呢？但是闭包是个bug，它为你提供了破坏这种已定规则的限制。为你的代码提供无限可能，这也许就是JavaScript真正的魅力所在，它让一切变得可能。 函数如果嵌套的话，随作用域链来定，如果作用域链上没有则访问不到。会出现ReferenceError 执行环境（execution context）、作用域链（scope chain）的创建上面都是程序还没运行的时候干的事情，下面来说下程序运行起来会发生什么。 当JavaScript在运行的时候，也就是某个函数被调用时，会创建一个执行环境（execution context），以及相应的作用域链。然后使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)，也有称为作用域对象（scope object）的。这东西你摸不到看不见，但是它却真正存在着——就像真理 活动对象（activation object）、作用域对象（scope object）当我们的代码有多个函数嵌套的时候，一个个作用域对象就被串联起来形成作用域链（Scope chain） 闭包我至少见过N种定义闭包概念的版本，让我们来欣赏一下： 函数对象可以通过作用域相互关联，函数体内部的变量可以保存在函数作用域内这种观点引申出来的就是，所有JavaScript函数都是闭包。因为它们都是对象，都关联到作用域链。 函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量包裹起来了这是从计算机科学文献中引申出来的闭包的解释。 闭包是指有权访问另一个函数作用域中的变量的函数这是《JavaScript高级程序设计第三版》的定义。也就是说至少需要2个函数才能构成闭包 闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。这是MDN的解释。闭包由两部分构成：函数以及创建改函数的环境环境由闭包创建时在作用域中的任何局部变量组成。 现在觉得，上面说的其实都有道理。特别是第二个和第三个解释,所以我觉得最最准确描述就是下面两句了。 闭包是指有权访问另一个函数作用域中的变量的函数","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"JavaScript","slug":"笔记/JavaScript","permalink":"http://www.manfredhu.com/categories/笔记/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"}]},{"title":"Object.defineProperties的实际作用（MEAN开发Model层的写法）","slug":"5-MEANdevelop-ModelProblem","date":"2016-01-21T06:43:50.000Z","updated":"2016-03-10T15:04:24.000Z","comments":true,"path":"2016/01/21/5-MEANdevelop-ModelProblem/","link":"","permalink":"http://www.manfredhu.com/2016/01/21/5-MEANdevelop-ModelProblem/","excerpt":"","text":"Object.defineProperties是什么？有什么用？这个问题比较听起来可能比较难以理解，确实我也是在项目中遇到的才会去想。以前看到《高级程序设计》的时候，有这么一种东西，定义一个对象。大概第几章忘了，看下下面的代码估计能想起来是什么。 12345678910111213141516171819202122232425262728293031var User = &#123;&#125;; //声明一个空对象Object.defineProperties(User, &#123; //填充对象属性 _id: &#123; writable: true, //设置属性是否可写，默认为true configurable: false, //设置属性是否可以配置，默认为true。当设置为false时不能用delete删除 enumerable: false, //设置属性是否可以枚举，默认为true.即for-in循环对象的时候可以输出属性 value: 0 //默认值 &#125;, id: &#123; set: function(value) &#123; if(value &gt; 0) &#123; this._id = value; //数据库设置的为主键从0开始递增 &#125; &#125;, get: function() &#123; return this._id; &#125; &#125;&#125;);var privateId = Object.getOwnPropertyDescriptor(User, '_id');console.log(privateId.value); //0var userId = Object.getOwnPropertyDescriptor(User, 'id');console.log(userId.get()); //还没设置呢，输出undefineduserId.set(10); //设置id为10console.log(userId.get()); //输出10，设置有效userId.set(-10);console.log(userId.get()); //输出10，设置无效 大概就是Object.defineProperties这个东西吧，可以定义属性。定义一个属性用的是Object.defineProperty。不过通常对象都是多个属性的啦，所以基本用的都是Object.defineProperties。 其实刚开始我看到这个属性觉得——嗯，有这个东西。但是具体哪里会用到，有什么作用，还真的没去思考太多。只是知道有这个东西，但是普通的前端开发，貌似也没怎么用到这个东西，直到——做项目的时候遇到了-_-!! MEAN开发Model层的写法副标题扯到MEAN开发了，之前做的项目里面，前端用的是AngularJS，后台用的是ExpressJS+node.js数据交互不用想都知道是Ajax啦。 所以从第一天开始就开开心心撸代码啦，嗯，差不多就这样。^_^ 写后台的时候遇到了几个坑爹的问题吧，首先是登陆模块。AngularJS用$httppost到/loginData一个表单到后台 比如是下面这样的1234var json = &#123; username: \"ManfredHu\", password: \"123456\"&#125;; 后台用ExpressJS的路由监听这个URI12345app.post('/loginData', function(req, res) &#123; console.log(\"接受到login页面的登陆信息\"); //调用login控制器传入req,res UserCtrl.login(req, res);&#125;); 这个ExpressJS的路由其实类似JavaWeb里面的web.xml那个配置servlet的东西。就是一个请求过来，你到底要调用哪个Controller到处理。这里专门为User写了个Controller取名UserCtrl，通过CMD的形式组织，exports暴露了一个login的方法专门处理request/response。 然后问题就坑爹了，前端数据的验证怎么做？如果直接将JSON传入Dao层执行数据库的查找等等的匹配操作。那么其实问题其实还挺大的，你要考虑如果有人专门来POST数据测试你的服务器呢？当然我相信大家都是好人不会去干这种事，不过从安全性来讲，应该是要有一层验证的，而且后面的Dao层也会接受一个对象去执行增删查改等等操作 这里讲的是后台的数据验证 所以上面的Object.defineProperties就派上用场了，应该要将这个json组装成一个Model，且这个Model应该有类似C#、Java一样的私有属性private、公有方法public等等。 C#的属性的概念其实相比字段就是多了一层过滤层，因为属性都是合法的字段。123456789101112131415public class Student &#123; private string name; //字段 public string Name //属性 &#123; set &#123; name=value; //这里是给私有属性name赋值 &#125; get &#123; return name; //这里取出私有属性name的值 &#125; &#125; &#125; Java的类似，不过没有C#属性的概念，所有的都称为方法。123456789public class Student &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 所以其实JavaScript要模仿这些传统的后台，也要有一个类似类的概念的东西——Object.defineProperties 上面的代码类似声明了一个类，定义了私有的属性_id,公有的方法id,里面有set和get方法。那其实思路就变得很简单了，将POST的JSON数据包装成Model（这个过程会检验属性的正确性），然后对Model进行DAO操作。JavaScript模拟传统后台的东西就完全出来了。 当然其实这部分包装成Model的过程完全可以不考虑，但是验证的过程你要写在Controller或者其他地方，既然都要写的，那还不如像传统后台一样多一层Model层。而且运行node.js的Chrome的V8解析器完全可以忽略Object.defineProperties的兼容性问题。 综上所述,Object.defineProperties在开发后台的时候，用处非常大。可以用来创建实体类。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/categories/随笔/"},{"name":"JavaScript","slug":"随笔/JavaScript","permalink":"http://www.manfredhu.com/categories/随笔/JavaScript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.manfredhu.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.manfredhu.com/tags/JavaScript/"}]},{"title":"AngularJS笔记","slug":"4-angular-note","date":"2016-01-20T05:00:38.000Z","updated":"2017-02-10T18:05:42.000Z","comments":true,"path":"2016/01/20/4-angular-note/","link":"","permalink":"http://www.manfredhu.com/2016/01/20/4-angular-note/","excerpt":"","text":"AngularJS兼容性 1.3.0版本放弃了IE8（官网有兼容的方法） 引入了单向数据绑定 AngularJS的MVVM的原理与传统的MVC不同，这里的view不是jsp或者aspx之类的。M也不一样，这里是ViewModel。AngularJS通过Binder/Data-binding engine(通常称为Binder)将模板Template与ViewModel关联起来且通过dirty-checking来实现实时的更新 指令的执行过程加载阶段从angular.js下载到客户端开始执行进入引导阶段，AngularJS会初始化自身需要的组件，查看ng-app边界，然后加载模块，使用依赖注入来注入依赖。 编译阶段(compile)编译阶段模板将被搜索指令，然后指令会链接到AngularJS内置库或自定义指令代码相应的部分上。指令detective与作用域scope相结合产生实时视图。 链接阶段(link)当引导和编译阶段完成之后，AngularJS进入运行时数据绑定阶段。这个阶段的特点是任何在作用域的更改都会反映在视图上，并且视图的更改也会更新到作用域。也称为双向绑定。 AngularJS的MVVM是借助$scope实现的 $scope有事件机制，如$emit(“EventName”)向上传播和$broadcast(“EventName”)向下传播 $scope是一个普通的JS对象（POJO—-plain old javascript object普通JS对象） $scope提供了一些工具方法 $watch() / $apply() $scope是表达式的执行环境（或者叫作用域） $scope是一个平行DOM结构的树形结构的对象 子$scope对象会继承父$scope上的属性和方法 每个应用都有且只有一个rootScope的对象，通常是在 ng-app 上 这样子层标签就可以继承父级标签的方法（个人猜测$scope是挂载在DOM结构的一组JS对象，映射关- 系，与jQ的data数据缓存原理类似） Angular默认的请求头12Accept: application/json,text/plain,X-Requested-With: XMLHttpRequest 设置请求头的第一种方法，如果想把请求头设置到每一个发送出去的请求上，则可以将其设置为AngularJS的默认值，可以通过$httpProvider.defaults.headers配置对象来设置 123456angular.module('MyApp',[]).config(function($httpProvider) &#123; //删除AngularJS默认的X-Request-With头 delete $httpProvider.default.headers.common['X-Requested-With']; //为所有GET请求设置DO NOT TRACK $httpProvider.default.headers.get['DNT'] = '1';&#125;); 第二种方法是不将其作为默认值，则可以将头信息作为配置对象的一部分传递给$http服务 Angular转换请求和响应转换请求如果请求的配置对象属性中包含JS对象，那么就把这个对象序列化成JSON格式 转换响应如果检测到了XSRF（Cross Site Request Forgery）跨站请求伪造，则直接丢弃，如果检测到了JSON响应，则使用JSON解析器对其进行反序列化 如果想自定义转换规则则设置transformRequest和transformResponse作为key来配置转换函数 12345678var module = angular.module(&apos;myApp&apos;);module.config(function($httpProvider)&#123; $httpProvider.defaults.transformRequest = function(data) &#123; //使用jQuery的param方法 //把JSON数据转化成字符串形式 return $.param(data); &#125;&#125;);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"AngularJS","slug":"笔记/AngularJS","permalink":"http://www.manfredhu.com/categories/笔记/AngularJS/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"AnuglarJS","slug":"AnuglarJS","permalink":"http://www.manfredhu.com/tags/AnuglarJS/"}]},{"title":"CSS笔记","slug":"3-CSS-note","date":"2016-01-17T12:27:02.000Z","updated":"2017-02-10T18:05:31.000Z","comments":true,"path":"2016/01/17/3-CSS-note/","link":"","permalink":"http://www.manfredhu.com/2016/01/17/3-CSS-note/","excerpt":"","text":"清除浮动老生常谈的话题，面试经常问的问题解决方法有很多种，这里讲几种 子元素加clear1234&lt;div class=\"news\"&gt; &lt;p&gt;Some Text&lt;/p&gt; &lt;br class=\"clear\"&gt;&lt;/div&gt; 12345678910.news&#123; background: gray; border: solid 1px black;&#125;.news p&#123; float: right;&#125;.clear&#123; clear: both;&#125; 这种方法可以扩展出很多种不同的方法，如JS动态添加，设置一个公共的类然后添加，或者直接就是一段内联style的html代码，但是原理都是用到了clear这个属性 父元素BFC化HTML文档流是盒子模型的，BFC就是组织盒子模型的形式，当元素的类型如标签(p和span)不一样的时候，其表现出来的样子是不一样的。所以BFC就是让这个元素看起来像盒子的一种代称，BFC全称 Box Formatting Context。CSS2.1还有IFC,即Inline Formatting Context。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 BFC的区域不会与float box重叠 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 计算BFC的高度时，浮动元素也参与计算 产生BFC的条件：当然普通的块级元素默认呈现块级的样子，但是通过CSS我们可以可以让某些元素呈现BFC的形态（块级形态） 根元素(html元素) float不为none的元素(包括left,right,inherit三个，因为float只有四个值) position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inline-flex overflow不为visible(包括hidden,scroll,auto,inherit四个值) 如下面的为在父元素加float属性使其BFC化 1234&lt;div class=\"news\"&gt; &lt;p&gt;Some Text&lt;/p&gt; &lt;br class=\"clear\"&gt;&lt;/div&gt; 12345678910.news&#123; background: gray; border: solid 1px black;&#125;.news p&#123; float: right;&#125;.clear&#123; clear: both;&#125; 透明度opacity opacity属性是CSS3新增的属性，取值为0.0(完全透明)到1.0(完全不透明)，后代元素也会一起被影响 12345p&#123; filter: alpha(opacity=80); /*IE5-7，注意这里取值80*/ opacity: 0.8; /*IE8+*/ color: #000;&#125; RGBARGBA是扩展透明度的一种格式，a代表alpha透明度。IE9+支持RGBA写法。 1234p&#123; background-color: rgba(0,0,0,0.8); /*取值0-1*/ color: #fff;&#125; RGBA与opacity的区别是：opacity会影响整个元素，而RGBA影响单一的属性。 PNG图片的问题png图片的最大优势是支持alpha透明度，但是IE6不直接支持PNG透明度，PNG透明度自IE7才支持。好的是现在已经逐渐淘汰了IE6， 拥有布局的问题默认拥有布局的元素： body/html table/tr/td img hr input/select/textarea/button iframe/embed/object/applet/marquee 所以其实div和span是没有布局的。 设置以下CSS属性会让元素获得布局。 float: left/right display: inline-block width/height zoom: 任何值（只有IE） IE7中以下属性也触发布局(下面三个属性只有IE7+才支持) overflow: hidden/scroll/auto min-width: 任何值 max-width: 除none之外的任何值 条件注释 lt &lt; lte &lt;= gt &gt; gte &gt;= 条件注释写法如下，这里的是XHTML写法，所以后面会以/&gt;结尾，HTML5写法最好是没有反斜杠 1234567891011&lt;!-- [if IE 6]&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/ie6.css\" /&gt;&lt;![endif]--&gt;&lt;!-- [if !IE 6]&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/ie6.css\" /&gt;&lt;![endif]--&gt;&lt;!-- [if gte IE 6]&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css/ie6.css\" /&gt;&lt;![endif]--&gt; IE常见的BUG及其解决方法下面这些BUG都是很有代表性的，在我做的项目中下面的bug基本都遇到了。-_-!!这运气真不是一般好。当然现在说起IE6兼容很多人可能会嗤之以鼻，但是我觉得在天朝大国这个连学校都在用着XP的地方，身为一名合格的前端，IE6兼容必须要过关。 双外边距浮动BUG在元素有外边距且浮动的时候 1234div.someone&#123; float: left; margin-left: 20px;&#125; 解决方法对float的元素设置display:inline 12345div.someone&#123; float: left; margin-left: 20px; display: inline;&#125; 3像素文本偏移bug当文本与一个浮动元素相邻时这个bug有可能出现 1234567div.myFloat&#123; float: left; width:200px;&#125;p&#123; margin-left:200px;&#125; 解决方法(IE6以上) 1234567p&#123; height: 1%; /*拥有布局*/ margin-left: 0;&#125;.myFloat&#123; margin-left: -3px; /*重要的一句，等于左边的浮动元素的宽度缩小了3px*/&#125; IE6的重复字符bug当一系列浮动元素排列在一排，如果最后的元素重复出现则是这个bug。ps：通常是代码有添加注释的情况 解决方法 运用负外边距 清除注释 IE6的“躲猫猫”bug当一个浮动元素后面跟着一些非浮动元素，然后是一个清理元素，所有这些元素包含在一个设置了背景颜色或图像的父元素中。如果清理元素碰到了浮动元素，那么中间的非浮动元素看起来像消失了，只有在刷新页面的时候才出现。 解决方法 去掉父元素上的背景颜色或图像 避免清理元素与浮动元素接触 容器指定行高 将浮动元素和容器元素的position属性设置为relative","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"CSS","slug":"笔记/CSS","permalink":"http://www.manfredhu.com/categories/笔记/CSS/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"http://www.manfredhu.com/tags/CSS/"}]},{"title":"到了HTML5时代写HTML代码要注意的东西","slug":"2-someAboutHTML5","date":"2016-01-17T11:16:21.000Z","updated":"2017-02-10T18:05:57.000Z","comments":true,"path":"2016/01/17/2-someAboutHTML5/","link":"","permalink":"http://www.manfredhu.com/2016/01/17/2-someAboutHTML5/","excerpt":"","text":"DOCTYPE这是一个写在HTML头部的东西，浏览器会根据不同的DOCTYPE来识别不同的模式，后面的渲染和优化也会不一样，作为一个前端我们会严格要求自己。所以通常会copy一下的是不是^_^。但是在Eclipse中默认的不是HTML5的DOCTYPE,切记切记改过来噢亲。 常见的DOCTYPE有 1.HTML 4.01 Strict 1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt; 2.XHTML 1.0 Strict 12&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt; 标签不再自闭合如果你从XHTML开始严格要求自己，你会经常写这样的代码 1&lt;input type=\"text\" placeholder=\"请输入作者……\" id=\"writer\" name=\"writer\" /&gt; 本来这应该是没错的，但是如果转到HTML5时代的话，后面的/&gt;变成&gt;会更好。 自己有时候也没意识过来，在XHTML时代这种叫自闭合标签，但是在HTML5时代，不需要了。 字符编码不用写那么长了还有的，如charset也不用像下面这样写了。 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"&gt; 取而代之的是下面这样简便的写法 1&lt;meta charset=\"utf-8\"&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/categories/笔记/"},{"name":"HTML","slug":"笔记/HTML","permalink":"http://www.manfredhu.com/categories/笔记/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://www.manfredhu.com/tags/HTML/"},{"name":"笔记","slug":"笔记","permalink":"http://www.manfredhu.com/tags/笔记/"}]},{"title":"博客园博客已迁移到此","slug":"1-firstArchive","date":"2016-01-17T11:16:10.000Z","updated":"2017-04-05T13:45:52.000Z","comments":true,"path":"2016/01/17/1-firstArchive/","link":"","permalink":"http://www.manfredhu.com/2016/01/17/1-firstArchive/","excerpt":"","text":"欢迎您来到我的新博客，我是ManfredHu.原博客园的博主，博客园博客已停止使用以后全部文章更新会转移到这个博客。谢谢大家观看！！^_^","categories":[],"tags":[{"name":"杂文","slug":"杂文","permalink":"http://www.manfredhu.com/tags/杂文/"}]}]}